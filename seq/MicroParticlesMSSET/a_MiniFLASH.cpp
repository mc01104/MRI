//-----------------------------------------------------------------------------
//  Copyright (C) Siemens AG 1998-2006  All Rights Reserved.  Confidential
//-----------------------------------------------------------------------------
//
// Project: NUMARIS/4
//
//    File: \n4\pkg\MrServers\MrImaging\seq\a_MiniFLASH\a_MiniFLASH.cpp
//
// Authors: Mark Brown;       SMS MED US CSG TDC;
//          Brian Dale;       SMS MED US CSG MR R&D;
//          Wolfgang Rehwald; SMS MED US CSG MR R&D;
//          Keith Heberlein;  SMS MED US CSG MR R&D;
//
//          Original Author:  Anonymous
//
//    Lang: C++
//
// Descrip: This is the demo sequence MiniFLASH.
//          DO NOT base any diagnosis on images generated by this sequence.
//
//////////////////////////////////////////////////////////////////////////////////////////
//
//                                MiniFLASH Sequence Diagram
//
//                       |-----------TE-------------|
//
//              RF --|sSRF01|--------------------------------------------
//
//              Gs -|sGSliSel|-|sGSliSelReph|-------------|sGSpoil|------
//
//              Gp ----------|sGPhasEnc|------------------|sGPhasEncRew|-
//
//              Gr ----------|sGReadDeph|-------|sGradRO|----------------
//
//             ADC -----------------------------|sADC01|-----------------
//
//                |------------------------------TR----------------------|
//
///////////////////////////////////////////////////////////////////////////////////////////

#include "MrServers/MrImaging/seq/capsuleCL/a_MiniFLASH.h"
#include "MrServers/MrImaging/seq/common/feedbackData.h"
#include "MrServers/MrImaging/seq/capsuleCL/a_MiniFLASH_UI.h"
#include "MrServers/MrMeasSrv/SeqIF/csequence.h"
#include "MrServers/MrImaging/libSeqSysProp/SysProperties.h"
#include "MrServers/MrImaging/seq/SystemProperties.h"        // Siemens system properties
#include "MrServers/MrImaging/ut/libsequt.h"                 // for mSEQTest

#ifdef WIN32
    #include "MrServers/MrMeasSrv/SeqIF/Sequence/Sequence.h"
    #include <iostream>
    #include <fstream>
	using namespace std;
#endif

//#include <iostream>
// Macro: return S, if S is an error code
// (applies to functions returning MRRESULT-values)
#define OnErrorReturn(S) if(!MrSucceeded(S)) return(S)


#ifndef SEQ_NAMESPACE
    #error SEQ_NAMESPACE not defined
#endif



//  --------------------------------------------------------------------------
//
//  Name        :  SEQIF_DEFINE
//
//  Description :
///  \brief        Create instance of the sequence
//
//  Return      :  SeqIF *
//
//  --------------------------------------------------------------------------
#ifdef SEQUENCE_CLASS_MiniFLASH
    SEQIF_DEFINE (SEQ_NAMESPACE::MiniFlash)
#endif
using namespace SEQ_NAMESPACE;
using namespace WPT_NAMESPACE;

double gThetaFinal1;
//double gThetaFinal2;
double gK1;
double gK2;
double gtMeas;
double gtRTFeedBack;
double gtRTFeedBack2;
double g_theta = 0.0;
double g_deltaTheta = 2*M_PI;
double g_time_sin = 0.0;

#ifdef WIN32
	const uint16_t CAPACITY = 10000;
	double g_gradValuesHistory[CAPACITY] = {0};
	uint16_t g_gradIndex = 0;
	fstream g_fileID;
#endif


MiniFlash::MiniFlash()
        : m_sGActuateX          ("sGActuateX")
		, m_sGActuateY          ("sGActuateY")
		, m_sGActuateZ          ("sGActuateZ")
		, m_sWakeUp             ("sWakeUp")
		, m_sSRF01				("sSRF01")
		, m_sSRF01zSet          ("sSRF01zSet")
		, m_sSRF01zNeg			("sSRF01zNeg")
		, m_sSRF02				("sSRF02")
		, m_sSRF02zSet          ("sSRF02zSet")
		, m_sSRF02zNeg			("sSRF02zNeg")
		, m_sSRF01OffsetNegative     ("sSRF01OffsetNegative")
		, m_sSRF01zSetOffsetNegative ("sSRF01zSetOffsetNegative")
		, m_sSRF01zNegOffsetNegative ("sSRF01zNegOffsetNegative")
		, m_sSRF01OffsetPositive     ("sSRF01OffsetPositive")
		, m_sSRF01zSetOffsetPositive ("sSRF01zSetOffsetPositive")
		, m_sSRF01zNegOffsetPositive ("sSRF01zNegOffsetPositive")
		, m_sSRF02OffsetNegative     ("sSRF02OffsetNegative")
		, m_sSRF02zSetOffsetNegative ("sSRF02zSetOffsetNegative")
		, m_sSRF02zNegOffsetNegative ("sSRF02zNegOffsetNegative")
		, m_sSRF02OffsetPositive     ("sSRF02OffsetPositive")
		, m_sSRF02zSetOffsetPositive ("sSRF02zSetOffsetPositive")
		, m_sSRF02zNegOffsetPositive ("sSRF02zNegOffsetPositive")
		, m_sSRFActiveMarker         ("m_sSRFActiveMarker")
		, m_sSRFzSetActiveMarker     ("m_sSRF02zSetActiveMArker")
		, m_sSRFzNegActiveMarker     ("m_sSRF02zNegActiveMarker")
		, m_sSRFActiveMarkerRefocus  ("m_sSRFActiveMarkerRefocus")
		, m_sSRFzSetActiveMarkerRefocus("m_sSRFzSetActiveMarkerRefocus")
		, m_sSRFzNegActiveMarkerRefocus("m_sSRFzNegActiveMarkerRefocus")
		, m_sADCX				("sADCX")
		, m_sADCX_zSet			("sADCX_zSet")
		, m_sADCX_zNeg			("sADCX_zNeg")
		, m_sADCY				("sADCY")
		, m_sADCY_zSet			("sADCY_zSet")
		, m_sADCY_zNeg			("sADCY_zNeg")
		, m_sADCZ				("sADCZ")
		, m_sADCZ_zSet			("sADCZ_zSet")
		, m_sADCZ_zNeg			("sADCZ_zNeg")
		, m_sADCCom             ("sADCCom")
		, m_sADCCom_zSet        ("sADCCom_zSet")
		, m_sADCCom_zNeg        ("sADCCom_zNeg")
		, m_sADCCom2            ("sADCCom2")
		, m_sADCCom2_zSet       ("sADCCom2_zSet")
		, m_sADCCom2_zNeg       ("sADCCom2_zNeg")
		, m_sADCXCapsule        ("sADCXCapusle")
		, m_sADCX_zSetCapsule   ("sADCX_zSetCapusle")
		, m_sADCX_zNegCapsule   ("sADCX_zNegCapusle")
		, m_sADCYCapsule        ("sADCYCapusle")
		, m_sADCY_zSetCapsule   ("sADCY_zSetCapusle")
		, m_sADCY_zNegCapsule   ("sADCY_zNegCapusle")
		, m_sADCZCapsule        ("sADCZCapusle")
		, m_sADCZ_zSetCapsule   ("sADCZ_zSetCapusle")
		, m_sADCZ_zNegCapsule   ("sADCZ_zNegCapusle")
		, m_sGradRO				("sGradRO")
		, m_sGReadDeph			("sGReadDeph")
		, m_feedbackReceived    (false)
        , m_nbStep              (MAX_NB_STEP)   //MAX_NB_STEP     
		, m_lLinesToMeasure     (0)
        , m_lLinesPerSec        (0)
        , m_lCenterLine         (0)
        , m_dRFSpoilIncrement   (0)
        , m_dRFSpoilPhase       (0)
        , m_dMinRiseTime        (100000)
		, m_loop_test           (0)
		, m_loopTestClosedLoop  (0)
        , m_dGradMaxAmpl        (0)
		, tOff1                 (0)
		, tOff2                 (0)
		, tOffActiveMarker      (0)
        , m_pUI                 (new MiniFlashUI()) 
		, m_WIPParamTool        (*this)
{

   m_isRotorCenterAndRaduisFound = false;
   m_isDataSentToIce = false;
   m_isPause = false;

   m_tCycle = 0.0;
   m_tTracking = 0.0;
   m_nbGradBeforeTrack = -1;
   m_nbGradAfterTrack = -1;
   m_nbGradAtWakeUp = -1;
	m_timeAfterTrack = 0;
	m_interleavedOrSimult = 0; //Default interleaved
	m_imagingPlane = 0;

}


MiniFlash::~MiniFlash() {
    if(NULL != m_pUI) {
        // delete the user interface (UI) instance (if a UI instance has been created)
        delete m_pUI;
        m_pUI = NULL;
    }
}



NLSStatus MiniFlash::initialize(SeqLim &rSeqLim) {
    // This string is intended to store, where we are in the code (used for debugging by the MRTRACE macro).
    static const char *ptModule = {"MiniFLASH::initialize"};

    // Default return value
    NLS_STATUS lStatus = SEQU__NORMAL;

	rSeqLim.setMyOrigFilename ( __FILE__ );
	rSeqLim.setSequenceOwner ("USER");
    // -----------------------
    // Setting the hard limits
    // -----------------------

	rSeqLim.disableSAFEConsistencyCheck();
    // RF frequency is given as a long integer number in Hertz
    // The maximum allowed RF frequency is sufficient for 1H (hydrogen nuclei) in a 3-Tesla-system
    //                         (    min,       max)
    rSeqLim.setAllowedFrequency(8000000, 130850000);


    // The repetition time (TR) and echo time (TE) are given as long integer numbers in micro seconds.
    //                              (index,  min,        max,    increment,  default)
    rSeqLim.setTR                   (    0,  100,    5000000,           10,    20000);
    rSeqLim.setTE                   (    0,  100,     100000,           10,    10000);
    rSeqLim.setBandWidthPerPixel    (    0,   80,        900,           10,      260);


    // The flip angle is given as a double number in degrees.
    //                              (        min,        max,    increment,  default)
    rSeqLim.setFlipAngle            (       10.0,       90.0,          1.0,   90.000);
    //rSeqLim.setExtSrfFilename                                     ("%MEASDAT%/extrf.dat")  ;


    // The base resolution tells how many samples in readout direction are acquired in k-space. The increment-value
    // is not set directly. Instead, a key is used which is connected to values of 16, 32, 64, etc. The allowed
    // values can be looked up in "kSpaceDefines.h".
    //                              (        min,        max,    increment,  default)
    rSeqLim.setBaseResolution       (         64,        512,  SEQ::INC_64,      448); //INC_BASE2 also available
 
	

    // The field-of-view (FOV) is given as double numbers in mm.
    //                              (        min,        max,    increment,  default)
    rSeqLim.setReadoutFOV           (        100,        500,            1,      300);
    rSeqLim.setPhaseFOV             (        100,        500,            1,      300);


    // Here, we set the number of lines in phase encoding(PE)-direction.
    //                              (        min,        max,    increment,  default)
    rSeqLim.setPELines              (         32,       1024,            1,      128);


    // The MiniFLASH sequence is intended for single-slice measurements only.
    //                              (        min,        max,    increment,  default)
    rSeqLim.setSlices               (          1,          1,            1,        1);


    // The slice thickness is given as a double number in mm.
    //                              (        min,        max,    increment,  default)
    rSeqLim.setSliceThickness       (      2.000,     10.000,        0.500,    5.000);


    // --------------------------------------
    // Instantiation of the MiniFlashUI-class
    // --------------------------------------

    

    // MRRESULT_SEV is a mask for the "severity" bits. This if-statement checks whether the severity bits
    // are set (which indicates that something went wrong).
   //if((MRRESULT_SEV & (lStatus = createUI(rSeqLim))) == MRRESULT_SEV) {

        // The MRTRACE macro is used to log information for debugging purposes
       // MRTRACE("Instantiation of MiniFlashUI class failed!");
       // return lStatus;
    //}


    // This compiler directive restricts this code to the HOST version dll.
    // In this way the same source code can be compiled for both the Host and the MARS.
/*
    if(NULL == m_pUI) {
        MRTRACE("MiniFlashUI object pointer is null (creation failed probably)!");
        return ( SEQU_ERROR );
    }
*/

    // ----------------------------------------------
    // Declaration of pointer to UI parameter classes
    // ----------------------------------------------
    lStatus = m_pUI->registerUI(rSeqLim, m_WIPParamTool);
	//lStatus = m_pUI->registerUI(rSeqLim);
    if(MrSeverity(lStatus) != MRRESULT_SUCCESS) {
        MRTRACE("Registering MiniFlashUI object failed! Errorcode: %i", lStatus);
        return lStatus;
    }

    // -----------------------------------------------------------------
    // file containing the default postprocessing protocol (EVAProtocol)
    // -----------------------------------------------------------------
 #ifdef WIN32   
    // The _T(x) macro deals with the unicode conversion of strings.
    rSeqLim.setDefaultEVAProt (_T("%SiemensEvaDefProt%\\Inline\\Inline.evp"));
#endif
    return lStatus;
}



//. -------------------------------------------------------------------------
//.. fSEQPrep: prepare real time elements and calculate energy and timing
//. -------------------------------------------------------------------------
NLSStatus MiniFlash::prepare(MrProt &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo)
{
    static const char *ptModule = {"MiniFlash::prepare"};
    NLS_STATUS   lStatus = SEQU__NORMAL;                     // * Return status *
    long         lTEFil;
    double       dMeasureTimeUsec      = 0.0;
	long durationExt;
    // --------------------
    // get some information
    // --------------------

    OnErrorReturn(rMrProt.kSpace().linesToMeasure(m_lLinesToMeasure));

    m_dMinRiseTime = SysProperties::getGradMinRiseTime(rMrProt.gradSpec().mode());
    m_dGradMaxAmpl = SysProperties::getGradMaxAmpl(rMrProt.gradSpec().mode());
	m_dGradMaxAmpl = 21.0;

    dMeasureTimeUsec = (double)m_lLinesToMeasure * rMrProt.tr()[0];

	// make sure that m_lLinesPerSec is at least 1.
    m_lLinesPerSec =  std::max<long>(1,long(m_lLinesToMeasure * 1000000. /dMeasureTimeUsec));

    m_lCenterLine  = rMrProt.kSpace().echoLine();

	// TODO: Open a file to write inside the gradients values 
	// used for DEBUG mode to make sure that the gradients are updated correctly

	//. Prepare RF pulse for rotor imaging
    m_sSRF01.setTypeExcitation   ();
    //m_sSRF01.setDuration         (1000) ;
	m_sSRF01.setDuration         (500) ;
    m_sSRF01.setFlipAngle        (rMrProt.flipAngle());
    m_sSRF01.setInitialPhase     (90);
    m_sSRF01.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF01.setSamples          (100);
	m_sSRF01.setBandwidthTimeProduct(2.70);
    if(! m_sSRF01.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF01.getNLSStatus());

    //. Prepare refocusing RF pulse for rotor imaging
    m_sSRF02.setTypeRefocussing  ();
    //m_sSRF02.setDuration         (1280) ;
	m_sSRF02.setDuration         (640) ;
    m_sSRF02.setFlipAngle        (180);
    m_sSRF02.setInitialPhase     (0);
    m_sSRF02.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF02.setSamples          (128);
    m_sSRF02.setBandwidthTimeProduct(2.70);
    if(! m_sSRF02.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF02.getNLSStatus());
	

	//. Prepare RF pulses for capsule imaging
	// Negative offset used for the z-axis
    m_sSRF01OffsetNegative.setTypeExcitation   ();
    m_sSRF01OffsetNegative.setDuration         (1000) ;
    m_sSRF01OffsetNegative.setFlipAngle        (rMrProt.flipAngle());
    m_sSRF01OffsetNegative.setInitialPhase     (90);
    m_sSRF01OffsetNegative.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF01OffsetNegative.setSamples          (100);
	m_sSRF01OffsetNegative.setBandwidthTimeProduct(2.70);
    if(! m_sSRF01OffsetNegative.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF01OffsetNegative.getNLSStatus());
	// Negative refocusing pulse
    m_sSRF02OffsetNegative.setTypeRefocussing  ();
    m_sSRF02OffsetNegative.setDuration         (1280) ;
    m_sSRF02OffsetNegative.setFlipAngle        (180);
    m_sSRF02OffsetNegative.setInitialPhase     (0);
    m_sSRF02OffsetNegative.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF02OffsetNegative.setSamples          (128);
    m_sSRF02OffsetNegative.setBandwidthTimeProduct(2.70);
    if(! m_sSRF02OffsetNegative.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF02OffsetNegative.getNLSStatus());
	// Positive offset used for the x and y-axis
	m_sSRF01OffsetPositive.setTypeExcitation   ();
    m_sSRF01OffsetPositive.setDuration         (1000) ;
    m_sSRF01OffsetPositive.setFlipAngle        (rMrProt.flipAngle());
    m_sSRF01OffsetPositive.setInitialPhase     (90);
    m_sSRF01OffsetPositive.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF01OffsetPositive.setSamples          (100);
	m_sSRF01OffsetPositive.setBandwidthTimeProduct(2.70);
    if(! m_sSRF01OffsetPositive.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF01OffsetPositive.getNLSStatus());
	// Negative refocusing pulse
    m_sSRF02OffsetPositive.setTypeRefocussing  ();
    m_sSRF02OffsetPositive.setDuration         (1280) ;
    m_sSRF02OffsetPositive.setFlipAngle        (180);
    m_sSRF02OffsetPositive.setInitialPhase     (0);
    m_sSRF02OffsetPositive.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF02OffsetPositive.setSamples          (128);
    m_sSRF02OffsetPositive.setBandwidthTimeProduct(2.70);
    if(! m_sSRF02OffsetPositive.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF02OffsetPositive.getNLSStatus());
    
	//Prepare RF for passive tracking
	m_sSRFActiveMarker.setTypeExcitation   ();
    m_sSRFActiveMarker.setDuration         (60) ;
    m_sSRFActiveMarker.setFlipAngle        ((long) m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleK2));
    m_sSRFActiveMarker.setInitialPhase     (90);
    m_sSRFActiveMarker.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRFActiveMarker.setSamples          (10);
	m_sSRFActiveMarker.setBandwidthTimeProduct(2.70);
    if(! m_sSRFActiveMarker.prepSinc(rMrProt,rSeqExpo)) return (m_sSRFActiveMarker.getNLSStatus());
    //. Prepare refocusing RF pulse for rotor imaging
    m_sSRFActiveMarkerRefocus.setTypeRefocussing  ();
    m_sSRFActiveMarkerRefocus.setDuration         (1280) ;
    m_sSRFActiveMarkerRefocus.setFlipAngle        (180);
    m_sSRFActiveMarkerRefocus.setInitialPhase     (0);
    m_sSRFActiveMarkerRefocus.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRFActiveMarkerRefocus.setSamples          (128);
    m_sSRFActiveMarkerRefocus.setBandwidthTimeProduct(2.70);
    if(! m_sSRFActiveMarkerRefocus.prepSinc(rMrProt,rSeqExpo)) return (m_sSRFActiveMarkerRefocus.getNLSStatus());


	//. Prepare ADCs for rotor imaging
    m_sADCX.setColumns (rMrProt.kSpace().getlBaseResolution());
    m_sADCX.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
    m_sADCX.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));
	m_sADCX.getMDH().setIceProgramPara(ADC_TYPE,SIGNAL_DATA); // Signal Data
	m_sADCX.getMDH().setIceProgramPara(NO_CHANNEL,(uint16_t) m_WIPParamTool.getLongValue (rMrProt, WIPLongChannelID)); // Communication Data

	m_sADCY.setColumns (rMrProt.kSpace().getlBaseResolution());
    m_sADCY.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
    m_sADCY.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));
	m_sADCY.getMDH().setIceProgramPara(ADC_TYPE,SIGNAL_DATA); // Signal Data
	m_sADCY.getMDH().setIceProgramPara(NO_CHANNEL,(uint16_t) m_WIPParamTool.getLongValue (rMrProt, WIPLongChannelID)); // Communication Data
  
	m_sADCZ.setColumns (rMrProt.kSpace().getlBaseResolution());
    m_sADCZ.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
    m_sADCZ.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));
	m_sADCZ.getMDH().setIceProgramPara(ADC_TYPE,SIGNAL_DATA); // Signal Data
	m_sADCZ.getMDH().setIceProgramPara(NO_CHANNEL,(uint16_t) m_WIPParamTool.getLongValue (rMrProt, WIPLongChannelID)); // Communication Data

	//. Prepare ADCs for capsule imaging
	m_sADCXCapsule.setColumns (rMrProt.kSpace().getlBaseResolution());
	m_sADCXCapsule.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
	m_sADCXCapsule.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));
	m_sADCXCapsule.getMDH().setIceProgramPara(ADC_TYPE,SIGNAL_DATA); // Signal Data
	m_sADCXCapsule.getMDH().setIceProgramPara(NO_CHANNEL,(uint16_t) m_WIPParamTool.getLongValue (rMrProt, WIPLongChannelID)); // Communication Data

	m_sADCYCapsule.setColumns (rMrProt.kSpace().getlBaseResolution());
	m_sADCYCapsule.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
	m_sADCYCapsule.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));
	m_sADCYCapsule.getMDH().setIceProgramPara(ADC_TYPE,SIGNAL_DATA); // Signal Data
	m_sADCYCapsule.getMDH().setIceProgramPara(NO_CHANNEL,(uint16_t) m_WIPParamTool.getLongValue (rMrProt, WIPLongChannelID)); // Communication Data

	m_sADCZCapsule.setColumns (rMrProt.kSpace().getlBaseResolution());
	m_sADCZCapsule.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
	m_sADCZCapsule.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));
	m_sADCZCapsule.getMDH().setIceProgramPara(ADC_TYPE,SIGNAL_DATA); // Signal Data
	m_sADCZCapsule.getMDH().setIceProgramPara(NO_CHANNEL,(uint16_t) m_WIPParamTool.getLongValue (rMrProt, WIPLongChannelID)); // Communication Data

	// Set some timming variables
	gThetaFinal1 = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleThetaF1);
	gK1 = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleK1);
	gK2 = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleK2);
	gtMeas = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT);
	gtRTFeedBack = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleRTDelay);
	gtRTFeedBack2= m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleWakeUpDelay);
	m_tCycle = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT)*1000000;

	m_imagingPlane = m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane);

	//. Prepare readout gradient
    if(!m_sGradRO.prepRO(300,(fSDSRoundUpGRT(m_sADCX.getDuration()+300)),
        300,rMrProt,m_sADCX.getDwellTime()))return(m_sGradRO.getNLSStatus());

    //. Prepare and check readout dephasing gradient
    m_sGReadDeph.setMaxMagnitude(m_dGradMaxAmpl);
    m_sGReadDeph.setMinRiseTime(m_dMinRiseTime);
	//m_sGReadDeph.setRampTimes(300);
	//m_sGReadDeph.setMinRiseTime(m_dMinRiseTime);

	//. Prepare and check readout Rephasing gradient for GRE
	m_sGReadRephGRE.setMaxMagnitude(m_dGradMaxAmpl);
	m_sGReadRephGRE.setMinRiseTime(m_dMinRiseTime);
	if (! m_sGReadRephGRE.prepSymmetricTOTShortestTime(m_sGradROGRE.getMomentum(
		0,(long)(m_sGradROGRE.getRampUpTime() + m_sADCX.getDuration()/2))))
		return (m_sGReadRephGRE.getNLSStatus());
	
	/*
	if (! m_sGReadDeph.prepSymmetricTOTShortestTime(-m_sGradRO.getMomentum(
        0,(long)(m_sGradRO.getRampUpTime() + m_sADCX.getDuration()/2))))
        return (m_sGReadDeph.getNLSStatus());
	*/
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == SPIN_ECHO){

		if (! m_sGReadDeph.prepSymmetricTOTShortestTime(m_sGradRO.getMomentum(
			0,(long)(m_sGradRO.getRampUpTime() + m_sADCX.getDuration()/2))))
			return (m_sGReadDeph.getNLSStatus());
	}
	else
	{
		if (! m_sGReadDeph.prepSymmetricTOTShortestTime(-m_sGradRO.getMomentum(
			0,(long)(m_sGradRO.getRampUpTime() + m_sADCX.getDuration()/2))))
			return (m_sGReadDeph.getNLSStatus());
	}

	// Calculation of the total tracking duration
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == ALTERNATE_CL)
	{
		m_tTracking = m_sSRF01.getDuration()+m_sGReadDeph.getTotalTime()+abs(tOff1)+500 +m_sSRF02.getDuration()+500 +m_sGradRO.getRampUpTime()+m_sGradRO.getTotalTime();
	}
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == SPIN_ECHO)
	{
		m_tTracking = m_sSRF01.getDuration()+m_sGReadDeph.getTotalTime()+abs(tOff1)+500;
		m_tTracking += m_sSRF02.getDuration() +500 + m_sGradRO.getRampUpTime();
		m_tTracking += m_sGradRO.getDuration()- m_sGradRO.getRampDownTime() +m_sGradRO.getRampDownTime()+500;
		m_tTracking += m_sSRF02.getDuration() + 500 + m_sGradRO.getRampUpTime() + m_sGradRO.getTotalTime();
	}
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == GRADIENT_ECHO)
	{
		m_tTracking = m_sSRF01.getDuration()+m_sGReadDeph.getDuration()+m_sGReadDeph.getRampDownTime();
		m_tTracking += m_sGradRO.getRampUpTime() +  m_sGradRO.getDuration();
		m_tTracking += m_sGReadDeph.getDuration()+ m_sGReadDeph.getRampDownTime() + m_sGradRO.getRampUpTime() + m_sGradRO.getTotalTime();
	}
#ifdef WIN32
	cout << "************************************************************************" << endl;
	cout << "m_tTracking " <<  m_tTracking << endl;
	cout << "m_tCycle "    <<  m_tCycle << endl;
	cout << "************************************************************************" << endl;
#endif

	durationExt = (((long) ((m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT)*1000000)-m_tTracking) /MAX_NB_EXTERN_STEP)/GRAD_RASTER_TIME) * GRAD_RASTER_TIME ; //micro seconds, pulse length
	if(durationExt == 0)
		durationExt = 100000;
	
	m_nbGradBeforeTrack = (m_tCycle - m_tTracking - gtRTFeedBack)/durationExt;
	//m_nbGradAtWakeUp = (m_tCycle - m_tTracking - gtRTFeedBack2)/durationExt;
	m_nbGradAtWakeUp = m_tCycle - gtRTFeedBack2;
	m_nbGradAfterTrack = (MAX_NB_EXTERN_STEP - m_nbGradBeforeTrack);
	m_timeAfterTrack = m_nbGradAfterTrack*durationExt;
	if(m_nbGradBeforeTrack < 0 || m_nbGradAfterTrack < 0)
	{
#ifdef WIN32
		cout << "ERREUR DANS LE TIMMING" << endl;
#endif
		return (SEQU_ERROR);
	}
	//prepareExternalPulse(rMrProt, durationExt);
	//prepareInitPulse(rMrProt);

#ifdef WIN32
	cout << "m_nbGradBeforeTrack "    <<  m_nbGradBeforeTrack << endl;
	cout << "m_nbGradAtWakeUp "       <<  m_nbGradAtWakeUp    << endl;
	cout << "m_nbGradAfterTrack "     <<  m_nbGradAfterTrack  << endl;
#endif

    // Prepare ADC used to communicate data between Sequence and ICE
    m_sADCCom.setColumns (rMrProt.kSpace().getlBaseResolution());
	m_sADCCom.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
	m_sADCCom.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));
	   
	m_sADCCom2.setColumns (rMrProt.kSpace().getlBaseResolution());
	m_sADCCom2.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
	m_sADCCom2.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));

	prepareComADC(rMrProt);


	//prepareSinusoidalPulse(rMrProt);
	//. Prepare Gradient
	m_sGActuateX.setMaxMagnitude(42.9);
	if((m_WIPParamTool.getDoubleValue (rMrProt, WIPDoublePeriod)<0.000001)) //if 0
	{
		m_sGActuateX.setAmplitude(0.0);
	}
	else
	{
		m_sGActuateX.setAmplitude(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitude));
	}


	m_sGActuateX.setDuration((long)((m_WIPParamTool.getDoubleValue (rMrProt, WIPDoublePeriod))*1000000/GRAD_RASTER_TIME) * GRAD_RASTER_TIME);
	//m_sGActuateX.setDuration(10000);
	m_sGActuateX.setRampUpTime(300);
	m_sGActuateX.setRampDownTime(300);
 
	if( !( m_sGActuateX.prep() ) ||
        !( m_sGActuateX.check() ) )
      return m_sGActuateX.getNLSStatus();

	m_sGActuateY.setMaxMagnitude(42.9);
		
	if((m_WIPParamTool.getDoubleValue (rMrProt, WIPDoublePeriod)<0.000001)) //if 0
	{
		m_sGActuateY.setAmplitude(0.0);
	}
	else
	{
		m_sGActuateY.setAmplitude(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitude));
	}
	m_sGActuateY.setDuration((long)((m_WIPParamTool.getDoubleValue (rMrProt, WIPDoublePeriod))*1000000/GRAD_RASTER_TIME) * GRAD_RASTER_TIME);
	//m_sGActuateY.setDuration(10000);	
	m_sGActuateY.setRampUpTime(300);
	m_sGActuateY.setRampDownTime(300);

	if( !( m_sGActuateY.prep() ) ||
        !( m_sGActuateY.check() ) )
      return m_sGActuateY.getNLSStatus();

	m_sGActuateZ.setMaxMagnitude(42.9);
	if((m_WIPParamTool.getDoubleValue (rMrProt, WIPDoublePeriod)<0.000001)) //if 0
	{
		m_sGActuateZ.setAmplitude(0.0);
	}
	else
	{
		m_sGActuateZ.setAmplitude(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitude));
	}
		

	m_sGActuateZ.setDuration((long)((m_WIPParamTool.getDoubleValue (rMrProt, WIPDoublePeriod))*1000000/GRAD_RASTER_TIME) * GRAD_RASTER_TIME);
	//m_sGActuateZ.setDuration(10000);
	m_sGActuateZ.setRampUpTime(300);
	m_sGActuateZ.setRampDownTime(300);

	if( !( m_sGActuateZ.prep() ) ||
        !( m_sGActuateZ.check() ) )
      return m_sGActuateZ.getNLSStatus();

	// calcul time for balancing the timing table for spin echo tracking kernel
	tOffActiveMarker = (m_sSRFActiveMarker.getDuration()/2 + m_sGReadDeph.getTotalTime() + m_sSRFActiveMarkerRefocus.getDuration()/2)
						-(m_sSRFActiveMarkerRefocus.getDuration()/2 + m_sGradRO.getTotalTime()/2 );


	tOff1 = (m_sSRF01.getDuration()/2 + m_sGReadDeph.getTotalTime() + m_sSRF02.getDuration()/2)
		   -(m_sSRF02.getDuration()/2 + m_sGradRO.getTotalTime()/2 );

	tOff2 = (m_sSRF02.getDuration()/2 + m_sGradRO.getDuration() + m_sGReadDeph.getTotalTime() + m_sSRF02.getDuration()/2)
		   -(m_sSRF02.getDuration()/2 + m_sGradRO.getTotalTime()/2 );

#ifdef WIN32
	cout << "************************************************************************" << endl;
	cout << "Momentum = " 
		 << m_sGradRO.getMomentumTOT() + m_sGReadDeph.getMomentumTOT() << endl;
			
	cout << tOff1 << endl;
	cout << "************************************************************************" << endl;
	g_fileID.open("RTGradientsTest.txt", ios::out);
	if(g_fileID.fail())
		cout << "File open error" << endl;

#endif


    // ------------------------------------------------
    // Preparation of all required real time components
    // ------------------------------------------------
    rSeqExpo.setRelevantReadoutsForMeasTime(m_lLinesToMeasure / m_lLinesPerSec);
    // Set receiver gain
    OnErrorReturn(fSSLSetRxGain(K_RX_GAIN_CODE_HIGH,rMrProt,rSeqLim));
    // Prepare the slice position array
    OnErrorReturn(fSUPrepSlicePosArray (rMrProt, rSeqLim, m_asSLC));
    // Set sequence string for display in images
    //fSUSetSequenceString              ("fl", rMrProt, rSeqExpo);
	fSUSetSequenceString              ("se", rMrProt, rSeqExpo);
    //. Fill export section
	// oufel RF ENERGY CALCULATION
    rSeqExpo.setRFEnergyInSequence_Ws(m_WIPParamTool.getLongValue (rMrProt, WIPLongRepetition)
        * (m_sSRF01.getPulseEnergyWs() + m_sSRF02.getPulseEnergyWs()));
    rSeqExpo.setMeasuredPELines      (m_lLinesToMeasure);
    rSeqExpo.setMeasureTimeUsec      (dMeasureTimeUsec);
    rSeqExpo.setTotalMeasureTimeUsec (dMeasureTimeUsec);
    rSeqExpo.setPCAlgorithm          (SEQ::PC_ALGORITHM_NONE);
    rSeqExpo.setOnlineFFT            (SEQ::ONLINE_FFT_PHASE);
    //rSeqExpo.setICEProgramFilename   ("%SiemensIceProgs%\\IceProgramOnline2D");    // Only 2D reconstruction allowed
    rSeqExpo.setICEProgramFilename   ("%CustomerIceProgs%\\IceProgActuationCloseLoopV2");    // We Only Use MRI for gradient
    rSeqExpo.setICEProgramParam(ICE_PROGRAM_PARA_SHOW_OFFLINE, SEQ::SO_SHOW_NO);

    return (lStatus);
}

//. -------------------------------------------------------------------------
//.. fSEQCheck: check lines at the border of k-space (gradient overflow, GSWD)
//. -------------------------------------------------------------------------
NLSStatus MiniFlash::check(MrProt &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo, SEQCheckMode * /*pSEQCheckMode*/)
{
    
    static const char *ptModule = {"MiniFlash::check"};
    NLS_STATUS   lStatus = SEQU__NORMAL;
    long        lL                = 0;
    long        alLCk[4]          = {0, 1, rSeqExpo.getMeasuredPELines() - 2, rSeqExpo.getMeasuredPELines() - 1};
    while (lL < 4 )
    {
        OnErrorReturn(runKernel(rMrProt,rSeqLim,rSeqExpo,KERNEL_CHECK,0, 0, alLCk[lL]));
        lL++;
    }
    return(lStatus);
}

//. -------------------------------------------------------------------------
//.. fSEQRun: run the sequence
//. -------------------------------------------------------------------------
NLSStatus MiniFlash::run(MrProt  &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo)
{
    static const char *ptModule = {"MiniFlash::run"};
    NLS_STATUS lStatus          = SEQU__NORMAL;
	
    //. Initialize sequence test
    if(IS_UNIT_TEST_ACTIVE(rSeqLim))
    {
        mSEQTest(rMrProt,rSeqLim,rSeqExpo,RTEB_ORIGIN_fSEQRunStart,0,0,0,0,0);
    }
    
    //. Send the delay between measurements
    //OnErrorReturn(fSBBMeasRepetDelaysRun ( rMrProt, rSeqLim, rSeqExpo, 0 ));

    if(IS_UNIT_TEST_ACTIVE(rSeqLim))
    {
        mSEQTest (rMrProt, rSeqLim, rSeqExpo, RTEB_ClockInitTR, 0, 0, m_asSLC[0].getSliceIndex(), 0, 0);
    }

	m_sADCX.getMDH().setFreeParameterByIndex(1,0); // no of the acquisition
	m_sADCY.getMDH().setFreeParameterByIndex(1,0); // Will be incremented in the receive method
	m_sADCXCapsule.getMDH().setFreeParameterByIndex(1,0);
	m_sADCYCapsule.getMDH().setFreeParameterByIndex(1,0);
	m_sADCZCapsule.getMDH().setFreeParameterByIndex(1,0);

    // Call Kernel function
    OnErrorReturn(runKernel(rMrProt, rSeqLim, rSeqExpo,KERNEL_IMAGE,0, 0, 0));
	OnErrorReturn(runKernel(rMrProt, rSeqLim, rSeqExpo,KERNEL_IMAGE,0, 0, 1));

	// DEBIG mode only : Write the real-time gradients amplitude into a file
#ifdef WIN32

		
	if(g_fileID.is_open() == true)
		cout << "File open" << endl;
	else
		cout << "File not Open" << endl;

	for(int i = 0; i < g_gradIndex; i++)
	{
		if (i != 0 && i%10 == 0)
			g_fileID << endl;

		g_fileID << g_gradValuesHistory[i] << " ";
	}
#endif	

    if(IS_UNIT_TEST_ACTIVE(rSeqLim))
    {
        mSEQTest(rMrProt,rSeqLim,rSeqExpo,RTEB_ORIGIN_fSEQRunFinish,0,0,0,0,0);
    }
    return(SEQU__NORMAL);
}


//. -------------------------------------------------------------------------
//.. runKernel
//. -------------------------------------------------------------------------
NLS_STATUS MiniFlash::runKernel(MrProt &rMrProt, SeqLim &rSeqLim,
								MrProtocolData::SeqExpo &rSeqExpo, long lKernelMode, long /* lSlice */, long /* lPartition */, long lLine)
{
	static const char *ptModule = {"MiniFlash::runKernel"};
	NLS_STATUS         lStatus  = SEQU__NORMAL;

	long lT;

    //Send data to ICE. Apply only once at the beginning of the sequence
	if(m_isDataSentToIce == false && lKernelMode == KERNEL_IMAGE)
	{
		sendComDataToIce(m_sADCCom, m_sADCCom_zSet, m_sADCCom_zNeg,1);
		sendComDataToIce(m_sADCCom2, m_sADCCom2_zSet, m_sADCCom2_zNeg, 3);

		m_isDataSentToIce = true;
	}
		//m_sADCX.getMDH().setFreeParameterByIndex(3,0); // Switch between max speed and position control disabled
		//m_sADCY.getMDH().setFreeParameterByIndex(3,0); // Disable = 0, Enable = 1
	

	if (lLine == 0)
		applyRotMatrix((double)(0.0));
	else // lLine = 1
		applyRotMatrix((double)(M_PI/2.0));
		


	m_isRotorCenterAndRaduisFound = true;

	fRTEBInit( m_asSLC[0].getROT_MATRIX());
	printRotationMatrix(m_asSLC[0].getROT_MATRIX());

	lT = 0;
    /////////////////////////////////////////////////////////////////////////////
    // Apply actuation sequence  
	/////////////////////////////////////////////////////////////////////////////
	//if (m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == SINUSOIDALE || (m_isRotorCenterAndRaduisFound == false && m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) >= EXTERNGRD_TRACKACTUATE ))
		//
	
	OnErrorReturn((NLS_STATUS)applySETrackingActuationForCapsules(rMrProt, lT, lLine));
	
	OnErrorReturn((NLS_STATUS)pause1Sec(rMrProt, lT, lLine));
	OnErrorReturn((NLS_STATUS)pause1Sec(rMrProt, lT, lLine));

	OnErrorReturn((NLS_STATUS)fRTEBFinish());

	// Apply the first actuation bloc, the tracking bloc and the second actuation bloc and wait for
	// feedback. Once feedback received resume loading blocs into MARS.
	fRTWaitForWakeup();
	//m_sFeedbackSemaphore.acquire();

	//m_sFeedbackSemaphore.release();

	//Send a notification to ICE if whether or not the feedback was received
	if(m_feedbackReceived == true)
	{
		m_feedbackReceived = false;
		m_sADCX.getMDH().setFreeParameterByIndex(2,1); // Feedback received
		m_sADCY.getMDH().setFreeParameterByIndex(2,1); // Feedback received
		m_sADCXCapsule.getMDH().setFreeParameterByIndex(2,1);
		m_sADCYCapsule.getMDH().setFreeParameterByIndex(2,1);
		m_sADCZCapsule.getMDH().setFreeParameterByIndex(2,1);

	}
	else
	{
		m_sADCX.getMDH().setFreeParameterByIndex(2,0); // No Feedback received
		m_sADCY.getMDH().setFreeParameterByIndex(2,0); // No Feedback received
		m_sADCXCapsule.getMDH().setFreeParameterByIndex(2,0);
		m_sADCYCapsule.getMDH().setFreeParameterByIndex(2,0);
		m_sADCZCapsule.getMDH().setFreeParameterByIndex(2,0);

	}
	//. Call sequence unit test
	if(IS_UNIT_TEST_ACTIVE(rSeqLim))
	{
		if (lKernelMode == KERNEL_CHECK)
			mSEQTest(rMrProt, rSeqLim, rSeqExpo, RTEB_ORIGIN_fSEQCheck,  10, lLine, m_asSLC[0].getSliceIndex(), 0, 0);
		else
			mSEQTest(rMrProt, rSeqLim, rSeqExpo, RTEB_ORIGIN_fSEQRunKernel,10,lLine,m_asSLC[0].getSliceIndex(), 0, 0);
		mSEQTest    (rMrProt, rSeqLim, rSeqExpo, RTEB_ClockCheck,        10, lLine, m_asSLC[0].getSliceIndex(), 0, 0);
	}


	return(lStatus);
}


NLSStatus MiniFlash::receive(SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo, SEQData& rSEQData)
{
	static const char *ptModule = {"MiniFlash::receive"};
	NLSStatus         lStatus  = SEQU__NORMAL;

	//double durationTab[5] = {0.15, 0.75, 1, 0.5, 0.25};
	//double durationSin;

	// Check if the feedback is the expected one
	if(strcmp(rSEQData.getID(),"MRIR"))
	{
		UTRACE (Debug, iUTraceMarker, "**************************************************************** " );
		UTRACE (Debug, iUTraceMarker, "Feedback data in " << ptModule << " has wrong ID " << rSEQData.getID());
		UTRACE (Debug, iUTraceMarker, "**************************************************************** " );
		return lStatus;
	}
	m_feedbackReceived = true;
	//--------------------------------------------------------------------------------------------
	// Reserve Semaphore HERE
	//--------------------------------------------------------------------------------------------
	m_sFeedbackSemaphore.acquire();
	
	// Used for Debug. Increase a counter so we know that receive is called
	m_sADCX.getMDH().setFreeParameterByIndex(1,++m_loop_test); 
	m_sADCY.getMDH().setFreeParameterByIndex(1,m_loop_test); // 
	m_sADCXCapsule.getMDH().setFreeParameterByIndex(1,m_loop_test);
	m_sADCYCapsule.getMDH().setFreeParameterByIndex(1,m_loop_test);
	m_sADCZCapsule.getMDH().setFreeParameterByIndex(1,m_loop_test);

	// Get the feedback data
	FBData fbData;
	fbData = *(FBData*) rSEQData.getData();

	// The ICE program will send a 1 in fbData.lShot if the Circle is found
	//if (fbData.lShot == 1 && m_isPause == true)
	if (fbData.lShot == 1)
	{
		m_isRotorCenterAndRaduisFound = true;
		++m_loopTestClosedLoop;
	}
	g_theta = fbData.prjAngle;

	if(fbData.SimultORInterleaved == 1)
		m_interleavedOrSimult = 1;
	else
		m_interleavedOrSimult = 0;

	m_sGActuateX.setAmplitude(fbData.uValx[0]);
	m_sGActuateY.setAmplitude(fbData.uValy[0]);
	m_sGActuateZ.setAmplitude(fbData.uValz[0]);

	if( !( m_sGActuateX.prep() ) || !( m_sGActuateX.check() ) )
		return m_sGActuateX.getNLSStatus();

	if( !( m_sGActuateY.prep() ) || !( m_sGActuateY.check() ) )
		return m_sGActuateY.getNLSStatus();

	if( !( m_sGActuateZ.prep() ) || !( m_sGActuateZ.check() ) )
		return m_sGActuateZ.getNLSStatus();

	//m_prjAngle = fbData.prjAngle * M_PI/180.0; // Convert to radian

	m_sFeedbackSemaphore.release();

	return lStatus;

}



NLS_STATUS MiniFlash::createUI (SeqLim&)
{
	static const char *ptModule = {"MiniFlash::createUI"};
    #ifdef WIN32

        

        //  ----------------------------------------------------------------------
        //  Delete existing instance if necessary
        //  ----------------------------------------------------------------------
        if(m_pUI)  {
            delete m_pUI;
            m_pUI = NULL;
        }



        //  ----------------------------------------------------------------------
        //  Instantiation of the UI class
        //  ----------------------------------------------------------------------
        try  {
            m_pUI = new MiniFlashUI();
        }

        catch (...)  {
            delete m_pUI;
            m_pUI = NULL;

            TRACE_PUT1(TC_ALWAYS, TF_SEQ,"%s: Cannot instantiate UI class !", ptModule);
            return ( SEQU_ERROR );
        }

    #endif

    return ( SEQU_NORMAL );

}   // end: MiniFlash::createUI



const MiniFlashUI* MiniFlash::getUI (void) const
{
	return ( m_pUI );
}


// --------------------------------------------------------------------------------------------
///  \brief    This method apply a rotation matrix 
///
///
///  \param    axis : A value set by the user interface card      
///
///  \return   NONE
// --------------------------------------------------------------------------------------------
void MiniFlash::applyRotMatrix(double theta)
{

	sROT_MATRIX mat;

	mat.dMat[0][0] = 0; 
	mat.dMat[0][1] = cos(theta);
	mat.dMat[0][2] = 0;

	mat.dMat[1][0] = 1;
	mat.dMat[1][1] = 0;
	mat.dMat[1][2] = 0;

	mat.dMat[2][0] = 0;
	mat.dMat[2][1] = sin(theta);
	mat.dMat[2][2] = 0;

	m_asSLC[0].setROT_MATRIX(mat);


}
// --------------------------------------------------------------------------------------------
///  \brief    This method send specific actuation data to the ICE 
///            Data to send to ICE : 
///                    
///            
///				- First ADC : 
///
///  \param    NONE      
///
///  \return   \arg \c SEQU__NORMAL  : If the Real time event bloc is okay
///            \arg \c SEQU_ERROR    : Otherwise
// --------------------------------------------------------------------------------------------
NLS_STATUS MiniFlash::sendComDataToIce(sREADOUT &adc, sFREQ_PHASE &adcSet, sFREQ_PHASE &adcNeg, int index)
{

	NLS_STATUS         lStatus  = SEQU__NORMAL;

	long lT = 0;
	adc.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	adc.getMDH().setFreeParameterByIndex(0,index); // 
	adc.getMDH().setFreeParameterByIndex(1,0); // 

	//m_sADCCom.getMDH().setFreeParameterByIndex(1,0); 

	fRTEBInit( m_asSLC[0].getROT_MATRIX());
	//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
	//- *                             Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
	//- *                               (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
	//- *fRTEI(                                                    ,              ,          ,          ,                ,              ,                ,      );
	//- **********************************************************************************************************************************************************
	fRTEI ( lT                                                     , &adcSet,        0,   &adc,  0,   0, 0,    0 );
	fRTEI ( lT + adc.getDuration()                                 , &adcNeg,        0,      0,  0,   0, 0,    0 );
	fRTEI ( lT += 20000                                            ,       0,        0,      0,  0,   0, 0,    0 );
	
	OnErrorReturn((NLS_STATUS)fRTEBFinish());

	return lStatus;

}


// --------------------------------------------------------------------------------------------
///  \brief    This method apply a 1 second pause
///            getMDH().setFreeParameterByIndex(0,...); used for projection
///            getMDH().setFreeParameterByIndex(1,...); used for loop
///            getMDH().setFreeParameterByIndex(2,...); used for Errors
///
///  \param    rMrProt      
///
///  \return   \arg \c SEQU__NORMAL  : If the Real time event bloc is okay
///            \arg \c SEQU_ERROR    : Otherwise
// --------------------------------------------------------------------------------------------
NLS_STATUS MiniFlash::pause1Sec(MrProt &rMrProt, long& lT, long lLine)
{
	NLS_STATUS         lStatus  = SEQU__NORMAL;
	fRTEI ( lT += 1000000,             0,            0,         0,               0,             0,               0,    0 );
	return lStatus;
}

// --------------------------------------------------------------------------------------------
///  \brief    This method apply a Spin echo tracking and actuation sequence kernel 
///            getMDH().setFreeParameterByIndex(0,...); used for projection
///            getMDH().setFreeParameterByIndex(1,...); used for loop
///            getMDH().setFreeParameterByIndex(2,...); used for Errors
///
///  \param    rMrProt      
///
///  \return   \arg \c SEQU__NORMAL  : If the Real time event bloc is okay
///            \arg \c SEQU_ERROR    : Otherwise
// --------------------------------------------------------------------------------------------
NLS_STATUS MiniFlash::applySETrackingActuationForCapsules(MrProt &rMrProt, long& lT, long lLine)
{
	NLS_STATUS         lStatus  = SEQU__NORMAL;
	//long lT = 0;
	//fRTEBInit( m_asSLC[0].getROT_MATRIX());
    //. Prepare FrequencyPhase objects of the RF pulse
    m_sSRF01zSet.prepSet (m_asSLC[0], m_sSRF01) ;
    m_sSRF01zNeg.prepNeg (m_asSLC[0], m_sSRF01) ;

	m_sSRF01zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sSRF01zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));

	m_sSRF02zSet.prepSet (m_asSLC[0], m_sSRF02) ;
    m_sSRF02zNeg.prepNeg (m_asSLC[0], m_sSRF02) ;

	m_sSRF02zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sSRF02zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
    /* -------------------------------------------------------- */
    /* Set the frequency/phase properties of the readout events */
    /* -------------------------------------------------------- */
    m_sADCX.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCX.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCX.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCX.getMDH().setFreeParameterByIndex(0,1); // 1 means x-axis
	m_sADCX.getMDH().setFreeParameterByIndex(3,SIMULTANEOUS); // Interleaved actuation and imaging

	m_sADCX_zSet.prepSet (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCX_zNeg.prepNeg (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/

	m_sADCX_zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sADCX_zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));


	// Apply tracking sequence, then actuation sequence
	// oufel ADD PHASE CYCLING
	//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
	//- *          Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
	//- *            (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
	//- *fRTEI(                                 ,              ,          ,          ,                ,              ,                ,      );
	//- **********************************************************************************************************************************************************
	fRTEI ( lT                                  , &m_sSRF01zSet,    &m_sSRF01,0,        0,            0,            0,    &m_sWakeUp );
	fRTEI ( lT + m_sSRF01.getDuration()         , &m_sSRF01zNeg,0,     0,  0,             &m_sGReadDeph,            0,    0 );
	if(tOff1<0)
		fRTEI ( lT += m_sSRF01.getDuration()+m_sGReadDeph.getTotalTime()+abs(tOff1)/*+500*/, &m_sSRF02zSet,  &m_sSRF02, 0, 0,0,            0,    0 );
	else
		fRTEI ( lT += m_sSRF01.getDuration()+m_sGReadDeph.getTotalTime()/*+abs(tOff1)*//*+500*/, &m_sSRF02zSet,  &m_sSRF02, 0, 0,0,            0,    0 );
	fRTEI ( lT + m_sSRF02.getDuration()         , &m_sSRF02zNeg,0,     0,              0,             0,            0,    0 );
	if(tOff1>0)
		fRTEI ( lT += m_sSRF02.getDuration()+abs(tOff1)/*+500*/    ,             0,            0,       0,     0,             &m_sGradRO,            0,    0 );
	else
		fRTEI ( lT += m_sSRF02.getDuration()/*+500*/    ,             0,            0,       0,     0,             &m_sGradRO,            0,    0 );
	fRTEI ( lT += m_sGradRO.getRampUpTime()     , &m_sADCX_zSet,     0,&m_sADCX,       0,             0,            0,    0 );
	fRTEI ( lT + m_sADCX.getDuration()          , &m_sADCX_zNeg,     0,       0,              0,             0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration() - m_sGradRO.getRampDownTime(),0, 0,          0,   &m_sGActuateX,             0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration() ,0, 0,          0,   &m_sGActuateX,             0,            0,    0 );
	fRTEI ( lT += m_sGradRO.getDuration()-m_sGradRO.getRampDownTime()   ,            0,             0,          0,              &m_sGActuateY,             &m_sGActuateX,            0,    0 );
	fRTEI ( lT += m_sGActuateX.getTotalTime()  ,            0,             0,          0,               0,             0,            0,    0 );

	return lStatus;
}


	/*
		setIceProgramPara(0,...)  --> 0: Com data, 1: Signal Data
		setIceProgramPara(1,...)  --> 1: Rotor, 2: Capsule
		setIceProgramPara(2,...)  --> Control type (0: Open Loop, 1:Commutation control , 2:FBLinearization, 3:PI)
		setIceProgramPara(3,...)  --> Nb rotors
		setIceProgramPara(4,...)  --> Channel to be used
		setIceProgramPara(5,...)  --> 0: Interleaved tracking and actuation, 1: Simulatneous track/actuation
		setIceProgramPara(6,...)  --> Kalman gain 
		setIceProgramPara(7,...)  --> Velocity Kalman gain
		setIceProgramPara(8,...)  --> P Gain
		setIceProgramPara(9,...)  --> I Gain
		setIceProgramPara(10,...) --> D Gain
		setIceProgramPara(11,...) --> FB linearization Gain 1
		setIceProgramPara(12,...) --> FB linearization Gain 1
		setIceProgramPara(13,...) --> gtMeas
		setIceProgramPara(14,...) --> gtRTFeedBack
		setIceProgramPara(15,...) --> Theta Final 1
		setIceProgramPara(16,...) --> Theta Final 2
		setIceProgramPara(17,...) --> Theta Final 3
		setIceProgramPara(18,...) --> Rotor arm radius
		setIceProgramPara(19,...) --> Duration tracking sequence
		setIceProgramPara(20,...) --> Max grad mT/m
		setIceProgramPara(21,...) --> Rotor Static Friction
		setIceProgramPara(22,...) --> Rotor Dynamic Friction
		setIceProgramPara(23,...) --> Rotor Load torque
#define ADC_TYPE 0
#define SIGNAL_DATA 1
#define COM_DATA 0

#define EXPERIMENT_TYPE 1
#define ROTOR_EXP 1
#define CAPSULE_EXP 2

#define CONTROL_TYPE 2
#define OPEN_LOOP 0
#define MAX_TORQUE 1
#define FBLINEARIZATION 2
#define PI 3

#define NB_ROTORS 3

#define NO_CHANNEL 4

#define TRACKING_ACTUATION_TYPE 5 
#define INTERLEAVED 0
#define SIMULTANEOUS 1

#define KALMAN_GAIN 6
#define KALMAN_VELOCITY_GAIN 7
#define P_GAIN 8
#define I_GAIN 9
#define D_GAIN 10
#define FB_LINERIZATION_GAIN_1 11
#define FB_LINERIZATION_GAIN_2 12
#define ACTUATION_DURATION_1 13
#define ACTUATION_DURATION_2 14
#define THETA_TARGET_1 15
#define THETA_TARGET_2 16
#define THETA_TARGET_3 17
#define ROTOR_ARM_RADIUS 18
#define TRACKING_DURATION 19
#define MAX_GRAD_AMP 20
#define ROTOR_STATIC_FRICTION 21
#define ROTOR_VISCOUS_FRICTION 22
#define ROTOR_LOAD_TORQUE 23
	*/
void MiniFlash::prepareComADC(MrProt &rMrProt)
{
	double actuationDuration;
	m_sADCCom.getMDH().setIceProgramPara(ADC_TYPE,COM_DATA); // Communication Data
	m_sADCCom.getMDH().setIceProgramPara(EXPERIMENT_TYPE,CAPSULE_EXP); // Capsule
	/*
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == INITIALIZE || 
	   m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == ACTIVE_MARKER)
		m_sADCCom.getMDH().setIceProgramPara(CONTROL_TYPE,OPEN_LOOP); // Open Loop if initialization mode
	else
		m_sADCCom.getMDH().setIceProgramPara(CONTROL_TYPE,PI); // Position control
*/
	m_sADCCom.getMDH().setIceProgramPara(2,(uint16_t) gK1); // Open Loop if initialization mode
	m_sADCCom.getMDH().setIceProgramPara(3,(uint16_t) gK2);// 1 capsule
	m_sADCCom.getMDH().setIceProgramPara(4,21); 

	/*
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == SIMULTANEOUS_CL)
	{
		m_sADCCom.getMDH().setIceProgramPara(TRACKING_ACTUATION_TYPE,1); // 1: Simulatneous track/actuation
	}
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == MULTI_CAPSULES)
	{
		m_sADCCom.getMDH().setIceProgramPara(TRACKING_ACTUATION_TYPE,1); // 1: Simulatneous track/actuation
	}
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == ALTERNATE_CL)
	{
		m_sADCCom.getMDH().setIceProgramPara(TRACKING_ACTUATION_TYPE,0); // 0: Interleaved tracking and actuation
	}

	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == SIMULTANEOUS_CL)
	{
		m_sADCCom.getMDH().setIceProgramPara(6,1); // 1: Simulatneous track/actuation
	}
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == MULTI_CAPSULES)
	{
		m_sADCCom.getMDH().setIceProgramPara(6,1); // 1: Simulatneous track/actuation
	}
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == ALTERNATE_CL)
	{
		m_sADCCom.getMDH().setIceProgramPara(6,0); // 0: Interleaved tracking and actuation
	}
*/	

	m_sADCCom.getMDH().setIceProgramPara(5, 1);  //  nb capsules
	//spoiler duration
	m_sADCCom.getMDH().setIceProgramPara(6,(uint16_t)((m_WIPParamTool.getDoubleValue (rMrProt, WIPDoublePeriod))*1000)); //microsec
	//imaging momentum
	m_sADCCom.getMDH().setIceProgramPara(7,(uint16_t)((m_sGradRO.getMomentumTOT() + m_sGReadDeph.getMomentumTOT())/1000.0));  //  
	//max grad
	m_sADCCom.getMDH().setIceProgramPara(8,21);  //  P Gain

	m_sADCCom.getMDH().setIceProgramPara(9,26);  //  nb Segments
	
	//m_sADCCom.getMDH().setIceProgramPara(D_GAIN,(uint16_t) m_WIPParamTool.getLongValue (rMrProt, WIPLongChannelID));  //  D Gain
	
	//m_sADCCom.getMDH().setIceProgramPara(11,90);  //  FB linearization Gain 1

	/*
	m_sADCCom.getMDH().setIceProgramPara(10, 6);  //  nb Segments
	m_sADCCom.getMDH().setIceProgramPara(11,180);  //  FB linearization Gain 1
	m_sADCCom.getMDH().setIceProgramPara(12,310);  //  FB linearization Gain 2
	m_sADCCom.getMDH().setIceProgramPara(13,130);   //  FB linearization Gain 2
	m_sADCCom.getMDH().setIceProgramPara(14,160);  //  FB linearization Gain 2
	m_sADCCom.getMDH().setIceProgramPara(15,30);  //  FB linearization Gain 2
	m_sADCCom.getMDH().setIceProgramPara(16,0);//gThetaFinal1);  // Theta target for second rotor, or rotor direction
*/
	//m_sADCCom.getMDH().setIceProgramPara(FB_LINERIZATION_GAIN_1,0);  //  FB linearization Gain 1
	//m_sADCCom.getMDH().setIceProgramPara(FB_LINERIZATION_GAIN_2,0);  //  FB linearization Gain 2
	//
	actuationDuration = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT) * 1000 - m_tTracking/1000;
	//m_sADCCom.getMDH().setIceProgramPara(ACTUATION_DURATION_1,(uint16_t) actuationDuration);  // Actuation time in ms
	//m_sADCCom.getMDH().setIceProgramPara(ACTUATION_DURATION_2,(uint16_t) m_timeAfterTrack); // Feed-back time 
	//
	//m_sADCCom.getMDH().setIceProgramPara(THETA_TARGET_1,(uint16_t) (gThetaFinal1*1000));  // Theta target for first rotor 
	//m_sADCCom.getMDH().setIceProgramPara(THETA_TARGET_2,(uint16_t) 2);//gThetaFinal1);  // Theta target for second rotor, or rotor direction
	//m_sADCCom.getMDH().setIceProgramPara(THETA_TARGET_3,(uint16_t) m_WIPParamTool.getLongValue (rMrProt, WIPLongChannelID) + 150);  // Theta target for third rotor
	

	m_sADCCom.getMDH().setIceProgramPara(17,512);  // Theta target for third rotor

	m_sADCCom.getMDH().setIceProgramPara(ROTOR_ARM_RADIUS,16);  // Rotor arm radius

	m_sADCCom.getMDH().setIceProgramPara(TRACKING_DURATION,18000);  // Duration tracking sequence (us)
	m_sADCCom.getMDH().setIceProgramPara(MAX_GRAD_AMP,abs(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitude)));  // Max Grad Amplitude
	m_sADCCom.getMDH().setIceProgramPara(ROTOR_STATIC_FRICTION,(uint16_t) gK1);  // Rotor Static Friction  NB * pow(10.0,-5.0) (default 8) (1 was used for max torque)
	m_sADCCom.getMDH().setIceProgramPara(ROTOR_VISCOUS_FRICTION,(uint16_t) gK2);  // Rotor viscous Friction NB * pow(10.0,-7.0) (default 100)(10 was used for max torque)
	m_sADCCom.getMDH().setIceProgramPara(ROTOR_LOAD_TORQUE,(uint16_t) m_WIPParamTool.getDoubleValue (rMrProt, WIPDoublePeriod) + 150);  // Rotor load torque

	/*
	uint16_t xRotorCenterZ = 643;
	uint16_t xRotorCenterY = 380;
	uint16_t yRotorCenterX = 410;
	uint16_t yRotorCenterZ = 359;
	uint16_t zRotorCenterX = 472;
	uint16_t zRotorCenterY = 403;

	
	m_sADCCom2.getMDH().setIceProgramPara(ADC_TYPE,COM_DATA); // Communication Data
	m_sADCCom2.getMDH().setIceProgramPara(1,xRotorCenterZ); // x-Rotor center z
	m_sADCCom2.getMDH().setIceProgramPara(2,xRotorCenterY); // x-Rotor center y
	//m_sADCCom2.getMDH().setIceProgramPara(3,yRotorCenterX); // y-Rotor center x
	//m_sADCCom2.getMDH().setIceProgramPara(4,yRotorCenterZ); // y-Rotor center z
	//m_sADCCom2.getMDH().setIceProgramPara(5,zRotorCenterX); // z-Rotor center x
	//m_sADCCom2.getMDH().setIceProgramPara(6,zRotorCenterY); // z-Rotor center y

	//Target Theta for multiple rotors control
	m_sADCCom2.getMDH().setIceProgramPara(7,18); // 18 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(8,0); // 0 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(9,0); // 0 rad/s

	m_sADCCom2.getMDH().setIceProgramPara(10,0); // 0 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(11,0); // 0 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(12,18); // 18 rad/s

	m_sADCCom2.getMDH().setIceProgramPara(13,0); // 0 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(14,18); // 18 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(15,0); // 0 rad/s

	m_sADCCom2.getMDH().setIceProgramPara(16,yRotorCenterX); // 0 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(17,yRotorCenterZ); // 18 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(18,zRotorCenterX); // 0 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(19,zRotorCenterY); // 0 rad/s
	*/
/*
	m_sADCCom2.getMDH().setIceProgramPara(ADC_TYPE,COM_DATA);// Communication Data
	
	m_sADCCom2.getMDH().setIceProgramPara(1,(uint16_t) m_nbSegments);  // Segments number 
	m_sADCCom2.getMDH().setIceProgramPara(2,(uint16_t) (m_roadMaps[0] * 180 / M_PI));  // First angle
	m_sADCCom2.getMDH().setIceProgramPara(3,(uint16_t) (m_roadMaps[1] * 180 / M_PI));  // Second angle
	m_sADCCom2.getMDH().setIceProgramPara(4,(uint16_t) (m_roadMaps[2] * 180 / M_PI));  // Third angle
	m_sADCCom2.getMDH().setIceProgramPara(5,(uint16_t) (m_roadMaps[3] * 180 / M_PI));  // Fourth angle
	m_sADCCom2.getMDH().setIceProgramPara(6,(uint16_t) (m_roadMaps[4] * 180 / M_PI));  // Fifth angle
	m_sADCCom2.getMDH().setIceProgramPara(7,(uint16_t) m_wayPoints[0]);  // First target
	m_sADCCom2.getMDH().setIceProgramPara(8,(uint16_t) m_wayPoints[1]);  // Second target
	m_sADCCom2.getMDH().setIceProgramPara(9,(uint16_t) m_wayPoints[2]);  // Third target
	m_sADCCom2.getMDH().setIceProgramPara(10,(uint16_t) m_wayPoints[3]);  // Fourth target
	m_sADCCom2.getMDH().setIceProgramPara(11,(uint16_t) m_wayPoints[4]);  // Fifth target
*/
}


void MiniFlash::printRotationMatrix(const sROT_MATRIX mat)
{
	#ifdef WIN32
	for(int i =0; i<3; i++)
	{
		for(int j = 0; j<3; j++)
			cout << mat.dMat[i][j];
		cout << endl;
	}
	#endif

}

