//    -----------------------------------------------------------------------------
//      Copyright (C) Siemens AG 1998  All Rights Reserved.
//    -----------------------------------------------------------------------------
//
//     Project: NUMARIS/4
//        File: \n4_servers1\pkg\MrServers\MrImaging\seq\a_MiniFLASH\a_MiniFLASH.h
//     Version: \main\9
//      Author: Clinical
//        Date: 2010-12-02 19:49:26 +01:00
//
//        Lang: C++
//
//     Descrip: Declarations for a_MiniFLASH.cpp
//
//     Remarks: This is the demo sequence MiniFLASH.
//              DO NOT base any diagnosis on images generated by this sequence.
//
//    -----------------------------------------------------------------------------


// Make sure that this header is read only once:
#ifndef a_MiniFlash_h
#define a_MiniFlash_h 1

//------------------------------
// Includes
//------------------------------

#include "MrServers/MrMeasSrv/MeasUtils/nlsmac.h"
#include "MrServers/MrImaging/libSBB/StdSeqIF.h"
#include "MrServers/MrImaging/libSeqUtil/libSeqUtil.h"

#include "MrServers/MrMeasSrv/SeqFW/libGSL/libGSL.h"               // fGSL... prototypes
#include "MrServers/MrMeasSrv/SeqFW/libSSL/libSSL.h"               // fSSL... prototypes
#include "MrServers/MrImaging/libSBB/libSBBmsg.h"                  // SBB_... error codes

#include "MrServers/MrProtSrv/MrProt/KSpace/MrKSpace.h"            // For KSpace
#include "MrServers/MrProtSrv/MrProt/MeasParameter/MrSysSpec.h"    // For GradSpec
#include "MrServers/MrProtSrv/MrProt/MeasParameter/MrRXSpec.h"     // For MrRXSpec
#include "MrServers/MrProtSrv/MrProt/MrProt.h"                     // MrProt
#include "MrServers/MrMeasSrv/SeqIF/SeqBuffer/SeqLim.h"            // SeqLim
#include "MrServers/MrProtSrv/MrProt/SeqIF/SeqExpo.h"              // SeqExpo
#include "MrServers/MrMeasSrv/SeqIF/libRT/sREADOUT.h"              // sREADOUT
#include "MrServers/MrMeasSrv/SeqIF/libRT/sGRAD_PULSE.h"           // sGRAD_PULSE
#include "MrServers/MrMeasSrv/SeqIF/libRT/sRF_PULSE.h"             // sRF_PULSE
#include "MrServers/MrMeasSrv/SeqIF/libRT/sFREQ_PHASE.h"           // sFREQ_PHASE

#include "MrServers/MrMeasSrv/SeqIF/libRT/SEQSemaphore.h" 

#include "MrServers/MrMeasSrv/SeqIF/libMES/SEQData.h"

#include "MrServers/MrMeasSrv/SeqIF/Sequence/sequmsg.h"
#include "MrServers/MrImaging/seq/common/WIPParameterTool/WIPParameterTool.h"

#ifdef _VB_LINE
#include "MrServers/MrProtSrv/MrProt/SeqDefines.h"
#endif


#ifdef WIN32
	#include "TCHAR.h"
#endif

#ifdef BUILD_SEQU
    #define __OWNER
#endif

// The following include is necessary for the DLL generation
#include "MrCommon/MrGlobalDefinitions/ImpExpCtrl.h"



#define MAX_NB_STEP 100
#define MAX_NB_EXTERN_STEP 10
#define PERIOD_FB_GRAD 5000 // micro seconds

//------------------------------
// Forward declarations
//------------------------------

class MrProt;
class SeqLim;
class SeqExpo;
class SEQData;
class Sequence;

namespace SEQ_NAMESPACE
{
	/*
		setIceProgramPara(0,...) --> 0: Com data, 1: Signal Data
		setIceProgramPara(1,...) --> 1: Rotor, 2: Capsule
		setIceProgramPara(2,...) --> Control type (0: Open Loop, 1:Commutation control , 2:FBLinearization, 3:PI)
		setIceProgramPara(3,...) --> Nb rotors
		setIceProgramPara(4,...) --> Channel to be used
		setIceProgramPara(5,...) --> 0: Interleaved tracking and actuation, 1: Simulatneous track/actuation
		setIceProgramPara(6,...) --> Kalman gain 
		setIceProgramPara(7,...) --> Velocity Kalman gain
		setIceProgramPara(8,...) --> P Gain
		setIceProgramPara(9,...) --> I Gain
		setIceProgramPara(10,...) --> D Gain
		setIceProgramPara(11,...) --> FB linearization Gain 1
		setIceProgramPara(12,...) --> FB linearization Gain 2
		setIceProgramPara(13,...) --> gtMeas
		setIceProgramPara(14,...) --> gtMeas2
		setIceProgramPara(15,...) --> Theta Final 1
		setIceProgramPara(16,...) --> Theta Final 2
		setIceProgramPara(17,...) --> Theta Final 3
		setIceProgramPara(18,...) --> Rotor arm radius
		setIceProgramPara(19,...) --> Duration tracking sequence
		setIceProgramPara(20,...) --> Max grad mT/m
		setIceProgramPara(21,...) --> Rotor Static Friction
		setIceProgramPara(22,...) --> Rotor Dynamic Friction
		setIceProgramPara(23,...) --> Rotor Load torque

	*/
#define ADC_TYPE 0
#define SIGNAL_DATA 1
#define COM_DATA 0

#define EXPERIMENT_TYPE 1
#define ROTOR_EXP 1
#define CAPSULE_EXP 2

#define CONTROL_TYPE 2
#define OPEN_LOOP 0
#define MAX_TORQUE 1
#define FBLINEARIZATION 2
#define PI 3
#define LYAPUNOV_POS  4
#define LYAPUNOV_VEL  5

#define NB_ROTORS 3

#define NO_CHANNEL 4

#define TRACKING_ACTUATION_TYPE 5 
#define INTERLEAVED 0
#define SIMULTANEOUS 1

#define KALMAN_GAIN 6
#define KALMAN_VELOCITY_GAIN 7
#define P_GAIN 8
#define I_GAIN 9
#define D_GAIN 10
#define FB_LINERIZATION_GAIN_1 11
#define FB_LINERIZATION_GAIN_2 12
#define ACTUATION_DURATION_1 13
#define ACTUATION_DURATION_2 14
#define THETA_TARGET_1 15
#define THETA_TARGET_2 16
#define THETA_TARGET_3 17
#define ROTOR_ARM_RADIUS 18
#define TRACKING_DURATION 19
#define MAX_GRAD_AMP 20
#define ROTOR_STATIC_FRICTION 21
#define ROTOR_VISCOUS_FRICTION 22
#define ROTOR_LOAD_TORQUE 23



	enum WIPParameterPositions {
		WIPSelectionType    ,
        WIPDoubleAmplitude  ,
		WIPDoublePeriod     ,
		WIPLongRepetition   ,
		WIPSelectionPlane   ,
		WIPDoubleThetaF1	,
		WIPDoubleK1			,
		WIPDoubleK2			,
		WIPDoubleDurationEXT,
		WIPDoubleRTDelay    ,
		WIPDoubleWakeUpDelay,
		WIPDoubleFreqOffset ,
		WIPSelectionSeq     ,
		WIPLongChannelID    ,
    };

	enum WIPParameterTYPE_OPTION {
		  SIMULTANEOUS_CL            = 10,
		  ALTERNATE_CL               = 20,
		  INITIALIZE				 = 30,
		  ACTIVE_MARKER	     		 = 40,
		  MULTI_CAPSULES			 = 50,
	};
    static const char* sOptionType1  = "Simultaneous";
	static const char* sOptionType2  = "Alternate";
	static const char* sOptionType3  = "Initialisation";
	static const char* sOptionType4  = "ActiveMarker";
	static const char* sOptionType5  = "MultiCapsule";


	enum WIPParameterSEQ_OPTION {
		  SPIN_ECHO     = 100,
		  GRADIENT_ECHO = 200,
		  NO_TRACKING   = 300,

	};
	enum WIPParameterPLANE_OPTION {
		X_Y = 1,
		X_Z = 2,
		Y_Z = 3,
		ARB1 = 4,
		ARB2 = 5,
		X_Z_PRIME = 6,
		X_X  = 7,
		Y_Y  = 8,
		Z_Z  = 9,
		X_Y_PRIME = 10,
		Y_Z_PRIME = 11,

    };


	static const char* sOptionPlane1 = "(x,y)";
	static const char* sOptionPlane2 = "(x,z)";
	static const char* sOptionPlane3 = "(y,z)";
	static const char* sOptionPlane4 = "ARB1";
	static const char* sOptionPlane5 = "ARB2";
	static const char* sOptionPlane6 = "(x,z)'";
	static const char* sOptionPlane7 = "(x,x)";
	static const char* sOptionPlane8 = "(y,y)";
	static const char* sOptionPlane9 = "(z,z)";
	static const char* sOptionPlane10 = "(x,y)'";
	static const char* sOptionPlane11 = "(y,z)'";

    static const char* sOptionSeq1   = "Spin Echo";
	static const char* sOptionSeq2   = "Gradient echo";
	static const char* sOptionSeq3   = "No tracking";

	static int iUTraceMarker = 0;


    // forward declaration
    class MiniFlashUI;

	/**
	 * @brief The MiniFlash sequence class is intended as a demo implementation for teaching purposes. Therefore, all
	 * functions are implemented in a "minimalistic" fashion.
	 */
    class __IMP_EXP MiniFlash : public StdSeqIF
    {
    public:
		/**
		 * @brief Standard constructor.
		 * 
		 * Creates a MiniFlash object with all class member objects being initialized.
		 */
        MiniFlash();


		/**
		 * @brief Destructor.
		 * 
		 * The MiniFlash sequence is destructed. A potentially associated MiniFlashUI object will
		 * be deleted.
		 */
        virtual ~MiniFlash();


		/**
		 * @brief Initialization of the sequence.
		 *
		 * This method is equivalent to the former fSeqInit(...)-function.
		 *
		 * Basically, the "hard limits" for the protocol parameters are set. The hard limits define the maximum
		 * allowed range for each parameter.
		 *
		 * In addition, the associated MiniFlashUI object is created on the Windows-32 (host) machine.
		 *
		 * @return If running on a Windows-32-machine, the status will tell whether the creation of MiniFlashUI
		 *         was successful. If not running on a Windows-32-machine, the return value will always
		 *         "SEQU__NORMAL".
		 */
        virtual NLSStatus initialize(SeqLim &rSeqLim);


		/**
		 * @brief Preparation of the sequence.
		 *
		 * This method is equivalent to the former fSeqPrep(...)-function. It checks whether or not the
		 * current protocol is valid (i.e. a sequence run with the given parameters is possible).
		 *
		 * The method is called during the binary search (graphical user interface of EXAM or POET) and prior
		 * to executing a sequence.
		 *
		 * @return Success is indicated by "SEQU__NORMAL". Otherwise, the appropriate error code is returned.
		 */
        virtual NLSStatus prepare(MrProt &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo);


		/**
		 * @brief Check of the sequence.
		 *
		 * This method is equivalent to the former fSeqCheck(...)-function. It checks whether or not the
		 * sequence could do any harm to the patient. This could be:
		 *
		 * - nerve stimulation in the patient
		 * - exceeding of the specific absorbtion rate (SAR) limit
		 *
		 * @return Success is indicated by "SEQU__NORMAL". Otherwise, the appropriate error code is returned.
		 */
        virtual NLSStatus check(MrProt &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo, SEQCheckMode *  pSEQCheckMode);


        // * ---------------------------------------------------------------------- *
        // *                                                                        *
        // * Name        :  MiniFlash::run                                          *
        // *                                                                        *
        // * Description :  Execution of the sequence                               *
        // *                                                                        *
        // * Return      :  NLS status                                              *
        // *                                                                        *
        // * ---------------------------------------------------------------------- *
        virtual NLSStatus run(MrProt &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo);


        // * ---------------------------------------------------------------------- *
        // *                                                                        *
        // * Name        :  Fl3d_ce::runKernel                                      *
        // *                                                                        *
        // * Description :  Executes the basic timing of the real-time sequence.    *
        // *                                                                        *
        // * Return      :  NLS status                                              *
        // *                                                                        *
        // * ---------------------------------------------------------------------- *
        virtual NLS_STATUS runKernel(MrProt &rMrProt,SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo, long lKernelMode, long lSlice, long lPartition, long lLine);

        // * ---------------------------------------------------------------------- *
        // *                                                                        *
        // * Name        :  MiniFlash::receive                                      *
        // *                                                                        *
        // * Description :  Executes the basic timing of the real-time sequence.    *
        // *                                                                        *
        // * Return      :  NLS status                                              *
        // *                                                                        *
        // * ---------------------------------------------------------------------- *
		virtual NLSStatus receive(SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo, SEQData& rSEQData);
                
        //  --------------------------------------------------------------
        //
        //  Name        :  getUI
        //
        //  Description :
        /// \brief <b>     Returns the pointer to the Templ UI class  </b>
        ///
        ///                This method is only sensible on the host.
        ///                On the measurement system, it will return an nearly empty object.
        ///
        //  Return      :  MiniFlashUI*
        //
        //  --------------------------------------------------------------
        const MiniFlashUI* getUI (void) const;


protected:
    // * ---------------------------------------------------------------------- *
    // * RF spoiling phase                                                      *
    // * ---------------------------------------------------------------------- *
    double m_dRFSpoilPhase;


    // * ---------------------------------------------------------------------- *
    // * Increment of the Rf spoiling phase                                     *
    // * ---------------------------------------------------------------------- *
    double m_dRFSpoilIncrement;


    // * ---------------------------------------------------------------------- *
    // * Index of the k-space center line                                       *
    // * ---------------------------------------------------------------------- *
    long m_lCenterLine;

    // * ---------------------------------------------------------------------- *
    // * flag to signal that feedback is received                               *
    // * ---------------------------------------------------------------------- *

	bool m_feedbackReceived;

    // * ---------------------------------------------------------------------- *
    // * Mini Rise Time                                                         *
    // * ---------------------------------------------------------------------- *
    double m_dMinRiseTime;


    // * ---------------------------------------------------------------------- *
    // * Mini Rise Time                                                         *
    // * ---------------------------------------------------------------------- *
    double m_dGradMaxAmpl;


    // * ---------------------------------------------------------------------- *
    // * No of phase encoding lines measured per second                         *
    // * ---------------------------------------------------------------------- *
    long m_lLinesPerSec;


    // * ---------------------------------------------------------------------- *
    // * No of phase encoding lines with iPAT                                   *
    // * m_lLinesToMeasure and m_lLinesToMeasureMax are identical if iPAT is    *
    // * disabled.                                                              *
    // * ---------------------------------------------------------------------- *
    int32_t m_lLinesToMeasure;


    // * ---------------------------------------------------------------------- *
    // * Slice position information (rotation matrices and shifts)              *
    // * ---------------------------------------------------------------------- *
    sSLICE_POS m_asSLC[1];
	        
	// * ---------------------------------------------------------------------- *
    // * RF Pulses and NCO                                                      *
    // * ---------------------------------------------------------------------- *
    //sRF_PULSE_RECT    m_sSRF01;
	sRF_PULSE_SINC   m_sSRF01;
    sFREQ_PHASE      m_sSRF01zSet;
    sFREQ_PHASE      m_sSRF01zNeg;

	sRF_PULSE_SINC   m_sSRF01OffsetNegative;
    sFREQ_PHASE      m_sSRF01zSetOffsetNegative;
    sFREQ_PHASE      m_sSRF01zNegOffsetNegative;
	
	sRF_PULSE_SINC   m_sSRF01OffsetPositive;
    sFREQ_PHASE      m_sSRF01zSetOffsetPositive;
    sFREQ_PHASE      m_sSRF01zNegOffsetPositive;

	//sRF_PULSE_RECT    m_sSRF02;
	sRF_PULSE_SINC   m_sSRF02;
    sFREQ_PHASE      m_sSRF02zSet;
    sFREQ_PHASE      m_sSRF02zNeg;

	sRF_PULSE_SINC   m_sSRF02OffsetNegative;
    sFREQ_PHASE      m_sSRF02zSetOffsetNegative;
    sFREQ_PHASE      m_sSRF02zNegOffsetNegative;

	sRF_PULSE_SINC   m_sSRF02OffsetPositive;
    sFREQ_PHASE      m_sSRF02zSetOffsetPositive;
    sFREQ_PHASE      m_sSRF02zNegOffsetPositive;

	sRF_PULSE_SINC   m_sSRFActiveMarker;
    sFREQ_PHASE      m_sSRFzSetActiveMarker;
    sFREQ_PHASE      m_sSRFzNegActiveMarker;

	sRF_PULSE_SINC   m_sSRFActiveMarkerRefocus;
    sFREQ_PHASE      m_sSRFzSetActiveMarkerRefocus;
    sFREQ_PHASE      m_sSRFzNegActiveMarkerRefocus;


    // * ---------------------------------------------------------------------- *
    // * Read Out                                                               *
    // * ---------------------------------------------------------------------- *
    sREADOUT         m_sADCX;
    sFREQ_PHASE      m_sADCX_zSet;
    sFREQ_PHASE      m_sADCX_zNeg;
    // * Feedback Generator                                                     *
	sREADOUT         m_sADCY;
    sFREQ_PHASE      m_sADCY_zSet;
    sFREQ_PHASE      m_sADCY_zNeg;
	// * Feedback Generator                                                     *
	sREADOUT         m_sADCZ;
    sFREQ_PHASE      m_sADCZ_zSet;
    sFREQ_PHASE      m_sADCZ_zNeg;

    // * Feedback Generator ADC used for Capusle Imaging                        *
    sREADOUT         m_sADCXCapsule;
    sFREQ_PHASE      m_sADCX_zSetCapsule;
    sFREQ_PHASE      m_sADCX_zNegCapsule;
    sREADOUT         m_sADCYCapsule;
    sFREQ_PHASE      m_sADCY_zSetCapsule;
    sFREQ_PHASE      m_sADCY_zNegCapsule;
    sREADOUT         m_sADCZCapsule;
    sFREQ_PHASE      m_sADCZ_zSetCapsule;
    sFREQ_PHASE      m_sADCZ_zNegCapsule;
	// * Data communication with the ICE. (Controller gains, Target position...)
	sREADOUT         m_sADCCom;
    sFREQ_PHASE      m_sADCCom_zSet;
    sFREQ_PHASE      m_sADCCom_zNeg;
	sREADOUT         m_sADCCom2;
    sFREQ_PHASE      m_sADCCom2_zSet;
    sFREQ_PHASE      m_sADCCom2_zNeg;
	// * ---------------------------------------------------------------------- *
    // * Gradient                                                               *
    // * ---------------------------------------------------------------------- *
    sGRAD_PULSE_RO   m_sGradRO        ;
    sGRAD_PULSE      m_sGReadDeph     ;
	sGRAD_PULSE_RO   m_sGradROGRE     ;
    sGRAD_PULSE      m_sGReadDephGRE  ;
    sGRAD_PULSE      m_sGReadRephGRE  ;

	// * ---------------------------------------------------------------------- *
    // * Sync Bits                                                              *
    // * ---------------------------------------------------------------------- *

	sSYNC_WAKEUP m_sWakeUp;

    // * ---------------------------------------------------------------------- *
    // * Propulsion gradients                                                   *
    // * ---------------------------------------------------------------------- *

	sGRAD_PULSE      m_sGActuateX;
	sGRAD_PULSE      m_sGActuateY;
	sGRAD_PULSE      m_sGActuateZ;
	

    int			     m_nbStep;

	SEQSemaphore m_sFeedbackSemaphore;          // used to synchronise run and receive
	
	uint16_t m_loop_test; 
	uint16_t m_loopTestClosedLoop; 
	uint16_t m_interleavedOrSimult; // 0 for interleaved, 1 for simult

	int32_t  m_imagingPlane;

	long tOff1;
	long tOff2;
	long tOffActiveMarker;

	bool m_isRotorCenterAndRaduisFound;
    bool m_isDataSentToIce;
	bool m_isPause;

	// Sequence timming information
	double m_tCycle; // m_tcycle = tracking time + actuation time
	double m_tTracking; // Tracking sequence duration
	long m_nbGradBeforeTrack;
	long m_nbGradAfterTrack;
	long m_nbGradAtWakeUp;
	double m_timeAfterTrack;

    //  --------------------------------------------------------------
    /// \brief <b> UI class for Templ
    ///
    ///         This class is basically empty on the measurement system
    //  --------------------------------------------------------------
    MiniFlashUI* m_pUI;

    //  ------------------------------------------------------------------
    //
    //  Name        :  MiniFlash::createUI
    //
    //  Description :
    /// \brief <b>     Instantiation of UI classes   </b>
    //
    //  Return      :  NLS status
    //
    //  ------------------------------------------------------------------
    virtual NLS_STATUS createUI (SeqLim &rSeqLim);
    
	

    //  ------------------------------------------------------------------
    //
    //  Name        :  MiniFlash::UnusedArg
    //
    //  Description :
    /// \brief         Used to avoid compiler warnings
    //
    //  Return      :  void
    //
    //  ------------------------------------------------------------------
    template< class TYPE > void UnusedArg (TYPE Argument) const { if( false ) { TYPE Dummy; Dummy = Argument; } };

	// * ---------------------------------------------------------------------- *
    // * User interface                                                         *
    // * ---------------------------------------------------------------------- *
	WPT_NAMESPACE::WIPParameterTool m_WIPParamTool;
private:

    // * ------------------------------------------------------------------ *
    // * Copy constructor not implemented                                   *
    // * ------------------------------------------------------------------ *
    MiniFlash (const MiniFlash &right);


    // * ------------------------------------------------------------------ *
    // * Assignment operator not implemented                                *
    // * ------------------------------------------------------------------ *
    MiniFlash & operator=(const MiniFlash &right);

	
	//double m_prjAngle;

    void applyRotMatrix(int32_t axis);
    void applyRotMatrix(double angle);
	void printRotationMatrix(const sROT_MATRIX mat);

	void prepareComADC(MrProt &rMrProt);

	NLS_STATUS sendComDataToIce(sREADOUT &adc, sFREQ_PHASE &adcSet, sFREQ_PHASE &adcNeg, int index);
	
	NLS_STATUS applyInitPulses                    (MrProt &rMrProt, long& lT, long lLine);
	NLS_STATUS applySETrackingActuationForCapsules(MrProt &rMrProt, long& lT, long lLine);
	NLS_STATUS pause1Sec                          (MrProt &rMrProt, long& lT, long lLine);

};
};

#endif
