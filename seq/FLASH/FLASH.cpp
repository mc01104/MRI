// --------------------------------------------------------------------------------------------
//    Copyright (C) Siemens AG 2010  All Rights Reserved. Confidential.
// --------------------------------------------------------------------------------------------
//
//  Project: NUMARIS/4
//     File: \n4\pkg\MrServers\MrImaging\seq\FLASH\FLASH.cpp
//   Author: H IM MR PLM AW T-AFW
//
//     Lang: C++
//
//  Descrip: Source file for FLASH Sequence
//
//  Remarks: This is the demo sequence FLASH.
//           DO NOT base any diagnosis on images generated by this sequence!
//
//
//  EGA Requirement Key: As shown on the following lines:
//
//   Abbrev.   Translation                                         Relevant for
//   -------   -----------                                         ------------
//   EGA-All   All of the following keys:                          All EGA requirements
//   EGA-Any   All or any of the following keys:                   All EGA requirements
//   EGA-01    {:IMPLEMENT:000_EGA_BildOri_SW_SequenzROVz::}       GR/GP   polarity
//   EGA-02    {:IMPLEMENT:000_EGA_BildPos_SW_SequenzSSelVz::}     GS      polarity
//   EGA-03    {:IMPLEMENT:000_EGA_BildMass_SW_SequenzROPC::}      GR/GP   amplitude
//   EGA-04    {:IMPLEMENT:000_EGA_BildPos_SW_SequenzSSel::}       GS      amplitude
//   EGA-05    {:IMPLEMENT:000_EGA_BildPos_SW_NCOFrequenzSSel::}   SRF     frequency
//   EGA-06    {:IMPLEMENT:000_EGA_BildPos_SW_NCOFrequenzRO::}     Readout frequency
//   EGA-07    {:IMPLEMENT:000_EGA_BildOri_SW_OrientierungTest::}  Image orientation
//
// --------------------------------------------------------------------------------------------

#include "MrServers/MrImaging/seq/FLASH/FLASH.h"
#include "MrServers/MrImaging/seq/FLASH/FLASH_UI.h"

#include "MrServers/MrImaging/seq/FLASH/FLASHSampling.h"
#include "MrServers/MrImaging/libSL/StdSL_ID.h"

#include "ProtBasic/Interfaces/MrPat.h"

#include "MrServers/MrImaging/libSeqUtil/libSeqUtil.h"
#include "MrServers/MrMeasSrv/MeasNuclei/IF/MeasKnownNuclei.h"
#include "MrServers/MrProtSrv/MrProt/MeasParameter/MrSysSpec.h"

#include "MrCommon/UTrace/Macros.h"
#include "MrServers/MrImaging/libMath/MrException.h"

#include "ProtBasic/Interfaces/KSpaceDefines.h"
#include "MrServers/MrMeasSrv/SeqFW/libSSL/libSSL.h"
#include "MrServers/MrProtSrv/MrProt/SeqDefines.h"

#include "MrServers/MrProtSrv/MrProt/CoilSelect/MrRxCoilSelect.h"


// --------------------------------------------------------------------------------------------
// Debugging:
// --------------------------------------------------------------------------------------------
//
// Please use UTRACE to log debugging information instead of the commands "cout" or "printf".
//
// The logged information can be accessed with the tool "LogViewer". You can start this tool
// by just typing in "logviewer" in the IDEA-command shell.
//
// Example usage:
//
//   UTRACE (Debug, iUTraceMarker, "Test debug message: " << iSomeTestVariable);
//   UTRACE (Error, iUTraceMarker, "Test error message!");
//
// --------------------------------------------------------------------------------------------


#ifndef SEQ_NAMESPACE
    #error SEQ_NAMESPACE not defined
#endif


#ifdef SEQUENCE_CLASS_FLASH
    // define a method to create a FLASH sequence instance
    SEQIF_DEFINE (SEQ_NAMESPACE::Flash)
#endif


using namespace SEQ_NAMESPACE;
using namespace KSpace;
using namespace KSA;
using namespace SL;
using namespace WPT_NAMESPACE;


Flash::Flash (void)
    : m_lKSpacePointsToMeasure (0)
    , m_lKSpacePointsToCheck   (0)
    , m_lSlicesToMeasure       (1)
    , m_dMinRiseTime           (100000)
    , m_dGradMaxAmpl           (0)
    , m_SamplingConfigurator   ()
    , m_CheckSampling          ()
    , m_SLM                    ()
    , m_SL                     ("StdSL"     , &m_SLM)
    , m_FISPKernel             ("FISPKernel", &m_SLM)
    , m_FLASHKernel            (&m_FISPKernel, RFSPOIL_INCREMENTdeg)
    , m_pFlashUI               (new FlashUI())
    , m_WIPParamTool           (*this)
{
}



Flash::~Flash (void)
{
    delete m_pFlashUI;
}



NLSStatus Flash::initialize (SeqLim& rSeqLim)
{
    // --------------------------------------------------------------------------------------------
    // Define sequence hard limits
    // --------------------------------------------------------------------------------------------
    //
    // In the following passage there are many methods to define sequence dependent limits on UI
    // parameters. The methods do all have the same signature:
    //
    //   setParameter (min value, max value, increment, default value)
    //
    // The values which are defined here are the "hard sequence limits". The UI will however find
    // the actual limits by means of the so-called "binary search". This algorithm is explained in
    // the IDEA manual.


    double  dMin = 0;
    double  dMax = 0;
    double  dInc = 0;
    double  dDef = 0;

    long    lMin = 0;
    long    lDef = 0;

    // provide general information about the sequence
    rSeqLim.setMyOrigFilename (__FILE__);
    rSeqLim.setSequenceOwner ("USER");


    // --------------------------------------------------------------------------------------------
    // Define the sequence hint text
    // --------------------------------------------------------------------------------------------
    //
    // The sequence hint text is available via the "imprint name.dll" command

    std::ostringstream HintText;

    HintText << "\n";
    HintText << "    Application: FLASH sequence for demonstration purpose\n";
    HintText << "    Shows how to use libCSL, libKSpace and WIPParameterTool";
    HintText << "    \n";
    HintText << "    Build: " << __DATE__ << "   " << __TIME__ << "\n";

    rSeqLim.setSequenceHintText (const_cast <char*> (HintText.str().c_str()));


    // --------------------------------------------------------------------------------------------
    // Define the system hardware requirements
    // --------------------------------------------------------------------------------------------

    rSeqLim.setAllowedFrequency     (8000000, 500000000); // Hz
    rSeqLim.setRequiredGradAmpl     (10.0);               // mT/m
    rSeqLim.setRequiredGradSlewRate (10.0);               // (mT/m)/ms

    // Define selectable gradient modes
    rSeqLim.setGradients(
        SEQ::GRAD_FAST,
        SEQ::GRAD_NORMAL,
        SEQ::GRAD_WHISPER,
        SEQ::GRAD_FAST_GSWD_RISETIME,
        SEQ::GRAD_NORMAL_GSWD_RISETIME,
        SEQ::GRAD_WHISPER_GSWD_RISETIME
    );

    // Gradient TokTokTok at Measurement start
    rSeqLim.setIntro (SEQ::OFF, SEQ::ON);


    // --------------------------------------------------------------------------------------------
    // Define supported nuclei
    // --------------------------------------------------------------------------------------------
    //
    // Remark: Besides this change, you may have to adapt some default parameters, so that the
    //         sequence will prepare successfully on the default protocol. (e.g. default bandwidth
    //         to 130 Hz instead of 390 Hz)
    //
    // Options for supported nuclei: NUCLEI_ALL
    //                               NUCLEUS_1H
    //                               NUCLEUS_31P

    rSeqLim.setSupportedNuclei (NUCLEI_ALL.get().c_str());


    // --------------------------------------------------------------------------------------------
    // Define basic sequence parameters
    // --------------------------------------------------------------------------------------------

    int lDefBaseResolution = 256;

    rSeqLim.setBaseResolution    ( 64,  512, SEQ::INC_64, lDefBaseResolution);
    rSeqLim.setPELines           ( 32, 1024,           1, lDefBaseResolution);
    rSeqLim.setPhaseOversampling (0.0,  1.0,        0.01,                0.0);

    
    // --------------------------------------------------------------------------------------------
    // Define hard limits for field-of-view (FOV) [mm]
    // --------------------------------------------------------------------------------------------

    dMax = SysProperties::getFoVMax();  // maximum FoV depends on gradient linearity
    dDef = 300.0;                       // default FOV is 300 mm
    dInc =   1.0;                       // allowed stepsize is 1 mm
    dMin =  20.0;                       // minimum FoV is limited by the gradient performance.

    // update minimum value such that difference of min and max value is a multiple of dInc
    dMin = fSDSdRoundUpMinimum (dMin, dMax, dInc);

    if (dDef < dMin) dDef = dMin;
    if (dDef > dMax) dDef = dMax;

    // Set limits in SeqLim instance
    rSeqLim.setReadoutFOV (dMin, dMax, dInc, dDef);
    rSeqLim.setPhaseFOV   (dMin, dMax, dInc, dDef);


    // --------------------------------------------------------------------------------------------
    // Define timing limits (TR/TE/TI)
    // --------------------------------------------------------------------------------------------
    //
    // The first argument in the limit definition of timing parameters is an array index.
    // (e.g. for certain sequences, multiple TR values can be defined)
    //
    // Options for inversion mode: INVERSION_OFF
    //                             SLICE_SELECTIVE
    //                             VOLUME_SELECTIVE

    rSeqLim.setContrasts      (1,  1,  0,  1);
    
    // calculation of limits for TI
    lMin = 8000;
    lMin = fSDSRoundToInc (lMin, 1000);
    lDef = (lMin <= 150000) ? 150000 : lMin;

    rSeqLim.setTI (0, lMin, 2000000, 1000,   lDef); // [us]
    rSeqLim.setTR (0,  100, 5000000,  100, 100000); // [us]
    rSeqLim.setTE (0,  100,  100000,  100,  30000); // [us]

    // do not allow inversion
    rSeqLim.setInversion (SEQ::INVERSION_OFF);
    rSeqLim.setSTIRMode  (SEQ::OFF);

    
    // --------------------------------------------------------------------------------------------
    // Define slices and slice mode parameter limits
    // --------------------------------------------------------------------------------------------
    //
    // Remark: Slice reordering is not implemented for this sequence. Furthermore, the lines loop
    //         is inside of the slices loop. We call this mode "sequential" (-> MSM_SEQUENTIAL).
    //
    // Options for multi slice mode:          MSM_SEQUENTIAL
    //                                        MSM_SINGLESHOT
    //                                        MSM_INTERLEAVED
    //
    // Options for slice series mode:         ASCENDING
    // (excitation order)                     INTERLEAVED
    //                                        DESCENDING
    //
    // Options for allowed slice orientation: DOUBLE_OBLIQUE
    //                                        ORTHOGONAL
    //                                        SINGLE_OBLIQUE

    rSeqLim.setConcatenations      (    1,            1,      1,     1);
    rSeqLim.setSlices              (    1, K_NO_SLI_MAX,      1,     1);
    rSeqLim.setSliceThickness      (2.000,       10.000,  0.500, 5.000);
    rSeqLim.setSliceDistanceFactor (0.000,        8.000,  0.010, 0.200);

    rSeqLim.setMultiSliceMode      (SEQ::MSM_SEQUENTIAL);
    rSeqLim.setSliceSeriesMode     (SEQ::ASCENDING, SEQ::INTERLEAVED, SEQ::DESCENDING);

    rSeqLim.enableSliceShift(); // allow offcenter slice position
    rSeqLim.enableMSMA();
    rSeqLim.enableOffcenter();  // allow an offcenter position of the slab
    rSeqLim.setAllowedSliceOrientation (SEQ::DOUBLE_OBLIQUE);

    rSeqLim.setAveragingMode (SEQ::INNER_LOOP, SEQ::OUTER_LOOP);


    // --------------------------------------------------------------------------------------------
    // Define 3D-parameter limits
    // --------------------------------------------------------------------------------------------

    rSeqLim.setDimension (SEQ::DIM_2, SEQ::DIM_3);

    rSeqLim.setPartition         (    8,     256,           2,          32);
    rSeqLim.setImagesPerSlab     (    8,     512,           2,          32);
    rSeqLim.setSlabThickness     (5.000, 160.000);
    rSeqLim.set3DPartThickness   (0.100,   5.000, 0.01 , rSeqLim.getSlabThickness().getMax() / rSeqLim.getPartition().getDef());
    rSeqLim.setSliceOversampling (0.000,   1.000, 0.010, 0.000);

    rSeqLim.setMinSliceResolution (0.5); // Minimum fraction of actually measured slices


    // --------------------------------------------------------------------------------------------
    // Set standard limits related to k-space sampling (e.g. for PAT)
    // --------------------------------------------------------------------------------------------

    m_SamplingConfigurator.setLimits (rSeqLim, false);


    // --------------------------------------------------------------------------------------------
    // Allow turning on elliptical scanning
    // --------------------------------------------------------------------------------------------

    rSeqLim.setEllipticalScanning (SEQ::OFF, SEQ::ON);
    
    
    // --------------------------------------------------------------------------------------------
    // Define parallel acquisition technique (PAT) limits
    // --------------------------------------------------------------------------------------------
    
    rSeqLim.setPATMode (SEQ::PAT_MODE_NONE, SEQ::PAT_MODE_GRAPPA, SEQ::PAT_MODE_SENSE);
    rSeqLim.setRefLinesPE    (12, 30, 1, 24);
    rSeqLim.setAccelFactorPE ( 1,  4, 1,  2);


    // --------------------------------------------------------------------------------------------
    // Define partial fourier (PF) limits
    // --------------------------------------------------------------------------------------------

    rSeqLim.setPhasePartialFourierFactor (SEQ::PF_OFF, SEQ::PF_HALF, SEQ::PF_5_8, SEQ::PF_6_8, SEQ::PF_7_8);


    // --------------------------------------------------------------------------------------------
    // Hide some switches
    // --------------------------------------------------------------------------------------------

    rSeqLim.getAsymmetricEcho().setDisplayMode (SEQ::DM_OFF);
    rSeqLim.getEPIFactor().setDisplayMode (SEQ::DM_OFF);
    rSeqLim.getInversion().setDisplayMode (SEQ::DM_OFF);


    // --------------------------------------------------------------------------------------------
    // Define loop control parameter limits
    // --------------------------------------------------------------------------------------------
    //
    // Remark: 511 repetitions result in 512 measurements

    rSeqLim.setRepetitions (0, 511, 1, 0);
    rSeqLim.setAverages    (1,  32, 1, 1);

    rSeqLim.setRepetitionsDelayTime (   0, 2000000000, 100000, 0);
    rSeqLim.setTD                   (0, 0,   30000000,   1000, 0);


    // --------------------------------------------------------------------------------------------
    // Define preparation pulse parameter limits
    // --------------------------------------------------------------------------------------------
    //
    // MTC  = magnetization transfer contrast
    // PSat = Parallel Saturation Pulse
    // RSat = Regional Saturation Pulse
    // TSat = Travelling Saturation Pulse
    //
    // Fat suppression modes:   FAT_SUPPRESSION_OFF
    //                          FAT_SATURATION
    //                          FAT_SATURATION_QUICK,
    //                          WATER_EXCITATION
    //
    // Water suppression modes: WATER_SUPPRESSION_OFF
    //                          WATER_SATURATION
    //                          WATER_SATURATION_QUICK
    //                          FAT_EXCITATION
    
    rSeqLim.setFatSuppression   (SEQ::FAT_SUPPRESSION_OFF, SEQ::FAT_SATURATION);
    rSeqLim.setWaterSuppression (SEQ::WATER_SUPPRESSION_OFF);
    rSeqLim.setMTC              (SEQ::OFF, SEQ::ON);
    rSeqLim.setPSatMode         (SEQ::PSAT_NONE, SEQ::PSAT_SINGLE_REG, SEQ::PSAT_DOUBLE_REG);

    rSeqLim.setPSatThickness    ( 3.000, 150.000, 1.000, 50.000);
    rSeqLim.setPSatGapToSlice   ( 5.000,  50.000, 1.000, 10.000);

    rSeqLim.setRSats            (    0,        8,     1,      0);
    rSeqLim.setRSatThickness    (3.000,  150.000, 1.000, 50.000);


    // --------------------------------------------------------------------------------------------
    // Define physiological measurement parameter limmits
    // --------------------------------------------------------------------------------------------
    //
    // In this section, the trigger modes are defined and the number of phases in which each cycle
    // can be subdivided.

    rSeqLim.addPhysioMode (SEQ::SIGNAL_CARDIAC,     SEQ::METHOD_TRIGGERING);
    rSeqLim.addPhysioMode (SEQ::SIGNAL_RESPIRATION, SEQ::METHOD_TRIGGERING);

    rSeqLim.setPhases (1, K_NO_SLI_MAX, 1, 1);


    // --------------------------------------------------------------------------------------------
    // Define excitation parameter limits
    // --------------------------------------------------------------------------------------------

    rSeqLim.setFlipAngle (10.000, 90.000, 1.000, 15.000);
    rSeqLim.setExtSrfFilename ("%MEASDAT%/extrf.dat"); // folder for external RF pulses
    rSeqLim.setRFSpoiling (SEQ::ON);


    // --------------------------------------------------------------------------------------------
    // Define ADC parameter limits
    // --------------------------------------------------------------------------------------------

    rSeqLim.setBandWidthPerPixel (0, 80, 1560, 10, 390); // Hz
    rSeqLim.setReadoutOSFactor   (2.0); // maximum oversampling factor in readout direction


    // --------------------------------------------------------------------------------------------
    // Define reconstruction / interpolation parameter limits
    // --------------------------------------------------------------------------------------------
    //
    // Remark: Real part images can only be reconstructed if inversion is active.
    //
    // Reconstruction modes: RECONMODE_MAGNITUDE
    //                       RECONMODE_PHASE
    //                       RECONMODE_MAGN_PHASE
    //                       RECONMODE_REAL_PART
    //                       RECONMODE_REAL_PHASE

    rSeqLim.set2DInterpolation (SEQ::NO, SEQ::YES);
    rSeqLim.setReconstructionMode (
        SEQ::RECONMODE_MAGNITUDE,
        SEQ::RECONMODE_PHASE,
        SEQ::RECONMODE_MAGN_PHASE
    );


    // --------------------------------------------------------------------------------------------
    // Define database control parameter limits
    // --------------------------------------------------------------------------------------------
    //
    // The multiple series mode tells whether each measurement can be stored in a different
    // series.

    rSeqLim.setMultipleSeriesMode (
        SEQ::MULTIPLE_SERIES_OFF,
        SEQ::MULTIPLE_SERIES_EACH_MEASUREMENT,
        SEQ::MULTIPLE_SERIES_EACH_SLICE,
        SEQ::MULTIPLE_SERIES_EACH_SLICE_AND_MEASUREMENT
    );


    // --------------------------------------------------------------------------------------------
    // Define adjustment parameter limits
    // --------------------------------------------------------------------------------------------
    //
    // Adjustment shim modes: ADJSHIM_TUNEUP
    //                        ADJSHIM_STANDARD
    //                        ADJSHIM_ADVANCED (spectroscopy)

    rSeqLim.setAdjShim (SEQ::ADJSHIM_TUNEUP, SEQ::ADJSHIM_STANDARD);

#ifdef WIN32
    // This method has to be called when the SeqLim structure has been filled,
    // but before local solve handlers are defined.
    fStdImagingInitPost (rSeqLim);

    // Define default post-processing protocol (EVAProtocol)
    rSeqLim.setDefaultEVAProt (L"%SiemensEvaDefProt%\\Inline\\Inline.evp");
#endif

    // --------------------------------------------------------------------------------------------
    // Let FlashUI object add WIP parameters and define the UI behavior
    // --------------------------------------------------------------------------------------------

    NLS_STATUS lStatus = m_pFlashUI->registerUI (rSeqLim, m_WIPParamTool);
    if (!MrSucceeded (lStatus)) {
        UTRACE (Error, iUTraceMarker, "Registering UI failed! (Status: " << lStatus << ")");
        return lStatus;
    }

    return SEQU_NORMAL;
}



NLSStatus Flash::prepareExampleConflicts (MrProt& rMrProt, SeqLim& rSeqLim, SeqExpo& /*rSeqExpo*/)
{
    try {
        if (!m_WIPParamTool.prepare (rMrProt, rSeqLim)) return SEQU_ERROR;

        // --------------------------------------------------------------------------------------------
        // Example conflict (a):
        // --------------------------------------------------------------------------------------------

        if ((m_WIPParamTool.getLongValue (rMrProt, WIPLong) > 50) && (m_WIPParamTool.getDoubleValue (rMrProt, WIPDouble) > 1)) {
            return SEQU_ERROR;
        }


        // --------------------------------------------------------------------------------------------
        // Example conflict (b):
        // --------------------------------------------------------------------------------------------

        if ((m_WIPParamTool.getLongValue (rMrProt, WIPLong) > 50) && m_WIPParamTool.getSelectedItem (rMrProt, WIPSelection).isText (sOption1)) {
            return SEQU_ERROR;
        }


        // --------------------------------------------------------------------------------------------
        // Example conflict (c):
        // --------------------------------------------------------------------------------------------
        //
        // (TE is given in [us] in the protocol and in [ms] in the UI)

        long lTE = rMrProt.getProtData()->getalTE()[0];
        if (lTE >= (m_WIPParamTool.getLongValue (rMrProt, WIPMaxTE) * 1000)) {
            return SEQU_ERROR;
        }
    }

    // --------------------------------------------------------------------------------------------
    // Catch exceptions and translate them into standard error messages      
    // --------------------------------------------------------------------------------------------
    catch (std::logic_error& Exception) {
        UTRACE (Error, iUTraceMarker, Exception.what());
        return SEQU_ERROR;
    }
    
    catch (...) {
        UTRACE (Error, iUTraceMarker, "Unspecified error occured during preparation of the example conflicts!");
        return SEQU_ERROR;
    }

    return SEQU_NORMAL;
}



NLSStatus Flash::prepareKSpaceSampling (MrProt& rMrProt, SeqLim& rSeqLim, SeqExpo& rSeqExpo)
{
    NLSStatus lStatus = SEQU_NORMAL;

    try {
        NLSStatus lStatus = m_SamplingConfigurator.prepare (rMrProt, rSeqLim, rSeqExpo);
        if (lStatus.isError()) {
            return lStatus;
        }

        KSpaceSampling* pSampling = m_SamplingConfigurator.getSampling();
        if (pSampling == NULL) {
            THROW_MR_MSG (KSpaceException, "No sampling instance could be retrieved from sampling configurator!");
        }

        SamplingParams* pParams = m_SamplingConfigurator.getParams();
        if (pParams == NULL) {
            THROW_MR_MSG (KSpaceException, "No sampling parameters could be retrieved from sampling configurator!");
        }


        // Set sampling instance to be used for preparing FISPKernel
        m_FISPKernel.setSamplingInstance (pSampling);


        if (pSampling->isCalculated()) {
            m_lKSpacePointsToMeasure = pSampling->getSamplingInfo().m_iTotalNumberOfKSpacePoints;


            m_CheckSampling.setSampling (*m_SamplingConfigurator.getSampling());
            m_CheckSampling.setPreCheckLength (2);
            m_CheckSampling.setPostCheckLength (2);

            if (!m_CheckSampling.configureAndPrepare (*m_SamplingConfigurator.getParams())) {
                return SEQU_ERROR;
            }

            m_CheckSampling.calculate();
            m_lKSpacePointsToCheck = m_CheckSampling.getTotalNumberOfKSpacePoints();

        } else {
            m_lKSpacePointsToMeasure = 1;
            m_lKSpacePointsToCheck   = 1;
        }
    }

    // --------------------------------------------------------------------------------------------
    // Catch exceptions and translate them into standard error messages      
    // --------------------------------------------------------------------------------------------

    catch (KSpace::KSpaceException& Exception) {
        UTRACE (Error, iUTraceMarker, Exception.what());
        return SEQU_ERROR;
    }
    
    catch (...) {
        UTRACE (Error, iUTraceMarker, "Unspecified error occured during preparation of the k-space sampling trajectory!");
        return SEQU_ERROR;
    }

    return lStatus;
}



NLSStatus Flash::prepareCompositeSeqLoop (MrProt& rMrProt, SeqLim& rSeqLim, SeqExpo& rSeqExpo)
{
    try {
        using namespace SL;


        // --------------------------------------------------------------------------------------------
        // Initialize loop structure                                                 
        // --------------------------------------------------------------------------------------------

        m_SLM.init (rMrProt);


        // --------------------------------------------------------------------------------------------
        // Settings
        // --------------------------------------------------------------------------------------------

        m_SLM.regConst (SLK::b_PERF_OSC_BIT             , false                   );
        m_SLM.regConst (SLK::e_PERF_PREP_SCAN           , SL::NEVER               );

        m_SLM.regConst (FISPKernel::d_MIN_RISE_TIME     , m_dMinRiseTime          );
        m_SLM.regConst (FISPKernel::d_MAX_GRAD_AMPLITUDE, m_dGradMaxAmpl          );

        // A scan loop is required if a KSpaceSampling class is used
        m_SLM.regConst (SLK::e_K_SPACE_LOOP_CONTROL     , SL::SCAN                );
        m_SLM.regConst (SLK::l_SCAN_LOOP_LENGTH         , m_lKSpacePointsToMeasure);
        m_SLM.regConst (SLK::l_SCANS_TO_CHECK           , m_lKSpacePointsToCheck  );


        // A separate lines and partitions loop can be created by using the following code
        //
        // NOTE: Please be aware, that you will also need to make sure that the correct k-space
        //       positions are visited in sequence check. The according adaptions can be made in
        //       the FISPKernel class.
        // 
        // m_SLM.regConst (SLK::e_K_SPACE_LOOP_CONTROL     , SL::PAR_INSIDE_LIN      );
        // m_SLM.regConst (SLK::l_LINE_LOOP_LENGTH         , m_lLines                );
        // m_SLM.regConst (SLK::l_PARTITION_LOOP_LENGTH    , m_lPartitions           );
        // m_SLM.regConst (SLK::l_LINES_TO_CHECK           , 2L                      );
        // m_SLM.regConst (SLK::l_PARTITIONS_TO_CHECK      , 2L                      );


        // --------------------------------------------------------------------------------------------
        // Create loop structure                                                 
        // --------------------------------------------------------------------------------------------

        if (!m_SL.configure (rMrProt, rSeqLim)) {
            if (rSeqLim.isContextNormal()) {
                UTRACE (Error, iUTraceMarker, "Configuration of loop structure failed! m_SL.configure (...)");
            }
            return SBB_ERROR;
        }


        // --------------------------------------------------------------------------------------------
        // Add the kernel                                                        
        // --------------------------------------------------------------------------------------------

        m_SL.addChildAt (&m_FLASHKernel, "Kernel_MP");


        // --------------------------------------------------------------------------------------------
        // Prepare loop structure                                                
        // --------------------------------------------------------------------------------------------

        if (!m_SL.prep (rMrProt, rSeqLim, rSeqExpo)) {
            if (rSeqLim.isContextNormal()) {
                UTRACE (Error, iUTraceMarker, "Preparation of the loop structure failed! m_SL.prep (...)");
            }
            return SBB_ERROR;
        }

    }

    // --------------------------------------------------------------------------------------------
    // Catch exceptions and translate them into standard error messages      
    // --------------------------------------------------------------------------------------------
    catch (SL::GeneralException& Exception) {
        UTRACE (Error, iUTraceMarker, Exception.what());
        return Exception.getNLSStatus();
    }
    
    catch (...) {
        UTRACE (Error, iUTraceMarker, "Unspecified error occured during preparation of the loop structure!");
        return SBB_ERROR;
    }

    return SEQU_NORMAL;
}



NLSStatus Flash::prepare (MrProt &rMrProt, SeqLim &rSeqLim, SeqExpo &rSeqExpo)
{
    static const char *ptModule = {"Flash::prepare"};

    NLS_STATUS lStatus = SEQU_NORMAL;


    // --------------------------------------------------------------------------------------------
    // Set configuration for automatic exception logging
    // --------------------------------------------------------------------------------------------
    //
    // Remarks:
    // - This will apply only to exception classes that derive from MrException and that are thrown
    //   using the macro THROW_MR or THROW_MR_MSG.
    // - Logging the stack trace for a single exception will take around 20 ms!
    // - Therefore: Avoid raising exceptions, test all required conditions before calling a method.
    // - Consider to deactivate exception logging or stack trace logging.

    MrException::setLoggingExceptions (true);
    MrException::setLoggingStackTrace (true);

    
    // --------------------------------------------------------------------------------------------
    // Read sequence parameters from protocol
    // --------------------------------------------------------------------------------------------

    m_lSlicesToMeasure = rMrProt.sliceSeries().getlSize();
    SEQ::PartialFourierFactor PhasePFFactor = rMrProt.kSpace().phasePartialFourierFactor();


    // --------------------------------------------------------------------------------------------
    // Check example conflict conditions for the WIP parameters
    // --------------------------------------------------------------------------------------------

    lStatus = Flash::prepareExampleConflicts (rMrProt, rSeqLim, rSeqExpo);
    if (!MrSucceeded (lStatus)) {
        return lStatus;
    }


    // --------------------------------------------------------------------------------------------
    // Check other conflicts
    // --------------------------------------------------------------------------------------------

    // Combination of partial Fourier < 6/8 and RealPartImages is not allowed
    if (((PhasePFFactor == SEQ::PF_HALF) || (PhasePFFactor == SEQ::PF_5_8)) && rMrProt.calcRealPartImages()) {
        return SEQU_ERROR ;
    }


    // --------------------------------------------------------------------------------------------
    // Define gradient rise times and amplitudes
    // --------------------------------------------------------------------------------------------
    //
    // In the sequence check method, the Gradient Safety Watch Dog (GSWD) checks the sequence for
    // acoustic noise and nerve stimulation. However, calling the check method is time consuming.
    //
    // Therefore, it makes sense to add further restrictions on the gradient performance (beyond
    // the hardware limitations given by SysProperties).

    double dNewLimitGradMinRiseTime =  5.0;
    double dNewLimitGradMaxAmpl     = 28.0;

    m_dMinRiseTime = std::max <double> (dNewLimitGradMinRiseTime, SysProperties::getGradMinRiseTime (rMrProt.gradSpec().mode()));
    m_dGradMaxAmpl = std::min <double> (dNewLimitGradMaxAmpl, 0.8 * SysProperties::getGradMaxAmpl (rMrProt.gradSpec().mode()));


    // Explanation of the GSWD mode:
    //
    // If the GSWD complains about stimulation, the gradient rise time will be increased
    // iteratively until no stimulation occurs anymore. For this iterative adjustment,
    // the sequence has to use the minimum rise time which is determined by the GSWD.
    //
    // The SBBs are treated by calling the method setGSWDGradientPerformance. However, the
    // gradients which are played out directly by the sequence also need to be restricted.
    // Therefore, the value for m_dMinRiseTime must be updated here.

    if (rMrProt.gradSpec().isGSWDMode()) {
        m_dMinRiseTime = rMrProt.gradSpec().GSWDMinRiseTime();
    }


    // --------------------------------------------------------------------------------------------
    // Prepare KSpaceSampling
    // --------------------------------------------------------------------------------------------
    
    lStatus = prepareKSpaceSampling (rMrProt, rSeqLim, rSeqExpo);
    if (!MrSucceeded (lStatus)) {
        return lStatus;
    }


    // --------------------------------------------------------------------------------------------
    // Prepare CompositeSeqLoop
    // --------------------------------------------------------------------------------------------
    
    lStatus = prepareCompositeSeqLoop (rMrProt, rSeqLim, rSeqExpo);
    if (!MrSucceeded (lStatus)) {
        return lStatus;
    }


    // --------------------------------------------------------------------------------------------
    // Set receiver gain: For thin slices use high receiver gain
    // --------------------------------------------------------------------------------------------
    
    long lRxGainCode = K_RX_GAIN_CODE_LOW;
    if (rMrProt.sliceSeries().aFront().thickness() <= 10.0) { // unit is mm
        lRxGainCode = K_RX_GAIN_CODE_HIGH;
    }

    lStatus = fSSLSetRxGain (lRxGainCode, rMrProt, rSeqLim);
    if (!MrSucceeded (lStatus)) {
        UTRACE (Error, iUTraceMarker, "Setting the receiver gain (fSSLSetRxGain) failed! Status: " << lStatus);
        return lStatus;
    }


    // --------------------------------------------------------------------------------------------
    // Calculate rotation matrices and positions for slices
    // --------------------------------------------------------------------------------------------
    //
    // fSUPrepSlicePosArray sets the index in the asSLC array (and other parameters) according to
    // the setting of the SliceSeriesMode

    lStatus = fSUPrepSlicePosArray (rMrProt, rSeqLim, m_asSLC);
    if (!MrSucceeded (lStatus)) {
        UTRACE (Error, iUTraceMarker, "Preparing the slice position array (fSUPrepSlicePosArray) failed! Status: " << lStatus);
        return lStatus;
    }
    

    // --------------------------------------------------------------------------------------------
    // Export information to the sequence export object
    // --------------------------------------------------------------------------------------------
    //
    // Remark: The export object will be read for example by the ICE program

    fSUSetSequenceString ("fl", rMrProt, rSeqExpo);
    rSeqExpo.setPreScans (0); // No preparation scans


    // --------------------------------------------------------------------------------------------
    // Settings for phase correction (PC) for phase images
    // --------------------------------------------------------------------------------------------
    //
    // - Set phase correction algorithm:
    // - Phase+Magn: Submatrix
    // - Phase+Real: extra phase correction scan

    rSeqExpo.setNoOfPhaseCorrLines   ( 16 * rMrProt.kSpace().getlBaseResolution() / 256);
    rSeqExpo.setLinSlopeLength       ( 16 * rMrProt.kSpace().getlBaseResolution() / 256);
    rSeqExpo.setNoOfPhaseCorrColumns (128 * rMrProt.kSpace().getlBaseResolution() / 256);
    rSeqExpo.setColSlopeLength       (128 * rMrProt.kSpace().getlBaseResolution() / 256);

    if ((PhasePFFactor == SEQ::PF_HALF) || (PhasePFFactor == SEQ::PF_5_8)) {
        rSeqExpo.setPCAlgorithm (SEQ::PC_ALGORITHM_MARGOSIAN);
    } else {
        if (rMrProt.calcPhaseImages() || (rMrProt.kSpace().phasePartialFourierFactor() != SEQ::PF_OFF)) {
            rSeqExpo.setPCAlgorithm (SEQ::PC_ALGORITHM_SUBMATRIX);
        } else {
            rSeqExpo.setPCAlgorithm (SEQ::PC_ALGORITHM_NONE);
        }
    }


    // --------------------------------------------------------------------------------------------
    // Set echo train length (-> used to set corresponding DICOM attributes) 
    // --------------------------------------------------------------------------------------------

    rSeqExpo.setEchoTrainLength         (rMrProt.contrasts());
    rSeqExpo.setGradientEchoTrainLength (static_cast <uint16_t> (rMrProt.contrasts()));
    rSeqExpo.setRFEchoTrainLength       (0);


    // --------------------------------------------------------------------------------------------
    // Set ICE program parameters
    // --------------------------------------------------------------------------------------------
    //
    // NOTE: In this demo sequence the data rate is not checked! Therefore, a data overflow can
    //       potentially occur!
    //
    // The flag SEQ::SO_SHOW_YES activates the cross displayed in front of the measurement time.

    bool bOnlineReconstruction = m_WIPParamTool.getBoolValue (rMrProt, WIPOnlineRecon);

    rSeqExpo.setICEProgramFilename ("%SiemensIceProgs%\\IceProgramStandard");

    if (bOnlineReconstruction) {
        rSeqExpo.setOnlineFFT          (SEQ::ONLINE_FFT_PHASE);
        rSeqExpo.setICEProgramParam    (ICE_PROGRAM_PARA_SHOW_OFFLINE, SEQ::SO_SHOW_NO);
    } else {
        rSeqExpo.setOnlineFFT          (SEQ::ONLINE_FFT_NONE); // default: no online FFTs except ROFT
        rSeqExpo.setICEProgramParam    (ICE_PROGRAM_PARA_SHOW_OFFLINE, SEQ::SO_SHOW_YES);
    }


    // Export the maximum number of slices per concatenation. The ICE program requires this information
    // to allocate sufficient memory. For sequential excitation, this value should be 1.
    rSeqExpo.setSlicePerConcat (1);


    // Tell the UI to show the Application Card
    rSeqExpo.setApplicationCard  (SEQ::APPLICATION_CARD_INLINE);


    return lStatus;
}



NLSStatus Flash::check (MrProt  &rMrProt, SeqLim &rSeqLim, SeqExpo &rSeqExpo, SEQCheckMode*)
{
    UTRACE (Debug, iUTraceMarker, "Sequence check <" << rSeqLim.getLinkedSeqFilename() << "> started");


    // Set sampling instance to be used
    m_FISPKernel.setSamplingInstance (&m_CheckSampling);


    // --------------------------------------------------------------------------------------------
    // Execute the composite seqloop in check mode
    // --------------------------------------------------------------------------------------------
    try {
        if (!m_SL.check (rMrProt, rSeqLim, rSeqExpo, m_asSLC))  {
            if (pSeqLim->isContextNormal()) {
                UTRACE (Error, iUTraceMarker, "Check of the loop structure (m_SL.check(...)) failed!");
            }
            return SBB_ERROR;
        }
    }

    // --------------------------------------------------------------------------------------------
    // Catch exceptions and translate them into standard error messages      
    // --------------------------------------------------------------------------------------------
    catch (SL::GeneralException& Exception) {
        UTRACE (Error, iUTraceMarker, Exception.what());
        return Exception.getNLSStatus();
    }

    catch (...) {
        UTRACE (Error, iUTraceMarker, "Unspecified error occured during check of the loop structure!");
        return SBB_ERROR;
    }


    UTRACE (Debug, iUTraceMarker, "Sequence check <" << rSeqLim.getLinkedSeqFilename() << "> finished");

    return SEQU_NORMAL;
}



NLSStatus Flash::run (MrProt& rMrProt, SeqLim& rSeqLim, SeqExpo& rSeqExpo)
{
    UTRACE (Debug, iUTraceMarker, "Sequence run <" << rSeqLim.getLinkedSeqFilename() << "> started");


    // Set sampling instance to be used
    m_FISPKernel.setSamplingInstance (m_SamplingConfigurator.getSampling());


    // --------------------------------------------------------------------------------------------
    // Initialization of the unit test function
    // --------------------------------------------------------------------------------------------
    if (IS_UNIT_TEST_ACTIVE (rSeqLim)) {

        // The sequence unit test checks the sequence run for correct timing, orientation, phase
        // offsets, etc.
        //
        // The unit test must be a completely unbiased observer. Therefore, information must be
        // passed to the unit test independently from the actual gradient or timing events.
        //
        // The following macro fulfills exactly this task.

        mSEQTest (rMrProt, rSeqLim, rSeqExpo, RTEB_ORIGIN_fSEQRunStart, 0, 0, 0, 0, 0); /*! EGA-All !*/
    }


    // --------------------------------------------------------------------------------------------
    // Execute the composite seqloop
    // --------------------------------------------------------------------------------------------
    try {
        if (!m_SL.run (rMrProt, rSeqLim, rSeqExpo, m_asSLC)) {
            UTRACE (Error, iUTraceMarker, "Execution of the loop structure (m_SL.run(...)) failed!");
            return SBB_ERROR;
        }
    }

    // --------------------------------------------------------------------------------------------
    // Catch exceptions and translate them into standard error messages      
    // --------------------------------------------------------------------------------------------
    catch (SL::GeneralException& Exception) {
        UTRACE (Error, iUTraceMarker, Exception.what());
        return Exception.getNLSStatus();
    }

    catch (...) {
        UTRACE (Error, iUTraceMarker, "Unspecified error occured during execution of the loop structure!");
        return SBB_ERROR;
    }


    // --------------------------------------------------------------------------------------------
    // Tell sequence unit test that sequence run is finished.
    // --------------------------------------------------------------------------------------------
    if (IS_UNIT_TEST_ACTIVE (rSeqLim)) {
        mSEQTest (rMrProt, rSeqLim, rSeqExpo, RTEB_ORIGIN_fSEQRunFinish, 0, 0, 0, 0, 0); /*! EGA-All !*/
    }


    UTRACE (Debug, iUTraceMarker, "Sequence run <" << rSeqLim.getLinkedSeqFilename() << "> finished");

    return SEQU_NORMAL;
}

// --------------------------------------------------------------------------------------------
//    Copyright (C) Siemens AG 2010  All Rights Reserved. Confidential.
// --------------------------------------------------------------------------------------------
