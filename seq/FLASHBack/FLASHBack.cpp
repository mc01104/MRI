//    -----------------------------------------------------------------------------
//      Copyright (C) Siemens AG 1998  All Rights Reserved.
//    -----------------------------------------------------------------------------
//
//     Project: NUMARIS/4
//        File: \n4\pkg\MrServers\MrImaging\seq\FLASHBack\FLASHBack.cpp
//     Version: \main\4c11a_er\17
//      Author: Clinical
//        Date: 2011-09-29 08:13:29 +02:00
//
//        Lang: C++
//
//     Remarks: This is the demo sequence FLASHBack.
//              DO NOT base any diagnosis on images generated by this sequence.
//
//
//  EGA Requirement Key: As shown on the following lines:
//
//   Abbrev.   Translation                                         Relevant for
//   -------   -----------                                         ------------
//   EGA-All   All of the following keys:                          All EGA requirements
//   EGA-Any   All or any of the following keys:                   All EGA requirements
//   EGA-01    {:IMPLEMENT:000_EGA_BildOri_SW_SequenzROVz::}       GR/GP   polarity
//   EGA-02    {:IMPLEMENT:000_EGA_BildPos_SW_SequenzSSelVz::}     GS      polarity
//   EGA-03    {:IMPLEMENT:000_EGA_BildMass_SW_SequenzROPC::}      GR/GP   amplitude
//   EGA-04    {:IMPLEMENT:000_EGA_BildPos_SW_SequenzSSel::}       GS      amplitude
//   EGA-05    {:IMPLEMENT:000_EGA_BildPos_SW_NCOFrequenzSSel::}   SRF     frequency
//   EGA-06    {:IMPLEMENT:000_EGA_BildPos_SW_NCOFrequenzRO::}     Readout frequency
//   EGA-07    {:IMPLEMENT:000_EGA_BildOri_SW_OrientierungTest::}  Image orientation
//
//
//
//
/// \file   FlASH.cpp
/// \brief  File containing source code for the sequences
///         - FlashBack
///
/// This file contains the implementation of the class FlashBack.
/// The sequence FlashBack and Flash1 use it to generate very nice images.
///
//  **************************************************************************



// ------------------------------------------------------------------------------
// Application includes
// ------------------------------------------------------------------------------
#include "MrServers/MrImaging/seq/FLASHBack/FLASHBack.h"
#include "MrServers/MrImaging/seq/FLASHBack/FLASHBack_UI.h"

// ------------------------------------------------------------------------------
// General includes
// ------------------------------------------------------------------------------
#include "MrServers/MrImaging/libSeqUtil/libSeqUtil.h"
#include "MrServers/MrMeasSrv/MeasNuclei/IF/MeasKnownNuclei.h"
#include "MrServers/MrProtSrv/MrProt/MeasParameter/MrSysSpec.h"
#include "MrServers/MrProtSrv/MrProt/MeasParameter/MrRXSpec.h"



// Error handling routines.
// Many functions return a NLS_STATUS (NLS = Native Language Support).
// This code is used to produce error messages in different languages.
// With this method it is possible to display sensible error messages in the user interface,
//  if the error code is passed correctly to the caller function
// In most cases, one checks whether the highest two bits of the return status are set.
// In the sequence, the use of SEQU__NORMAL as return value is used to signal ok.
//
#define OnErrorReturn(S) if(!MrSucceeded(S)) return(S)

#define OnErrorPrintAndReturn(S,P) if (!MrSucceeded(S)) \
    { MRTRACE("Error from %s \n",P); return(S);}


//  --------------------------------------------------------------------------
//
//  Name        :  SEQIF_DEFINE
//
//  Description :
///  \brief        Create instance of the sequence
//
//  Return      :  SeqIF *
//
//  --------------------------------------------------------------------------


#ifndef SEQ_NAMESPACE
    #error SEQ_NAMESPACE not defined
#endif


#ifdef SEQUENCE_CLASS_FLASHBack
    SEQIF_DEFINE (SEQ_NAMESPACE::FlashBack)
#endif


using namespace SEQ_NAMESPACE;




// An elegant way to switch debug messages on and off without recompiling the sequence can be
//   done by entering the debug mask in the windows registry, e.g. into
//    \\HKEY_LOCAL_MACHINE\\SOFTWARE\\Siemens\\Numaris4\\Config\\Modality\\Sequence\\DEBUG_USER_SEQUENCE
//    (this registry entry has to be defined by yourself.)
// The numerical value can be set by the programs configui (on the Scanner) or regedit (stand-alone PC),
//  so one can select the desired piece of debugging information by setting the correspondig bits

//   Then the following Macro can be used:
#define DEBUG_BY_REGISTRY(A, B){if (lDebugMask & A){std::cout  << __FILE__ << ": " << B << std::endl;}}
//   This macro allows the copntrolled output of bebug information, depending of the settings in
//    the DEBUG_USER_SEQUENCE-registry entry. Example:
//-  DEBUG_BY_REGISTRY(16," This is my debug text with TR: " << pMrProt->tr()[0] )
//    will dump "FLASHBack.cpp:  This is my debug text with TR: 1000" to the standard output, if
//    the bit 5 in the registry-key is set.

// NOTE: Setting the corresonding registry entry will cause ALL of your sequences using this key for debugging
//      to generate verbose output, which may decrease performance. So be aware of this global effect.

#define TRUE_IF_DETAILED_DEBUG ( lDebugMask > 63 )
long lDebugMask = getMaskFromRegistry ("DEBUG_USER_SEQUENCE") ; // read the debug value in a global
    //  variable, since function call is slow


FlashBack::FlashBack()
  : m_lRepetitionsToMeasure                       (0)
    , m_lLinesToMeasure                             (1)
    , m_lPhasesToMeasure                            (1)
    , m_lSlicesToMeasure                            (1)
    , m_lPartitionsToMeasure                        (1)
    , m_lScanTimeAllSats                            (0)
    , m_lDurationMainEventBlock                     (0)
    , m_lKernelRequestsPerMeasurement               (0)
    , m_lKernelCallsPerRelevantSignal               (0)
    , m_lInterDuration                              (0)
    , m_lTrigHaltDuration1                          (0)
    , m_lTrigHaltDuration2                          (0)
    , m_dRFSpoilIncrement                           (0)
    , m_dRFSpoilPhase                               (0)
    , m_lMySliSelRampTime                           (0)
    , m_dMinRiseTime                                (100000)
    , m_dGradMaxAmpl                                (0)

    , m_FirstSignal                                 (SEQ::SIGNAL_NONE)
    , m_FirstMethod                                 (SEQ::METHOD_NONE)
    , m_SecondSignal                                (SEQ::SIGNAL_NONE)
    , m_SecondMethod                                (SEQ::METHOD_NONE)

    , m_dRFSpoilPhasePrevSlice                      (0.0)
    , m_dRFSpoilIncrementPrevSlice                  (0.0)
    , m_dRFPrevSlicePosSag                          (999999.0)
    , m_dRFPrevSlicePosCor                          (999999.0)
    , m_dRFPrevSlicePosTra                          (999999.0)
    , m_dRFPrevSliceNormalSag                       (999999.0)
    , m_dRFPrevSliceNormalCor                       (999999.0)
    , m_dRFPrevSliceNormalTra                       (999999.0)

    , m_sSRF01                                      ("fl_Flash_ex")
    , m_sSRF01zSet                                  ("sSRF01zSet")
    , m_sSRF01zNeg                                  ("sSRF01zNeg")

    , m_sGSliSel                                    ("sGSliSel")         // Slice-select pulse
    , m_sGReadDeph                                  ("sGReadDeph")
    , m_sGSliSelReph                                ("sGSliSelReph") // Slice-select rephaser pulse
    , m_sGradReadout                                ("sGradReadout")

    , m_sGPhasTab                                  (RTEIDENT_TabKy) // phase encode
    , m_sGPhasTabRew                               (RTEIDENT_TabKy)// phase encode rewinder
    , m_sG3DTab                                    (RTEIDENT_TabKz)// partition encode
    , m_sG3DTabRew                                 (RTEIDENT_TabKz)// partition rewind

    , m_sADC01                                     ("sADC01")
    , m_sADC01zSet                                 ("sADC01zSet")
    , m_sADC01zNeg                                 ("sADC01zNeg")


    , m_TokTokSBB                                  (&m_mySBBList)
    , m_CSatFatSBB                                 (&m_mySBBList)
    , m_CSatWatSBB                                 (&m_mySBBList)
    , m_MSatSBB                                    (&m_mySBBList)
    , m_TSatSBB                                    (&m_mySBBList)
    , m_SpoilSBB                                   (&m_mySBBList)
    , m_pUI                                        (NULL) {
    // no further instructions...
}






FlashBack::~FlashBack()
{
    // Delete UI instance if an UI instance exists
    if (NULL != m_pUI) {
        delete m_pUI;
        m_pUI = NULL;
    }

}












//   --------------------------------------------------------------------------
//
//   Name        :  FlashBack::initialize
//
//   Description :
///  \brief        Initialization of the sequence
///
///                On the host, the object m_pUI will actually contain sensible
///                  data after FlashBack::initialize. On the measurement system, it
///                  is basically an empty object behind it.
///
//   Return      :  NLS status
//
//   --------------------------------------------------------------------------
NLSStatus FlashBack::initialize (SeqLim &rSeqLim)
{

    static const char *ptModule = {"FlashBack::initialize"};

    NLS_STATUS  lStatus = SEQU__NORMAL;




    //   ----------------------------------------------------------------------
    //
    //   Definition of sequence hard limits
    //
    //   ----------------------------------------------------------------------

    // ...
    double        dMin, dMax, dInc, dDef;
    long        lMin, lMax, lInc, lDef;
    long        lI;

        // if the mask is set to INIT and CALL, print some text
    PRINT_TRACE0 (rSeqLim, DEBUG_INIT, DEBUG_CALL,
                "() >>>> Welcome to the FLASHBack demo sequence  (Build: "__DATE__"   "__TIME__")") ;
        // If DEBUG_INIT is set, dump information that fSEQInit has been called
    if ( rSeqLim.getSeqDebugMode().getDebugMask()& DEBUG_INIT ) PRINT_DEBUGMASK(rSeqLim)

    dMin = dMax = dInc = dDef = 0.;
    lMin = lMax = lInc = lDef = 0;


    //. --------------------------------------------------------
    //. Add RSat to the SBB List
    //. --------------------------------------------------------
    for (lI=0; lI<MAXRSATS; lI++)
    {
        m_RSatSBB[lI].addToSBBList (&m_mySBBList);
    }




    //. --------------------------------------------------------
    //. Give general information about the sequence
    //. --------------------------------------------------------

        // let me introduce myself...
    rSeqLim.setMyOrigFilename ( __FILE__ );
    rSeqLim.setSequenceOwner    ( "USER" );
        // The sequence hint text is available via the "imprint name.dll" command
    rSeqLim.setSequenceHintText( (char *) "\n\
    Application: FlashBack sequence for demonstration purpose     \n\
               Uses explicit loop structures \n\
                                                     \n\
        Build: "__DATE__"   "__TIME__"\n")  ;


    //. -----------------------------------------------------------------------------
    //. Define the system requirements like frequency and gradient power
    //. -----------------------------------------------------------------------------
    rSeqLim.setAllowedFrequency     (8000000, 500000000); // Hz
    rSeqLim.setRequiredGradAmpl     (10.0); //  mT/m
    rSeqLim.setRequiredGradSlewRate (10.0); // (mT/m)/ms
        // Which gradient modes are allowed in the user interface?
        //  The _GSWD_RISETIME modes will allow a search over the rise times to avoid stimulation.
    rSeqLim.setGradients(SEQ::GRAD_FAST, SEQ::GRAD_NORMAL, SEQ::GRAD_WHISPER,
                            SEQ::GRAD_FAST_GSWD_RISETIME, SEQ::GRAD_NORMAL_GSWD_RISETIME,
                            SEQ::GRAD_WHISPER_GSWD_RISETIME);

    //  On which nuclei may the sequence run?
    //   NUCLEI_ALL, NUCLEUS_1H, NUCLEUS_31P ...
    //  This requires the library MeasNucleiIF in the makefiles.
    //  Besides this change, you may have to adapt some default parameters, so
    //   that the default protocol can succesfully prepare.
    //  For example: Change the default bandwidth to 130 (instead of 390)
    //   and increase the values for lPEDuration and lPERampTime (in fSEQPrep)
    rSeqLim.setSupportedNuclei(NUCLEI_ALL.get().c_str());

    //. -----------------------------
    //. Specify base matrix size of the image
    //. -----------------------------
                          //-  (min, max,        mult, def) alternatives: BASE2, INC_64
    rSeqLim.setBaseResolution ( 64, 512, SEQ::INC_64, 256);


    //. -----------------------------------------------------------------------------
    //. Specify phase encoding parameters
    //. -----------------------------------------------------------------------------
        // partial Fourier
        // The order of the arguments decides about the order in the user interface,
        //   the first one is the default
        // These choices/defines can be found in comp\MrServers/MrProtSrv/MrProt/SeqDefines.h
    rSeqLim.setPhasePartialFourierFactor (SEQ::PF_OFF, SEQ::PF_7_8, SEQ::PF_6_8, SEQ::PF_5_8, SEQ::PF_HALF);

        // set factor for phase oversampling: Min/Max/Inc/Default
    rSeqLim.setPhaseOversampling         (0.0,   1.0,   0.01,   0.0);

        // set number of phase encoding lines: Min/Max/Inc/Default
        // Default is the default value of the BaseResolution
    rSeqLim.setPELines                   (32, 1024, 1, rSeqLim.getBaseResolution().getDef());


    //. --------------------------------------------------------------------------
    //. Set the hard limits for Field of View
    //. --------------------------------------------------------------------------

    dMax = SysProperties::getFoVMax() ;  // maximum FoV depends on gradient linearity
    dDef = 300.0;                    // default FOV is 300 mm
    dInc =   1.0;                    // allowed stepsize is 1 mm
    dMin =    20;                     // minimum FoV is limited by the gradient performance.
                                     //  Its minimal value is found by binary search, so
                                     //  here any small number will do.

        // For different rounding methods there are predefined functions in
        //  comp/Mesaurement/MeasUtils/MeasMath.h available.
        //  e.g., fSDSdRoundUpMinimum lifts the minimum value to that an interger multiple
        //    of dInc fits into (dMax-dMin)
    dMin = fSDSdRoundUpMinimum(dMin, dMax, dInc);
    if (dDef < dMin) dDef = dMin;
    if (dDef > dMax) dDef = dMax;

        // Now set the limits
    rSeqLim.setReadoutFOV                ( dMin, dMax, dInc, dDef );
    rSeqLim.setPhaseFOV                  ( dMin, dMax, dInc, dDef );


    //. --------------------------------------------------------------------------
    //. Set TE / TR hard limits
    //. --------------------------------------------------------------------------
        // Set the allowed range for TR
        // If the default value cannot be realized by the sequence,
        //  it will choose the smallest possible one via a binary search
    rSeqLim.setTR                        (0,  100, 5000000, 100, 1000)  ;

        // Set number of desired contrasts and their corresponding TE time
        //-                    (Min,Max,Inc,Def)
    rSeqLim.setContrasts      (  1,  1,  0,  1) ;
        // Set limits/increment/default for Echo Time TE
        //  If the default value cannot be realized by the sequence,
        //  it will choose (the smallest possible) one via a binary search
        //-                    ( Contrast number,     min,      max,      inc,   default) ;
    rSeqLim.setTE             (               0,     100,   100000,      100,      1000) ;

    //. -------------------------------
    //. Set TI limits
    //. -------------------------------
    rSeqLim.setInversion (SEQ::INVERSION_OFF); // No inversion
                                                // Alternatives: SLICE_SELECTIVE, VOLUME_SELECTIVE

    rSeqLim.setSTIRMode  (SEQ::OFF);           // Alt: SEQ::ON
    lMin = 8000 ;
    lMin    = fSDSRoundToInc (lMin,1000);
    lDef    = (lMin <= 150000) ? 150000 : lMin;
        //-                    (TI number,     min,      max,      inc,   default) ;
    rSeqLim.setTI             (        0,    lMin,  2000000,     1000,      lDef) ;


    //. --------------------------------------------------------------------------------------
    //. Define limits for slices, excitation order etc.
    //. --------------------------------------------------------------------------------------
                                 //- (        min,          max,         inc,         def)  ;
    rSeqLim.setConcatenations       (           1,           1,           1,           1)  ;
    rSeqLim.setSlices               (           1,K_NO_SLI_MAX,           1,           1)  ;
    rSeqLim.setSliceThickness       (       2.000,      10.000,       0.500,       5.000)  ;
    rSeqLim.setSliceDistanceFactor  (       0.000,       8.000,       0.010,       0.200)  ;

            // We have no slice reordering implemented in this sequence, and we use
            //  the lines loop inside the slices loop, therefore it is SEQUENTIAL
            // Remember: MSM_INTERLEAVED is not INTERLEAVED.
            //  (MSM_INTERLEAVED means slice loop inside line loop)
    rSeqLim.setMultiSliceMode  (SEQ::MSM_SEQUENTIAL); //-  MSM_SINGLESHOT,   SEQ::MSM_INTERLEAVED

            // The excitation order inside a slice group is calculated within the UI (fSUPrepSlicePosArray) and
            //   therefore the actual spatial position of asSLC[0] depends on the SliceSeriesMode
    rSeqLim.setSliceSeriesMode ( SEQ::ASCENDING, SEQ::INTERLEAVED, SEQ::DESCENDING);
    rSeqLim.enableSliceShift ();   // we allow offcenter slice position
    rSeqLim.enableMSMA ();         // we allow MSMA
    rSeqLim.enableOffcenter ();    // we allow an offcenter position of the slab
                                    // we allow double oblique slices
    rSeqLim.setAllowedSliceOrientation (SEQ::DOUBLE_OBLIQUE); // alt: ORTHOGONAL, SINGLE_OBLIQUE

            // choice of averaging mode
    rSeqLim.setAveragingMode               (SEQ::INNER_LOOP, SEQ::OUTER_LOOP);


    //. --------------------------------------------------------------------------------------
    //. Define 3D-properties
    //. --------------------------------------------------------------------------------------

        // This is a sequence for 2D and 3D measurements
    rSeqLim.setDimension (SEQ::DIM_2, SEQ::DIM_3) ;

        // These are 3D-parameters:
    rSeqLim.setPartition            (           8,         256,           2,          32);
    rSeqLim.setImagesPerSlab        (           8,         512,           2,          32);
    rSeqLim.setSlabThickness        (       5.000,     160.000                          );
    rSeqLim.set3DPartThickness      (       0.100,         5.000,         0.01,
                   rSeqLim.getSlabThickness().getMax()/ rSeqLim.getPartition().getDef());
    rSeqLim.setSliceOversampling    (       0.000,       1.000,       0.010,       0.000);
        // Minimum fraction of actually measured slices
    rSeqLim.setMinSliceResolution   ( 0.5 );


    //. --------------------------------------------------------------------------------------
    //. Configure user interface: Hide some switches
    //. --------------------------------------------------------------------------------------

        // Hide the elliptical scanning switch
    rSeqLim.getEllipticalScanning       ().setDisplayMode (SEQ::DM_OFF);
        // Hide asymetric echo switch
    rSeqLim.getAsymmetricEcho           ().setDisplayMode (SEQ::DM_OFF);
        // Hide EPI-factor
    rSeqLim.getEPIFactor                ().setDisplayMode (SEQ::DM_OFF);
        // Hide Inversion
    rSeqLim.getInversion                ().setDisplayMode (SEQ::DM_OFF);


    //. --------------------------------------------------------------------------------------
    //. Set Limits for Loop control counters
    //. --------------------------------------------------------------------------------------

        // note that 511 repetitions are 512 measurements
    rSeqLim.setRepetitions                  (        0,      511,        1,        0)  ;
    rSeqLim.setAverages                     (        1,       32,        1,        1)  ;


        // Set Limits for delays in Loops
    lInc = 100000;
    lMax = 2000000000;
    rSeqLim.setRepetitionsDelayTime         (        0,     lMax,     lInc,        0)  ;
    rSeqLim.setTD                 (        0,        0, 30000000,     1000,        0)  ;

        // Patient information: Gradient TokTokTok at Measurement start
    rSeqLim.setIntro                       (SEQ::OFF, SEQ::ON);


      //. --------------------------------------------------------------------------------------
    //. Configure preparation pulses
    //. --------------------------------------------------------------------------------------

        // Set the min/max number of Regional Sats
    rSeqLim.setRSats                        (         0,MAXRSATS,        1,        0)  ;
        // Set mix/max Regional Sat Thickness
    rSeqLim.setRSatThickness                (     3.000, 150.000,    1.000,   50.000)  ;
    {
            // Set regional sat identifying names, must be unique
            // naming convention: Sequence identifier + number.
            // maximum of 6 chars are used for intentification!
        char    ptIdentdummy[7] ;
        int lI ;
        for (lI = 0; lI < MAXRSATS; lI++)
        {
            sprintf(ptIdentdummy, "FL%1d", lI+1);
            m_RSatSBB[lI].setIdent(ptIdentdummy);
        }
    }


        // Parallel Sats
        // Parallel sats are internally RSats, although they appear in the user interface
        //  as "Special Sats" along with the travelling = tracking sats
    rSeqLim.setPSatMode       ( SEQ::PSAT_NONE, SEQ::PSAT_SINGLE_REG, SEQ::PSAT_DOUBLE_REG)  ;
    rSeqLim.setPSatThickness                (     3.000, 150.000,    1.000,   50.000)  ;
    rSeqLim.setPSatGapToSlice               (     5.000,  50.000,    1.000,   10.000)  ;

        // Fat/Water Sats
    rSeqLim.setFatSuppression               (SEQ::FAT_SUPPRESSION_OFF, SEQ::FAT_SATURATION); // alt: FAT_SATURATION_QUICK, SEQ::WATER_EXCITATION
    rSeqLim.setWaterSuppression             (SEQ::WATER_SUPPRESSION_OFF); // alt: WATER_SATURATION,FAT_EXCITATION,WATER_SATURATION_QUICK );
    m_CSatFatSBB.setIdent("FLFS");
    m_CSatWatSBB.setIdent("FLWS");

        // (dis)allow use of Magnetization transfer contrast
        // default: SEQ:OFF
    rSeqLim.setMTC                          (SEQ::OFF, SEQ::ON);
    m_MSatSBB.setIdent("FLMS");

        // (dis)allow use of Dark Blood preparation pulse
        //- pSeqLim->setDarkBlood                    (SEQ::DB_OFF) ;

        // Travelling Sats
    rSeqLim.setTSats                        (         0,       1,        1,        0);
    rSeqLim.setTSatThickness                (     3.000, 150.000,    1.000,   40.000);
    rSeqLim.setTSatGapToSlice               (     0.000,  50.000,    1.000,   10.000);
    m_TSatSBB.setIdent ( "FLTS" );


    //. --------------------------------------------------------------------------------------
    //. Define possibilities for physiologic measurements
    //. --------------------------------------------------------------------------------------

        // which trigger modes are allowed
    rSeqLim.addPhysioMode (SEQ::SIGNAL_CARDIAC,     SEQ::METHOD_TRIGGERING);
    rSeqLim.addPhysioMode (SEQ::SIGNAL_RESPIRATION, SEQ::METHOD_TRIGGERING);
    // pSeqLim->addPhysioMode (SEQ::SIGNAL_RESPIRATION, SEQ::METHOD_TRIGGERING, SEQ::SIGNAL_CARDIAC, SEQ::METHOD_TRIGGERING);
        // set number of phases to be measured
    rSeqLim.setPhases     ( 1, K_NO_SLI_MAX, 1, 1 );    // is the default

    //. --------------------------------------------------------------------------------------
    //. Define properties of excitation
    //. --------------------------------------------------------------------------------------
    rSeqLim.setFlipAngle                        (   10.000,  90.000,    1.000,   15.000)  ;
        // where do I find external RF pulses
    rSeqLim.setExtSrfFilename ("%MEASDAT%/extrf.dat");

    rSeqLim.setRFSpoiling (SEQ::ON) ; // this is a flash sequence, so RFSpoiling should be on.
                        // in this case, the switch is not hidden, so the user can
                        // see that it is a flash sequence



    //. --------------------------------------------------------------------------------
    //. Set ADC properties
    //. --------------------------------------------------------------------------------

        //- Limits ADC bandwidth (Hz/pixel)( No.,      min,      max,      inc,      def);
    rSeqLim.setBandWidthPerPixel        (    0,        80,     1560,       10,      390);
        // How much is oversampled in Readout direction
    rSeqLim.setReadoutOSFactor(2.0) ;


    //. -----------------------------------------------------------------------------
    //. Configure Reconstruction / Interpolation
    //. -----------------------------------------------------------------------------

        // We allow in-slice interpolation, but default is off.
    rSeqLim.set2DInterpolation (SEQ::NO, SEQ::YES);
    rSeqLim.setReconstructionMode (SEQ::RECONMODE_MAGNITUDE, SEQ::RECONMODE_PHASE, SEQ::RECONMODE_MAGN_PHASE);
            // note: real part images are only allowed with Inversion
                //alt:        SEQ::RECONMODE_REAL_PART, SEQ::RECONMODE_REAL_PHASE

        // this check box is only available on the flow card
    //- pSeqLim->setPhaseImages (SEQ::YES, SEQ::NO);

    //. ------------------------------------------------------------------------------------
    //. Database control:
    //.     If repetitions >= 1, is it allowed to put each one in a different series?
    //. ------------------------------------------------------------------------------------
     rSeqLim.setMultipleSeriesMode (SEQ::MULTIPLE_SERIES_OFF, SEQ::MULTIPLE_SERIES_EACH_MEASUREMENT,
                                SEQ::MULTIPLE_SERIES_EACH_SLICE , SEQ::MULTIPLE_SERIES_EACH_SLICE_AND_MEASUREMENT );



    //. -----------------------------------------------------------------------------
    //. Adjustment parameters
    //. -----------------------------------------------------------------------------

        // Which Shim mode is the default / allowed
    rSeqLim.setAdjShim (SEQ::ADJSHIM_TUNEUP, SEQ::ADJSHIM_STANDARD); // alt: SEQ::ADJSHIM_ADVANCED (spectroscopy)


    //. -----------------------------------------------------------------------------
    //. User Interface: SolveHandlers and Sequence/Special card parameters
    //. -----------------------------------------------------------------------------

   #ifdef WIN32  // only needed on the host


        // This configures some UI behaviour (e.g. TD) and has to be called
        //  before my own SolveHandlers
    fStdImagingInitPost (rSeqLim);


    #endif

    // -------------------------------------------------------------------------------------
    // file containing the default postprocessing protocol (EVAProtocol)
    // -------------------------------------------------------------------------------------
 #ifdef WIN32
    rSeqLim.setDefaultEVAProt (_T("%SiemensEvaDefProt%\\Inline\\Inline.evp"));
 #endif





    //  ----------------------------------------------------------------------
    //  Instantiate of UI class
    //  ----------------------------------------------------------------------
    if ( (NLS_SEV & (lStatus = createUI (rSeqLim))) == NLS_SEV )  {
        TRACE_PUT1(TC_ALWAYS, TF_SEQ,"%s: Instantiation of UI class failed: FlashBack::createUI(SeqLim&)", ptModule);
        return ( lStatus );
    }



    //  ----------------------------------------------------------------------
    //  Declaration of pointer to UI parameter classes
    //  ----------------------------------------------------------------------

    #ifdef WIN32
    lStatus = m_pUI->registerUI (rSeqLim);

    if ( NLS_SEVERITY(lStatus) != NLS_SUCCESS )  {
        TRACE_PUT1_NLS(TC_INFO, TF_SEQ, "%s : Initialization of UI failed : "  , ptModule, lStatus);
        return ( lStatus );
    }
   #endif

    return (lStatus);

}








//  --------------------------------------------------------------------------
//
//  Name        :  FlashBack::prepare
//
//  Description :
/// \brief         Preparation of the sequence during binary search and prior
///                 to sequence execution
//
//  Return      :  NLS status
//
//  --------------------------------------------------------------------------
NLSStatus FlashBack::prepare (MrProt &rMrProt, SeqLim &rSeqLim, SeqExpo &rSeqExpo)
{
    static const char *ptModule = {"FlashBack::prepare"};

    // default return status is OK
    NLS_STATUS   lStatus               = SEQU__NORMAL;           // My return status
    long         lPreparingScans       = 0;                      // Number of preparing scans
    long         lTRMin                = 0;                      // Minimum TR
    double       dRfEnergyInSRFs       = 0.0;                    // RF energy in SRF
    long         lEffSatRepTime        = 0;
    long         lPreparingScansTotal  = 0;
    long         lI                    = 0;                      // Helper variables
    double       dMeasureTimeUsec      = 0.0 ;
    double       dTotalMeasureTimeMsec = 0.0 ;

        // initialize variables for rf spoiler
    m_dRFSpoilPhasePrevSlice     = 0.0;
    m_dRFSpoilIncrementPrevSlice = 0.0;
    m_dRFPrevSlicePosSag         = 999999.0;
    m_dRFPrevSlicePosCor         = 999999.0;
    m_dRFPrevSlicePosTra         = 999999.0;
    m_dRFPrevSliceNormalSag      = 999999.0;
    m_dRFPrevSliceNormalCor      = 999999.0;
    m_dRFPrevSliceNormalTra      = 999999.0;


        // get number of lines from the user interface
    lStatus = rMrProt.kSpace().linesToMeasure( m_lLinesToMeasure);
    OnErrorPrintAndReturn(lStatus,"linesToMeasure");        // if this fails, return Error

    m_lPhasesToMeasure = rMrProt.physiology().phases();      // get number of Phases from the user interface
    m_lSlicesToMeasure = rMrProt.sliceSeries().getlSize();       // get number of slices
    lStatus = rMrProt.kSpace().partitionsToMeasure( m_lPartitionsToMeasure); // get number of partitions
    OnErrorPrintAndReturn(lStatus,"PartitionsToMeasure");   // on failure, return

    m_lRepetitionsToMeasure = rMrProt.repetitions();         // get number of repetitions

    //. -----------------------------------------------------------------------------
    //. Print debug information
    //. -----------------------------------------------------------------------------

        // For sde/IDEA users: you can define a MASK in the sde environment for
        //  debug output (mask is accessible through pSeqLim->getSeqDebugMode().getDebugMask())
        // If MASK is set to PREP (9) and CALL (0) then echo name of this
        //   function to stdout
        // remember: ptModule has to be defined.
    PRINT_TRACE0 (rSeqLim, DEBUG_PREP, DEBUG_CALL, "() >>>>") ;
        // DEBUG output: if MASK is set to PREP (9) and LANDMARK (4) then echo variables to stdout
    PRINT_TRACE5 (rSeqLim, DEBUG_PREP, DEBUG_LANDMARK, "LinesToMeasure=%ld, EchoLine=%ld, PhasesToMeasure=%ld, SlicesToMeasure=%ld, RepetitionsToMeasure=%ld",
        m_lLinesToMeasure, rMrProt.kSpace().echoLine(),m_lPhasesToMeasure,m_lSlicesToMeasure,m_lRepetitionsToMeasure) ;

    DEBUG_BY_REGISTRY(128, "TR: " << rMrProt.tr()[0] );


    //. ---------------------------------------------------------------------------
    //. Define gradient rise times and strengths
    //. ---------------------------------------------------------------------------

        // It is sensible to restrict the minimum rise time and/or the maximum gradient amplitude in
        //  some cases to avoid noise and/or stimulations. Secondly, on oblique slices the
        // combination of gradients can cause gradient amplitude overflow, therefore
        //  the maximum Amplitude is reduced.

    double dReallySmallestRiseTime =  5.;
    double dReallyBiggestAmplitude = 28.;

        // These arrays take the MaxAmplitude and MinRiseTime values for the Sequence Building Blocks (SBB)
        //  Order: FAST/NORMAL/WHISPER
                                    // Default factor is 1.25 on GRAD_FAST, 1.0 on GRAD_NORMAL and GRAD_WHISPER
    double  adMinRiseTimes[3] =  {   std::max( 1.0 * SysProperties::getGradMinRiseTime(SEQ::GRAD_FAST   ),dReallySmallestRiseTime),
                                     std::max( 1.0 * SysProperties::getGradMinRiseTime(SEQ::GRAD_NORMAL ),dReallySmallestRiseTime),
                                     std::max( 1.0 * SysProperties::getGradMinRiseTime(SEQ::GRAD_WHISPER),dReallySmallestRiseTime)
                                 };

                                    // Default factor is 1.0
    double  adMaxGradAmplitudes[3] =  {  std::min( 0.8 * SysProperties::getGradMaxAmpl(SEQ::GRAD_FAST   ),dReallyBiggestAmplitude),
                                         std::min( 0.8 * SysProperties::getGradMaxAmpl(SEQ::GRAD_NORMAL ),dReallyBiggestAmplitude),
                                         std::min( 0.8 * SysProperties::getGradMaxAmpl(SEQ::GRAD_WHISPER),dReallyBiggestAmplitude)
                                 };

        // In the sequence kernel, we sometimes calculate the gradient pulses manually, so we store
        //  MinRiseTime and MaxGradAmpl
    m_dMinRiseTime = std::max<double>(dReallySmallestRiseTime, SysProperties::getGradMinRiseTime(rMrProt.gradSpec().mode()));
    m_dGradMaxAmpl = std::min<double>(dReallyBiggestAmplitude, 0.8 * SysProperties::getGradMaxAmpl(rMrProt.gradSpec().mode()));

        // GSWD mode: If the GradientSafetyWatchDog complains about stimulation,
        //  it will try to increase the gradient rise time
        //  iteratively until the stimulation threshold is reached.
        // The sequence has to be recalculated for this using the new gradients.
        // The SBBs are treated by .setGSWDGradientPerformance();
        //  but the gradients we send ourselves have to be restricted by us:
    if (rMrProt.gradSpec().isGSWDMode())
        m_dMinRiseTime =  rMrProt.gradSpec().GSWDMinRiseTime();


    //. ---------------------------------------------------------------------------
    //. Define criteria for forbidden protocol settings
    //. ---------------------------------------------------------------------------

        // Some remarks about the return value SEQU_ERROR:
        //  fSEQPrep is called in several contexts:
        //   In ContextPrepForBinarySearch the User interface tries to set parameters in order to
        //      decide which of them are editable. Here, prep cannot change protocol parameters.
        //      If fSEQPrep returns with SEQU_ERROR, the parameter is either not changeable or
        //      a SolveHandler is needed.
        //   In ContextPrepForMrProtUpdate the Protocol can be modified. This context
        //      is set after failure of the ContextPrepForBinarySearch.
        //   The final call of fSEQPrep (using the final settings) must succeed, otherwise the
        //      sequence cannot run this protocol. In this case, the user will get an error message
        //      like: "An internal error occurred. Your last change will be lost".
        //   To conclude: During the parameter search, a SEQU_ERROR is ok (or even necessary to find the limits
        //      e.g. of TE), since it indicates only that a parameter cannot be modified in this way.
        //       But on the final preparation, a SEQU_ERROR is fatal.

        // Combination of partial Fourier < 6/8 and RealPartImages is not allowed
        // Similarly, other forbidden combinations of UI parameters should be caught as early as possible
    if ( ((rMrProt.kSpace().phasePartialFourierFactor() == SEQ::PF_HALF) ||
       (rMrProt.kSpace().phasePartialFourierFactor() == SEQ::PF_5_8 )) &&
       (rMrProt.calcRealPartImages() )
    )
    return SEQU_ERROR ;

        // Get information about used trigger
    rMrProt.physiology().getPhysioMode (m_FirstSignal, m_FirstMethod, m_SecondSignal, m_SecondMethod);

        // We want to forbid the simultaneous use of Triggering and the
        //   "TokTokTok Gradient music" (i.e. the knocking before the measurement)
        //   for demonstration of Solve Handlers
        // So this combination must fail and a solve handler
        //  "fBSolveFunnyModeConflict1" is called if
        //  the conflict was induced by switching "Introduction" on.
    if ( (rMrProt.intro()) && (m_FirstMethod == SEQ::METHOD_TRIGGERING) )
        return SEQU_ERROR ;


    //. ---------------------------------------------------------------------------
    //. Initialize parameters on the Sequence/Special card
    //. ---------------------------------------------------------------------------

 #ifdef WIN32
        // In this part (only performed on the host) we initialize the values
        //  for the parameters on the Sequence/Special card.
        // The concept of ContextPrepForBinarySearch and ContextPrepForMrProtUpdate
        //  is used here:
        //  When creating the default protocol, fSEQPrep() is called in
        //   ContextPrepForBinarySearch. The parameters are not yet initialized,
        //   hence a SEQU_ERROR is returned. This causes a 2nd call of fSEQPrep(),
        //   this time in ContextPrepForMrProtUpdate,
        //   allowing for a modification of the protocol.
        // Now the parameters can be initialized.

        // if called within ContextPrepForMrProtUpdate, we can (and must) modify the protocol.
    if (rSeqLim.isContextPrepForMrProtUpdate())
    {
        PRINT_TRACE1 (rSeqLim, DEBUG_PREP, DEBUG_LANDMARK, "%s: initialized WIP Parameters.\n",ptModule); // just some debugging to see when this happens


            // set the selection box to the value WIP_SelectionBoxValue1
        if (!rMrProt.wipMemBlock().getalFree()[WIP_Selection_Box])     rMrProt.wipMemBlock().getalFree()[WIP_Selection_Box]     = WIP_SelectionBoxValue1;
        if (!rMrProt.wipMemBlock().getalFree()[WIP_UpperCheckBox])     rMrProt.wipMemBlock().getalFree()[WIP_UpperCheckBox]     = WIP_CheckBoxOff;
        if (!rMrProt.wipMemBlock().getalFree()[WIP_LowerCheckBox])     rMrProt.wipMemBlock().getalFree()[WIP_LowerCheckBox]     = WIP_CheckBoxOn;
        if (!rMrProt.wipMemBlock().getalFree()[WIP_LongParameter])     rMrProt.wipMemBlock().getalFree()[WIP_LongParameter]     = 400;
        if (!rMrProt.wipMemBlock().getadFree()[WIP_Double_Array_Elm1-lWIP_IndexDoubleValues_Start])
                    rMrProt.wipMemBlock().getadFree()[WIP_Double_Array_Elm1-lWIP_IndexDoubleValues_Start] = 2.;
        if (!rMrProt.wipMemBlock().getadFree()[WIP_Double_Array_Elm2-lWIP_IndexDoubleValues_Start])
                    rMrProt.wipMemBlock().getadFree()[WIP_Double_Array_Elm2-lWIP_IndexDoubleValues_Start] = 12.;
        if (!rMrProt.wipMemBlock().getadFree()[WIP_Double_Array_Elm3-lWIP_IndexDoubleValues_Start])
                    rMrProt.wipMemBlock().getadFree()[WIP_Double_Array_Elm3-lWIP_IndexDoubleValues_Start] = 22.;
    }
        // If any of the WIP parameters have not yet been initialized,
        //  return with error to induce a ContextPrepForMrProtUpdate

    long eI;
    for ( eI = WIP_Selection_Box; eI <= WIP_LongParameter; eI ++)
    {
        if (!rMrProt.wipMemBlock().getalFree()[eI])
            return SEQU_ERROR;
    }
    for ( eI = WIP_Double_Array_Elm1-lWIP_IndexDoubleValues_Start; eI <= WIP_Double_Array_Elm3-lWIP_IndexDoubleValues_Start; eI ++)
    {
        if (!rMrProt.wipMemBlock().getadFree()[eI])
            return SEQU_ERROR;
    }
        // Note that this method will disallow the use of the value "zero" in a sequence/Special parameter
        //  (return SEQU_ERROR)
        // However, it is sufficient if only one parameter is used as this indicator for "not-yet-initialized"
        // The above lines [... for ( eI = ... ]  could be replaced by a single statement like
        //   if (!pMrProt->getsWiPMemBlock().getalFree()[WIP_Selection_Box]) return SEQU_ERROR;
        // and the initialization would have to be encapsulated in this condition, too.
        //
        // The code from above could look like the following:
        //
        // if (pSeqLim->isContextPrepForMrProtUpdate())
        // {
        //   if (!pMrProt->getsWiPMemBlock().getalFree()[WIP_Selection_Box])
        //   {
        //        // initialize here ALL free parameters
        //      pMrProt->getsWiPMemBlock().getalFree()[WIP_Selection_Box]     = WIP_SelectionBoxValue1;
        //      pMrProt->getsWiPMemBlock().getalFree()[WIP_UpperCheckBox]     = WIP_CheckBoxOff;
        //      ...
        //
        //      ...
        //   }
        // }
        //
        // if (!pMrProt->getsWiPMemBlock().getalFree()[WIP_Selection_Box]) return SEQU_ERROR;
        //



#endif



    //. ----------------------------------------------------------------------------
    //. Preparation of the sequence
    //. ----------------------------------------------------------------------------


        // First, we have to calculate the time needed for a single measurement repetition.
        // Then the repetitions are considered

        // The time for a single measurement is determined by the number of kernel
        //  calls times the time for the kernel

    m_lKernelRequestsPerMeasurement = m_lPhasesToMeasure * m_lSlicesToMeasure
                                     * m_lLinesToMeasure * m_lPartitionsToMeasure
                                     * rMrProt.averages();


        // If there are Preparation scans outside the standard loop that
        //  call the Kernel, consider them here
    lPreparingScansTotal = 0 ;
    m_lKernelRequestsPerMeasurement +=  lPreparingScansTotal ;

    //. ----------------------------------------------------------------------------
    //. Prepare the Prepulses like Sats etc.
    //. ----------------------------------------------------------------------------

        // These Sats are done via Sequence Building Blocks (SBB)
        // These SBB functions will only prepare themselves, if the appropriate
        // selection has been made in the user interface.

        // One has to calculate the total RF energy to satisfy the unit test, therefore we
        //  accumulate all energy sent by the prepulses in a variable
    double dEnergyInPrepulsesPerMeasurement = 0.0 ; // reset energy calculation

        // The effective Repetition time is needed for optimal flipangle calculation of MSat pulses
        //  For sequential slice excitation (which is used in this sequence, it is equal to TR.
        // For interleaved excitation, the effective TR is shorter
    if (rMrProt.kSpace().getucMultiSliceMode() == SEQ::MSM_SEQUENTIAL)
        lEffSatRepTime = (rMrProt.tr()[0]);
    else
        lEffSatRepTime = (long)(rMrProt.tr()[0] / rMrProt.sliceSeries().getlSize());



    //. ----------------------------------------------------------------------------
    //. Preparation of Magnetization Transfer Contrast
    //. ----------------------------------------------------------------------------

        // Tell, how many Saturation pulses would be used during the measurement
        //  (needed for calculation of energy and time)
    m_MSatSBB.setRequestsPerMeasurement (m_lKernelRequestsPerMeasurement);
        // The spoiler gradient inside the SBB can be configured / limited
        //  for the selected gradient mode
        // An array with the maximum amplitudes for FAST/NORMAL/WHISPER is handed over
        // If not set, a default is used.
    m_MSatSBB.setMaxMagnitudes(adMaxGradAmplitudes);
        // ditto for the minimum rise time
    m_MSatSBB.setMinRiseTimes (adMinRiseTimes);
    m_MSatSBB.setFrequencyOffset (MSATOFFSETFREQHz);
        // Calculate flip angle depending on effective TR
    m_MSatSBB.setEffTrTime((double) lEffSatRepTime / 1000.0 );  // MSatSBB expects Milliseconds ;-)
        // Tell the SBB to use the longer rise times in case of a GSWD binary search
        // NOTE: This method has to be called for every SeqBuildBlock you use.
    m_MSatSBB.setGSWDGradientPerformance(rMrProt, rSeqLim);
        // prepare the saturation SBB
    if ( ! m_MSatSBB.prep(rMrProt,rSeqLim,rSeqExpo))
    {
        if ( ! rSeqLim.isContextPrepForBinarySearch() || TRUE_IF_DETAILED_DEBUG )
        {
            STRING_TR(rSeqLim, "FAILED to prepare ",m_MSatSBB.getIdent())
        }
         return m_MSatSBB.getNLSStatus();
    }
    dEnergyInPrepulsesPerMeasurement += m_MSatSBB.getEnergyPerRequest()
                                                   * m_lKernelRequestsPerMeasurement;

    //. ----------------------------------------------------------------------------
    //. Preparation of Regional Saturation pulses
    //. ----------------------------------------------------------------------------

    for (lI=0; lI < MAXRSATS; lI++) {
        m_RSatSBB[lI].setRequestsPerMeasurement (m_lKernelRequestsPerMeasurement);
        m_RSatSBB[lI].setMaxMagnitudes(adMaxGradAmplitudes);
        m_RSatSBB[lI].setMinRiseTimes (adMinRiseTimes);
        m_RSatSBB[lI].setGSWDGradientPerformance(rMrProt, rSeqLim);

        if ( ! m_RSatSBB[lI].prep(rMrProt,rSeqLim,rSeqExpo))
        {
            // Preparation of RSatSBB has failed. If this is within the binary search,
            //  that's not really bad, so don't print out any text, just return
            //  with an NLS status.
            // BUT if it happens in the real preparation, then print the information
            //  that it was the RSatSBB that caused the failure
            if ( ! rSeqLim.isContextPrepForBinarySearch() )
            {
                STRING_TR(rSeqLim, "FAILED to prepare ",m_RSatSBB[lI].getIdent())
            }
            return m_RSatSBB[lI].getNLSStatus();
        }


        dEnergyInPrepulsesPerMeasurement += m_RSatSBB[lI].getEnergyPerRequest()
                                                 * m_lKernelRequestsPerMeasurement;
    }

    //. ----------------------------------------------------------------------------
    //. Preparation of Travelling Sats
    //. ----------------------------------------------------------------------------

    m_TSatSBB.setRequestsPerMeasurement (m_lKernelRequestsPerMeasurement);
    m_TSatSBB.setMaxMagnitudes(adMaxGradAmplitudes);
    m_TSatSBB.setMinRiseTimes (adMinRiseTimes);
    m_TSatSBB.setGSWDGradientPerformance(rMrProt, rSeqLim);

    if ( ! m_TSatSBB.prep(rMrProt,rSeqLim,rSeqExpo))
    {
        if ( ! rSeqLim.isContextPrepForBinarySearch() || TRUE_IF_DETAILED_DEBUG )
        {
            STRING_TR(rSeqLim, "FAILED to prepare ",m_TSatSBB.getIdent())
        }
         return m_TSatSBB.getNLSStatus();
    }
    dEnergyInPrepulsesPerMeasurement += m_TSatSBB.getEnergyPerRequest()
                                                 * m_lKernelRequestsPerMeasurement;



    //. ----------------------------------------------------------------------------
    //. Preparation of Fat Saturation
    //. ----------------------------------------------------------------------------

    m_CSatFatSBB.setRequestsPerMeasurement (m_lKernelRequestsPerMeasurement);
    m_CSatFatSBB.setMaxMagnitudes(adMaxGradAmplitudes);
    m_CSatFatSBB.setMinRiseTimes (adMinRiseTimes);
        // Set an appropriate Ident for the Saturation
    m_CSatFatSBB.setCSatMode (SBBCSatCode_Fat);
    m_CSatFatSBB.setGSWDGradientPerformance(rMrProt, rSeqLim);

    if ( ! m_CSatFatSBB.prep(rMrProt,rSeqLim,rSeqExpo))
    {
        if ( ! rSeqLim.isContextPrepForBinarySearch() || TRUE_IF_DETAILED_DEBUG )
        {                                           // or even a detailed error message,
                                                    //  if not searching
            STRING_TR(rSeqLim, "FAILED to prepare ",m_CSatFatSBB.getIdent())
        }
         return m_CSatFatSBB.getNLSStatus();   // on error return NLS code
    }
        // add the calculated energy of the fat sat pulse
    dEnergyInPrepulsesPerMeasurement += m_CSatFatSBB.getEnergyPerRequest()* m_lKernelRequestsPerMeasurement;

    // Note that the CSatSBB has its own spoil gradients before and after the RF.
    // The last gradient ramp down time may hang out of the event block;
    //  this time can be retrieved via .getRampTimeOutsideSBB();


    //. ----------------------------------------------------------------------------
    //. Preparation of Water Saturation
    //. ----------------------------------------------------------------------------

    m_CSatWatSBB.setRequestsPerMeasurement (m_lKernelRequestsPerMeasurement);
    m_CSatWatSBB.setMaxMagnitudes(adMaxGradAmplitudes);
    m_CSatWatSBB.setMinRiseTimes (adMinRiseTimes);
    m_CSatWatSBB.setCSatMode (SBBCSatCode_Water);
    m_CSatWatSBB.setGSWDGradientPerformance(rMrProt, rSeqLim);

    if ( ! m_CSatWatSBB.prep(rMrProt,rSeqLim,rSeqExpo))
    {
        if ( ! rSeqLim.isContextPrepForBinarySearch() || TRUE_IF_DETAILED_DEBUG )
        {
            STRING_TR(rSeqLim, "FAILED to prepare ",m_CSatWatSBB.getIdent())
        }
         return m_CSatWatSBB.getNLSStatus();
    }
    dEnergyInPrepulsesPerMeasurement += m_CSatWatSBB.getEnergyPerRequest() * m_lKernelRequestsPerMeasurement;


    //. ----------------------------------------------------------------------------
    //. Preparation of Spoiler SBB, if any Sats have been used
    //. ----------------------------------------------------------------------------

    m_SpoilSBB.setRequestsPerMeasurement (m_lKernelRequestsPerMeasurement);
    m_SpoilSBB.setMaxMagnitudes(adMaxGradAmplitudes);
    m_SpoilSBB.setMinRiseTimes (adMinRiseTimes);
    m_SpoilSBB.setGSWDGradientPerformance(rMrProt, rSeqLim);

        // The spoiler prepares itself only, if a prepulse has been selected in the UI.
        //  To disable this automatic mode, you could use SpoilSBB.setSATSpoiler(false)
    if ( ! m_SpoilSBB.prep(rMrProt,rSeqLim,rSeqExpo))
    {
        if ( ! rSeqLim.isContextPrepForBinarySearch() || TRUE_IF_DETAILED_DEBUG )
        {
            STRING_TR(rSeqLim, "FAILED to prepare ",m_SpoilSBB.getIdent())
        }
        return m_SpoilSBB.getNLSStatus();
    }


    //. ----------------------------------------------------------------------------
    //. Preparation of TokTokTok gradient sound prior to measurement
    //. ----------------------------------------------------------------------------

    m_TokTokSBB.setRequestsPerMeasurement (1);
    if ( ! m_TokTokSBB.prep(rMrProt,rSeqLim,rSeqExpo))
    {
        if ( ! rSeqLim.isContextPrepForBinarySearch() || TRUE_IF_DETAILED_DEBUG )
        {
            STRING_TR(rSeqLim, "FAILED to prepare ",m_TokTokSBB.getIdent())
        }
         return m_TokTokSBB.getNLSStatus();
    }

        // Instead of preparing all SBBs seperately, one could use the
        //  SBBList method prepSBBAll.
        // This method also calculates the energy in the prepulses.
    //- if (!m_mySBBList.prepSBBAll (pMrProt, pSeqLim, pSeqExpo, &dEnergyInPrepPulses))
    //-    return(m_mySBBList.getpSBBLastPrep()->getNLSStatus()) ;


    //. ----------------------------------------------------------------------------
    //. Final calculation of energy and time for the preparation
    //. ----------------------------------------------------------------------------

        // Total Prepration pulse energy
    double dEnergyInPrepPulses = dEnergyInPrepulsesPerMeasurement * (rMrProt.repetitions()+1);

        // Now calculate the time that is used by the Saturation Prepulses
    m_lScanTimeAllSats = 0;

    for (lI=0;lI < MAXRSATS;lI++)
       m_lScanTimeAllSats  +=  m_RSatSBB[lI].getDurationPerRequest();
       m_lScanTimeAllSats  +=  m_CSatFatSBB.getDurationPerRequest();
       m_lScanTimeAllSats  +=  m_CSatWatSBB.getDurationPerRequest();
       m_lScanTimeAllSats  +=  m_MSatSBB.getDurationPerRequest();
       m_lScanTimeAllSats  +=  m_TSatSBB.getDurationPerRequest();
       m_lScanTimeAllSats  +=  m_SpoilSBB.getDurationPerRequest();


        // The trigger also needs some time, if triggering has been requested:
        // calculate Time needed for trigger
    m_lTrigHaltDuration1 = m_lTrigHaltDuration2 = 0;
    if (m_FirstMethod == SEQ::METHOD_TRIGGERING)
    {
        DEBUG_BY_REGISTRY( 128,"---- Trigger 1 is on, Method " << m_FirstMethod );
        m_lTrigHaltDuration1 =  std::max<long>((long)(rMrProt.physiology().triggerDelay(m_FirstSignal)), (long)(m_sTriggerBit1.getDuration()) + 10);
        if (m_SecondMethod == SEQ::METHOD_TRIGGERING)
        {
            m_lTrigHaltDuration2 =  std::max<long>((long)(rMrProt.physiology().triggerDelay(m_SecondSignal)), (long)(m_sTriggerBit2.getDuration()) + 10);
        }
    }


        // Calculate, how long the measurement will last
    dMeasureTimeUsec  =  (double) m_lKernelRequestsPerMeasurement * (double) ( rMrProt.tr()[0] ) ;
    dMeasureTimeUsec +=  (double) m_lKernelRequestsPerMeasurement * (double) (m_lTrigHaltDuration1 + m_lTrigHaltDuration2) / (double) m_lLinesToMeasure ;
    dMeasureTimeUsec +=  (double) m_TokTokSBB.getDurationPerRequest();

        // The duration of the main event block excludes the SBB functions
    m_lDurationMainEventBlock = rMrProt.tr()[0] - m_lScanTimeAllSats  ;



    //. ---------------------------------------------------------------------------
    //. Prepare the RF pulse objects
    //. ---------------------------------------------------------------------------

    m_sSRF01.setFlipAngle            (rMrProt.flipAngle());
    m_sSRF01.setInitialPhase         (0);
    m_sSRF01.setThickness            (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF01.setDuration             (2560);
      // this it required by the unit test, so it knows the purpose the pulse
    m_sSRF01.setTypeExcitation       ();
    m_sSRF01.setSamples              (128);
    m_sSRF01.setBandwidthTimeProduct (2.70);
    if (! m_sSRF01.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF01.getNLSStatus());

        //if it would be an external RF-pulse, use this:
    //- sSRF01.setFamilyName ("SE2560A90.SE90_12A2_2") ;
    //- if(! sSRF01.prepExternal(pMrProt,pSeqExpo) )  return (sSRF01.getNLSStatus());

    dRfEnergyInSRFs  = m_lKernelRequestsPerMeasurement * m_sSRF01.getPulseEnergyWs()
                                                     * (rMrProt.repetitions()+1);


    //. -------------------------------------------------------------------------------
    //. Prepare readout (ADC) objects
    //. -------------------------------------------------------------------------------
        // prepare the ADC with number of columns and dwelltime from the protocol
    m_sADC01.prep(rMrProt.kSpace().getlBaseResolution(), static_cast<long>(rMrProt.rxSpec().effDwellTime( rSeqLim.getReadoutOSFactor() )[0] + 0.5));
        // inform the Mdh about the k-space center column (symmetric echo)
    m_sADC01.getMDH().setKSpaceCentreColumn((unsigned short) (0.5 * rMrProt.kSpace().getlBaseResolution()) );


    //. -------------------------------------------------------------------------------
    //. Prepare readout gradient pulse
    //. -------------------------------------------------------------------------------
        // This is the simple style: choose a ramp time
    m_sGradReadout.setRampTimes (600) ;
        // choose the Duration of the RO gradient
    m_sGradReadout.setDuration  (fSDSRoundUpGRT(m_sADC01.getDuration()+m_sGradReadout.getRampUpTime())) ;             /*! EGA-03; EGA-01 !*/
        // fSDSRoundUpGRT rounds up to the next multiple of 10us
        //  (GRT = gradient raster time)

        // Hint: To get the Larmor constant, you can use the method
        //  m_sSRF01->getLarmorConst()
    if( !m_sGradReadout.prepRO( rMrProt, m_sADC01.getDwellTime()) )
    {
         return m_sGradReadout.getNLSStatus();
    }

    if (IS_DEBUG_BITMASK (rSeqLim, DEBUG_PREP|DEBUG_LANDMARK))
        std::cout << "GR_RO:   Ampl=" << m_sGradReadout.getAmplitude()
            << "    Dur=" <<  m_sGradReadout.getDuration()
            << "     Ramp=" << m_sGradReadout.getRampUpTime() << std::endl ;
    DEBUG_BY_REGISTRY( 32, " prep m_sGradReadout " << m_sGradReadout.getAmplitude() << " " << m_sGradReadout.getDuration() << " " << m_sGradReadout.getRampDownTime() << std::endl) ;
        // ... and check for possible problems
    if (! m_sGradReadout.check() )
    {
        DEBUG_BY_REGISTRY( 128, " sGradReadout failed ");
        return (m_sGradReadout.getNLSStatus());
    }

    //. ----------------------------------------------------------------------------
    //. Prepare 2D-phase encoding table gradient
    //. ----------------------------------------------------------------------------

        // Remember: This code is NOT optimized, just for demonstration :-)
        //  as a side effect, you have to increase this numbers, if you want to use this
        //  sequence for X-nucleus imaging.
    long lPEDuration = 1000;  // define some gradient times...
    long lPERampTime =  600;

        // The prepPE method prepares a Phase encoding gradient table.
        // It needs: the ramp up time, the duration (ramp up plus flat top),
        //  the ramp down time, the Protocol settings, the direction (ascending/descending),
        //  an offset momentum, and finally the current line coordinate.
        // Note: The final prep for each different k-space line has to be done inside
        //  the fSEQRunKernel function.
    if(! m_sGPhasTab.prepPE(lPERampTime, lPEDuration , lPERampTime, rMrProt, SEQ::DIR_ASCENDING, 0.0,
                     m_lLinesToMeasure - rMrProt.kSpace().echoLine() -1)  )  /*! EGA-03; EGA-01 !*/
        return(m_sGPhasTab.getNLSStatus());

        // Since we have manually fixed the ramp times and the duration, the amplitude may
        // exceed the gradient specification. So the gradient must be checked:
    if(! m_sGPhasTab.check() )
        return(m_sGPhasTab.getNLSStatus());

        // This second check looks at the other end of k-space to avoid failure there.
    if(! m_sGPhasTab.prepPE(lPERampTime, lPEDuration, lPERampTime, rMrProt, SEQ::DIR_ASCENDING, 0.0, - rMrProt.kSpace().echoLine()) )  /*! EGA-03; EGA-01 !*/
        return(m_sGPhasTab.getNLSStatus());
    if(! m_sGPhasTab.check() )
        return(m_sGPhasTab.getNLSStatus());

    //. ----------------------------------------------------------------------------
    //. Prepare slice selection gradient
    //. ----------------------------------------------------------------------------

        // In this example we calculate the optimal timing ourselves:
        // First step: What is the minimal ramp time for the needed gradient amplitude?
        //       (Take the required amplitude and multiply it with the min rise time)
        //       (The MAX(.. ,..) inhibits complaints about too little time before
        //        RF start
    m_lMySliSelRampTime =  fSDSRoundUpGRT(  std::max<double>(SysProperties::getCoilCtrlLead(),
                                           m_dMinRiseTime * m_sSRF01.getGSAmplitude())) ;
        // Second step: prepare it with the Amplitude requested by the RF-pulse
        //        and the duration of it
    if (! m_sGSliSel.prepAmplitude(m_lMySliSelRampTime, fSDSRoundUpGRT(m_sSRF01.getDuration()+m_lMySliSelRampTime), m_lMySliSelRampTime, m_sSRF01.getGSAmplitude() ) ) /*! EGA-04; EGA-02 !*/
       return(m_sGSliSel.getNLSStatus());
    if (! m_sGSliSel.check() ) // check it, on failure bail out
        return (m_sGSliSel.getNLSStatus());

        // check, how much time there is for the other gradients:
        //          what is the difference between the requested TE and the time
        //          already used for the gradients prepared until now?
    long lAvailableTime = fSDSRoundDownGRT( rMrProt.te()[0] - ( m_sSRF01.getDuration()/2 + m_sGSliSel.getRampDownTime() + m_sADC01.getDuration()/2 + m_sGradReadout.getRampUpTime() ));

       // If lAvailableTime <= 0 , then there is not enough time between rf and
       //  readout, so request more TE
    if ( lAvailableTime <= 0 )
    {
        DEBUG_BY_REGISTRY( 128, " reject rMrProt.te()[0] (not enough time for gradients) " << rMrProt.te()[0] );
        return SBB_NEGATIV_TEFILL ;
    }


    //. ----------------------------------------------------------------------------
    //. Prepare slice selection rewinder / 3D phase encoding table
    //. ----------------------------------------------------------------------------
        //  The momentum is given by half of the duration of the gradient
        //   flat top after middle of the RF-pulse plus the momentum of
        //   the ramp down gradient
    double dMomentumToBeRewinded =  m_sSRF01.getGSAmplitude()
                                    * ( m_sSRF01.getDuration() + m_lMySliSelRampTime ) / 2.;

        //  Depending on the sequence type ( 2D/3D ) the slice selection rewinder
        //   is put into the 3D phase encoding table or not.
    switch (rMrProt.kSpace().getucDimension())
    {
        case SEQ::DIM_2 :  // If there has been 2D selected ...
            m_sG3DTab.prepAmplitude     (0, 0, 0, 0.0); // we don't need a 3D phase encoding...

                // In this example, the fastest rewinding for the rephasing
                //  of the generated gradient moment is demonstrated:
                // One has to tell, what the limits of the Gradient are...
            m_sGSliSelReph.setMaxMagnitude(m_dGradMaxAmpl);
            m_sGSliSelReph.setMinRiseTime(m_dMinRiseTime);
                // and now the gradient is calculated automatically
            if (! m_sGSliSelReph.prepSymmetricTOTShortestTime( - dMomentumToBeRewinded)   ) /*! EGA-04; EGA-02 !*/
            {
                DEBUG_BY_REGISTRY( 128, " m_sGSliSelReph.prepSymmetricTOTShortestTime failed " );
                return (m_sGSliSelReph.getNLSStatus());
            }
                // The check is included in prepSymmetricTOTShortestTime, so we don't need it here:
                //- if (! sGSliSelReph.check() ) return (sGSliSelReph.getNLSStatus());

            if ( m_sGSliSelReph.getTotalTime() > lAvailableTime )
            {
                DEBUG_BY_REGISTRY( 128, " reject rMrProt.te()[0] (SliceRephase does not fit) " << rMrProt.te()[0] );
                return SBB_NEGATIV_TEFILL ;
            }
            break;

        case SEQ::DIM_3 :   // If there is 3D...
            m_sGSliSelReph.prepAmplitude     (0, 0, 0, 0.0); // We include the "slice" rewinding in the
                                                           //  3D phase encoding table
            m_sG3DTab.setMaxMagnitude(m_dGradMaxAmpl);         // Define properties of 3D gradient
            m_sG3DTab.setMinRiseTime (m_dMinRiseTime);
                // Prepare it in the shortest possible time...
            if (!m_sG3DTab.prep3DShortestTime    (rMrProt, SEQ::DIR_ASCENDING, - dMomentumToBeRewinded, 0 - rMrProt.kSpace().echoPartition()) )
                return m_sG3DTab.getNLSStatus();
            if ( m_sG3DTab.getTotalTime() > lAvailableTime )  // If the calculated time is too large, return with ERROR
            {
                    // if this should happen outside an binary search, we have a serious problem, so report it...
                if ( ! rSeqLim.isContextPrepForBinarySearch() ) TRACE_PUT1(TC_INFO, TF_SEQ, "%s: 3D gradient does not fit into timing.\n",ptModule);
                return SBB_NEGATIV_TEFILL ;
            }

            m_sG3DTabRew.setMaxMagnitude(m_dGradMaxAmpl);
            m_sG3DTabRew.setMinRiseTime (m_dMinRiseTime);
            m_sG3DTabRew.setAxis (SEQ::AXIS_SLICE);
                // Prepare it in the shortest possible time...
            if (!m_sG3DTabRew.prep3DShortestTime    (rMrProt, SEQ::DIR_ASCENDING, 0, 0 - rMrProt.kSpace().echoPartition()) )
                return m_sG3DTabRew.getNLSStatus();
            if ( m_sG3DTabRew.getTotalTime() > m_sGPhasTab.getTotalTime())
            {
                return (SEQU_ERROR);
            }

            break;
        default: return SEQU_ERROR;
    }


    //. ----------------------------------------------------------------------------
    //. Prepare read dephase gradient
    //. ----------------------------------------------------------------------------

        // For the read dephaser, the step-by-step preparation is demonstrated:
    double dNeededMomentForDephase = m_sGradReadout.getAmplitude() * (m_sADC01.getDuration() + m_sGradReadout.getRampUpTime() )/2;

        // 1. set Ramp Times
        // This calculates the gradient rise time needed if one wants to reach
        //  full gradient strength, so it is the "worst case scenario", since
        //  not always the  maximum amplitude is needed.
    m_sGReadDeph.setRampTimes ( fSDSRoundUpGRT(m_dMinRiseTime * m_dGradMaxAmpl) );

        // 2. set Duration (we stretch the gradient as long as we can)
    m_sGReadDeph.setDuration  (fSDSRoundDownGRT(lAvailableTime + m_sGSliSel.getRampDownTime() - m_sGReadDeph.getRampDownTime()));
    if  ( dNeededMomentForDephase / (double) m_sGReadDeph.getDuration() >=  m_dGradMaxAmpl )
    {
        DEBUG_BY_REGISTRY( 128, "m_sGReadDeph failed: Ampl too high ");
        return SBB_NEGATIV_TEFILL;
    }

        // 3. set Amplitude (note that it is sensible to calculate the
        //     duration/ramp times first and then the amplitude,
        //     since the times must be rounded to the gradient raster time
    m_sGReadDeph.setAmplitude (- dNeededMomentForDephase / (double) m_sGReadDeph.getDuration() );

        // 4. prepare
    if (! m_sGReadDeph.prep() )
    {
        DEBUG_BY_REGISTRY( 128, "m_sGReadDeph.prep() failed " );
        return (m_sGReadDeph.getNLSStatus());
    }

        // 5. check
    if (! m_sGReadDeph.check() )
    {
        DEBUG_BY_REGISTRY( 128, "m_sGReadDeph.check() failed" );
        return SBB_NEGATIV_TEFILL;
    }

    //. ----------------------------------------------------------------------------
    //. Prepare phase encoding rewinder gradient
    //. ----------------------------------------------------------------------------

        // Now define the rewinder for the phase tab;
        //  simply copy it from the original Phase table ...
    m_sGPhasTabRew=m_sGPhasTab;

    //. ----------------------------------------------------------------------------
    //. Prepare the spoilers
    //. ----------------------------------------------------------------------------

        // In this example, we want spoiler gradients only if the 2nd checkbox on the
        //  Sequence/Special card is activated
    if (rMrProt.wipMemBlock().getalFree()[WIP_LowerCheckBox] == WIP_CheckBoxOn)
    {
            // Prepare spoilers
            //  Set the characteristics for the gradients
        m_asGSpoil[Slice].setMaxMagnitude(m_dGradMaxAmpl);
        m_asGSpoil[Slice].setMinRiseTime (m_dMinRiseTime);

        double dSpoilMomentumSlice = m_sGSliSel.getAmplitude()
                          * (m_sGSliSel.getFlatTopTime()/2 + m_sGSliSel.getRampDownTime()/2 );
        dSpoilMomentumSlice =  std::min(dSpoilMomentumSlice,
                                  m_sGPhasTabRew.getDuration() * m_asGSpoil[Slice].getMaxMagnitude() );
            // The slice spoiler has to be performed in the time available
            //  during the execution of the Phase rewinder,
            //  and we want to have a certain gradient moment:
        switch ( rMrProt.kSpace().getucDimension() )
        {
            case SEQ::DIM_2:
                if (! m_asGSpoil[Slice].prepSymmetricTOTExactMomentum ( dSpoilMomentumSlice , m_sGPhasTabRew.getTotalTime())  )
                    return (m_asGSpoil[Slice].getNLSStatus());
            break;

            case SEQ::DIM_3:
                 m_asGSpoil[Slice].prepAmplitude(0,0,0,0.0);

            break;
            default: return SEQU_ERROR;
        }


            // For the read spoiler, we continue the readout gradient but multiply
            //  its amplitude by 2:
            // Match ramp times with the predecessor gradient
        long lSpoilReadRampUpTime         = m_sGradReadout.getRampDownTime();
        long lSpoilReadAmplitudeRequested = static_cast<long>( std::min (m_dGradMaxAmpl,2.0*m_sGradReadout.getAmplitude()));
        long lSpoilReadAmplitude          = lSpoilReadAmplitudeRequested;
        long lSpoilReadRampDownTime       = fSDSRoundUpGRT(lSpoilReadAmplitude * 2 * m_dMinRiseTime);
            //  Choose duration, that it fits in the timing of the Phase table rewinder
        long lSpoilReadDuration           = m_sGPhasTabRew.getTotalTime()-lSpoilReadRampDownTime;

        if (! m_asGSpoil[Read ].prepAmplitude (lSpoilReadRampUpTime, lSpoilReadDuration, lSpoilReadRampDownTime, lSpoilReadAmplitude) ) // check it, on failure bail out
            return (m_asGSpoil[Read].getNLSStatus());

            // This is just a silly example how to cut down your gradient iteratively
            //  if it does not fit into your timing...
            // Of course you should better request some more time
            //  instead of doing this.
        while (! m_asGSpoil[Read ].check() || lSpoilReadDuration < lSpoilReadRampUpTime)
        {       // while the check fails, iteratively decrease the gradient strenght.
            lSpoilReadAmplitude          = static_cast<long>(lSpoilReadAmplitude * 0.9);
            lSpoilReadRampDownTime       = fSDSRoundUpGRT(lSpoilReadAmplitude * 2 * m_dMinRiseTime);
            lSpoilReadDuration           = m_sGPhasTabRew.getTotalTime()-lSpoilReadRampDownTime;
            if (lSpoilReadAmplitude < lSpoilReadAmplitudeRequested * .05 ) // Now it's useless, so finish this game
                return (SEQU_ERROR);
            if (! m_asGSpoil[Read ].prepAmplitude (lSpoilReadRampUpTime, lSpoilReadDuration, lSpoilReadRampDownTime, lSpoilReadAmplitude) ) // if you cannot even prep it, exit
                return (m_asGSpoil[Read].getNLSStatus());
        }
        if  (lSpoilReadAmplitude != lSpoilReadAmplitudeRequested)
            std::cout << "Reduced Read spoiler Amplitude by Factor of " << static_cast<double>(lSpoilReadAmplitudeRequested) / lSpoilReadAmplitude<< std::endl;

            // Since we want to start the gradients with a .run-Method in the RunKernel,
            //  we have to define which gradient axis they belong to..
        m_asGSpoil[Read ].setAxis ( SEQ::AXIS_READOUT);
        m_asGSpoil[Slice].setAxis ( SEQ::AXIS_SLICE  );
    }
    else
    {       // No, we don't like spoiling our sequence...
        for (lI = 0;lI < 2;lI ++) m_asGSpoil[lI].prepAmplitude(0,0,0,0.0);
    }

    //. ----------------------------------------------------------------------------
    //. Calculate TEFill-times and check, whether timing can be realized
    //. ----------------------------------------------------------------------------

        // After definition of the gradient pulses, check whether we can fulfill
        //  the TE and TR requirements

    m_lInterDuration =   std::max( m_sGPhasTab.getTotalTime(), m_sGReadDeph.getTotalTime());
    m_lInterDuration =   std::max( m_lInterDuration , m_sGSliSelReph.getTotalTime() + m_sGSliSel.getRampDownTime()) ;

    m_alTEFil[ 0] = (rMrProt.te()[0] - m_sSRF01.getDuration()/2 - m_sGradReadout.getRampUpTime() - long(m_sADC01.getDuration()/2.0) - m_lInterDuration);

        // If the calculated TE fill time is negative, exit with the appropriate Error code
        // The above already checked Errors would be caught here, anyway...
    if ( m_alTEFil[ 0] < 0 )
    {
        if (rSeqLim.isContextPrepForMrProtUpdate())
        {
                // If we're in ContextPrepForMrProtUpdate, we have the right to
                //  alter the protocol
                // Therefore, we decrease TE[0] by the required amount.
            TRACE_PUT1(TC_INFO, TF_SEQ, "%s: rSeqLim.isContextPrepForMrProtUpdate()==TRUE, updating TE[0]y\n",ptModule);
            rMrProt.te()[0] += fSDSRoundUpGRT( -m_alTEFil[ 0]);
        }
        else
        {
                // If we're not in ContextPrepForMrProtUpdate, we must return with an error, since
                //  the protocol is invalid.
            DEBUG_BY_REGISTRY( 128, " reject rMrProt.te()[0] (negative TEFILL) " << rMrProt.te()[0] );
            return SBB_NEGATIV_TEFILL ;
        }
    }
        // Need to assure that gradient raster time is used (note that we can do
        //  this only here, since MIN( fSDSRoundUpGRT (...)) is 0,
        //  so the above check for (m_alTEFil[ 0] < 0) would always be true)
    m_alTEFil[ 0] = fSDSRoundUpGRT(m_alTEFil[ 0]);

        // After the readout, we need some time for rewinding etc.
    long lTimeAfterADC =  std::max(m_sGPhasTabRew.getTotalTime(),m_asGSpoil[Read].getTotalTime());
    lTimeAfterADC =  std::max(lTimeAfterADC,m_asGSpoil[Slice].getTotalTime());


        // The coil needs also some time for tune/detune, so make sure we keep at
        //  least this distance in time
    lTimeAfterADC =   std::max( lTimeAfterADC , static_cast<long>(SysProperties::getCoilCtrlHold()));
        // The receiver needs also some time for switching, depending on the bandwidth
    lTimeAfterADC =  static_cast<long>( std::max( lTimeAfterADC , static_cast<long>(SysProperties::getMinDurationBetweenReadoutAndRFPulse())));


    //. ----------------------------------------------------------------------------
    //. Calculate minimum TR and check, whether timing can be realized
    //. ----------------------------------------------------------------------------

    lTRMin     = m_lScanTimeAllSats + m_sGSliSel.getTotalTime() + lAvailableTime + m_alTEFil[ 0] + m_sGradReadout.getDuration() + lTimeAfterADC;
         // If the requested TR is smaller than the calculated TR, exit with
         //  the appropriate Error code
    if ( rMrProt.tr()[0] < lTRMin )
    {
        if (rSeqLim.isContextPrepForMrProtUpdate())
        {
            TRACE_PUT1(TC_INFO, TF_SEQ, "%s: rSeqLim.isContextPrepForMrProtUpdate()==TRUE, updating TR[0]\n",ptModule);
            rMrProt.tr()[0] = lTRMin;
        }
        else
        {
            DEBUG_BY_REGISTRY( 128, " reject rMrProt.tr()[0] (trfil negative)" << rMrProt.tr()[0] );
            return SBB_NEGATIV_TRFILL ;
        }
    }

    //. ----------------------------------------------------------------------------
    //. Preparation of OscBit
    //. ----------------------------------------------------------------------------

        // Prepare the osc bit
    m_sOscBit.setCode      (SYNCCODE_OSC0);
    m_sOscBit.setIdent     (RTEIDENT_Osc0) ;
    m_sOscBit.setDuration  (10);
    m_sOscBit.setStartTime (0);
    m_sOscBit.prep         ( 0, 10 );   // Channel: 0, duration: 10us

        // Note: Preparation of the triggering bits is done automatically during construction



    //. ------------------------------------------------------------------------
    //. Set the receiver gain: For thin slices use high receiver gain
    //. ------------------------------------------------------------------------

    if (rMrProt.sliceSeries().aFront().thickness() <= 10.0 )  // unit is mm
    {
        lStatus = fSSLSetRxGain (K_RX_GAIN_CODE_HIGH, rMrProt, rSeqLim);
        OnErrorPrintAndReturn (lStatus, "fSSLSetRxGain") ;
    }
    else
    {
        lStatus = fSSLSetRxGain (K_RX_GAIN_CODE_LOW, rMrProt, rSeqLim);
        OnErrorPrintAndReturn (lStatus, "fSSLSetRxGain") ;
    }


    //. ---------------------------------------------------------------------------
    //. Calculate the rotation matrices and positions for slices
    //. ---------------------------------------------------------------------------

        // fSUPrepSlicePosArray sets the index in the asSLC array according to
        //  (among other parameters) the setting of the SliceSeriesMode

    lStatus = fSUPrepSlicePosArray (rMrProt, rSeqLim, m_asSLC);
    OnErrorPrintAndReturn (lStatus,  "fSUPrepSlicePosArray");


    //. ---------------------------------------------------------------------------
    //. Export information to pSeqExpo
    //. ---------------------------------------------------------------------------
        // Now pass all the calculated information to the SeqExpo structure,
        //   this informs the ICE image reconstruction etc.

    fSUSetSequenceString ("fl", rMrProt, rSeqExpo); // tell the basic sequence string
    rSeqExpo.setRFEnergyInSequence_Ws  (dRfEnergyInSRFs + dEnergyInPrepPulses);
    rSeqExpo.setMeasuredPELines        (m_lLinesToMeasure);
    rSeqExpo.setMeasured3dPartitions   (m_lPartitionsToMeasure);

    rSeqExpo.setMeasureTimeUsec (dMeasureTimeUsec);
        // This function calculates the total measurement time, if the experiment is
        //  repeated via measurements > 1
    lStatus=fSBBMeasRepetDelaysPrep(rMrProt, rSeqLim, rSeqExpo,
                                  (dMeasureTimeUsec/1000.),
                                  &dTotalMeasureTimeMsec);
    OnErrorPrintAndReturn(lStatus,"fSBBMeasRepetDelaysPrep");

    double m_dTotalMeasureTimeUsec = dTotalMeasureTimeMsec * 1000.0;
    
    if ( (rMrProt.getsPhysioImaging().getlMethod1() == SEQ::METHOD_TRIGGERING) &&
         (rMrProt.physiology().triggerPulses (rMrProt.getsPhysioImaging().getlSignal1()) > 1)       
       )
    {
        MrPhysiology myPhysioWrapper(rMrProt.getsPhysioImaging());

        long lTriggerLockTime_us = rMrProt.physiology().triggerDelay(rMrProt.getsPhysioImaging().getlSignal1()) + rMrProt.getalTR()[0];
         rMrProt.getsPhysioImaging().setlTriggerLockTime( lTriggerLockTime_us ); // needed by UT
        
        long lPhysioHalts = (m_lRepetitionsToMeasure + 1) * m_lPartitionsToMeasure * m_lPhasesToMeasure *  rMrProt.averages() * m_lSlicesToMeasure ;

        m_dTotalMeasureTimeUsec +=  double( lTriggerLockTime_us * lPhysioHalts* (rMrProt.physiology().triggerPulses (rMrProt.getsPhysioImaging().getlSignal1()) - 1) );
    }


    rSeqExpo.setTotalMeasureTimeUsec (m_dTotalMeasureTimeUsec);

        // if we had an asymmetric echo, the following lines would display the
        // current asymmety in the tooltip:
    //- pSeqExpo->setNoOfDisplayedAsymmetricEchoes (1);
    //- pSeqExpo->setAsymmetricEcho                ( 0, AsymmetryInPercent );


        // Real part images require phase correction scans (and inversion pulses):
        // Neither of them are implemented in this sequence
    //- if( pMrProt->calcRealPartImages() )
    //-    pSeqExpo->setPhaseCorScans        (1);
    //- else
    //-    pSeqExpo->setPhaseCorScans        (0);

        // Preparation scans are set to zero in this sequence
    rSeqExpo.setPreScans               (lPreparingScans);


        // For the calculation of the remaining measurement time during the scan
        //   in the user interface the ADC events are counted.
        // To minimize data transfer caused by this function, not every ADC event
        //  should be counted, but only about one per second. The number of these
        // events has to be given, so that the UI can display the remaining time correctly
    m_lKernelCallsPerRelevantSignal =  std::max<long>(1, (long)(m_lKernelRequestsPerMeasurement * 1000000. / dMeasureTimeUsec) );
    rSeqExpo.setRelevantReadoutsForMeasTime ( m_lKernelRequestsPerMeasurement / m_lKernelCallsPerRelevantSignal );



    //. ---------------------------------------------------------------------------
    //.   Phase correction for phase images
    //. ---------------------------------------------------------------------------
        // Set phase correction algorithm:
        // Phase+Magn: Submatrix
        // Phase+Real: extra phase correction scan
    rSeqExpo.setNoOfPhaseCorrLines   (  16 * rMrProt.kSpace().getlBaseResolution() / 256);
    rSeqExpo.setLinSlopeLength       (  16 * rMrProt.kSpace().getlBaseResolution() / 256);
    rSeqExpo.setNoOfPhaseCorrColumns ( 128 * rMrProt.kSpace().getlBaseResolution() / 256);
    rSeqExpo.setColSlopeLength       ( 128 * rMrProt.kSpace().getlBaseResolution() / 256);

    if ( rMrProt.kSpace().phasePartialFourierFactor() == SEQ::PF_HALF ||
            rMrProt.kSpace().phasePartialFourierFactor() == SEQ::PF_5_8  )
    {
        rSeqExpo.setPCAlgorithm          (SEQ::PC_ALGORITHM_MARGOSIAN);
    }
            // Note that RealPart images need phase correction scans (and inversion pulses)
            //  which are not implemented in this sequence
    //- else if ( pMrProt->calcRealPartImages() )
    //-    pSeqExpo->setPCAlgorithm          (SEQ::PC_ALGORITHM_NONE);
    else if ( rMrProt.calcPhaseImages() )
        rSeqExpo.setPCAlgorithm          (SEQ::PC_ALGORITHM_SUBMATRIX);
    else if ( rMrProt.kSpace().phasePartialFourierFactor() != SEQ::PF_OFF )
        rSeqExpo.setPCAlgorithm          (SEQ::PC_ALGORITHM_SUBMATRIX);
    else
        rSeqExpo.setPCAlgorithm          (SEQ::PC_ALGORITHM_NONE);


    //. ----------------------------------------------------------------------
    //. Set echo train length (-> used to set corresponding DICOM attributes) 
    //. ----------------------------------------------------------------------
    rSeqExpo.setEchoTrainLength         (static_cast<int32_t>(rMrProt.contrasts()) );
    rSeqExpo.setGradientEchoTrainLength (static_cast<int16_t>(rMrProt.contrasts()) );
    rSeqExpo.setRFEchoTrainLength       (static_cast<int16_t>(0) );


    //. ---------------------------------------------------------------------------
    //. Set ICE Program parameters:
    //. ---------------------------------------------------------------------------

        // Depending on the type of sequence (2D / 3D) and the expected
        //  data rate of incoming raw data, the ICE program has to be selected.
        // (Here, we don't care about the data rate, which is dangerous
        //  since this may lead to an overflow)
        // The flag SEQ::SO_SHOW_YES turns the cross in front of the measurement time on

    bool bOnlineReconstruction = (rMrProt.wipMemBlock().getalFree()[WIP_UpperCheckBox] == WIP_CheckBoxOn);

    switch ( rMrProt.kSpace().getucDimension() )  {
        case SEQ::DIM_2:
            if (bOnlineReconstruction)
            {
                rSeqExpo.setICEProgramFilename  ("%SiemensIceProgs%\\IceProgramOnline2D");
                rSeqExpo.setOnlineFFT          (SEQ::ONLINE_FFT_PHASE);
                rSeqExpo.setICEProgramParam    (ICE_PROGRAM_PARA_SHOW_OFFLINE, SEQ::SO_SHOW_NO);
            }
            else
            {
                rSeqExpo.setICEProgramFilename  ("%SiemensIceProgs%\\IceProgram2D");
                rSeqExpo.setOnlineFFT          (SEQ::ONLINE_FFT_NONE); // default: no Online FFTs except ROFT
                rSeqExpo.setICEProgramParam    (ICE_PROGRAM_PARA_SHOW_OFFLINE, SEQ::SO_SHOW_YES);
            }
        break;

        case SEQ::DIM_3:
            if (bOnlineReconstruction)
            {
                rSeqExpo.setICEProgramFilename  ("%SiemensIceProgs%\\IceProgramOnlinePeFt3D");
                rSeqExpo.setOnlineFFT          (SEQ::ONLINE_FFT_PHASE);
                rSeqExpo.setICEProgramParam    (ICE_PROGRAM_PARA_SHOW_OFFLINE, SEQ::SO_SHOW_NO);
            }
            else
            {
                rSeqExpo.setICEProgramFilename  ("%SiemensIceProgs%\\IceProgramOffline3D");
                rSeqExpo.setOnlineFFT          (SEQ::ONLINE_FFT_NONE);
                rSeqExpo.setICEProgramParam    (ICE_PROGRAM_PARA_SHOW_OFFLINE, SEQ::SO_SHOW_YES);
            }
        break;
        default : return SEQU_ERROR;
    }

    // Export the maximum number of slices per concatenation. This has to be known by the ICE program
    //  to allocate a sufficient amount of memory
    // Here, it is 1, since we only do sequential excitation
    rSeqExpo.setSlicePerConcat ( 1 );

    //- pSeqExpo->setICEProgramParam (ICE_PROGRAM_PARA_DATARATE, static_cast<long>(dDataRate* 1000));

    //- pSeqExpo->setICEProgramParam (ICE_PROGRAM_PARA_NO_OF_SERIES, 1);  // all images of different measurements are in one serie


    // Tell the UI the Application Card to be used. Other possible values can be found in
    //   /n4/pkg/MrServers/MrProtSrv/MrProt/SeqDefines.h
    rSeqExpo.setApplicationCard  (SEQ::APPLICATION_CARD_INLINE);


    //. ---------------------------------------------------------------------------
    //. Print debug information
    //. ---------------------------------------------------------------------------

        // Now we want to report the settings of the Sequence/Special parameters
        // To avoid that this is done on every prepare (e.g., if one uses POET and
        //  looks at the output) the check for
        //  isContextPrepForBinarySearch is useful, since prep is often called in the
        //  binary search to test which parameters are editable.

#ifdef WIN32 // only possible for the host...

        // We want this information only if the DEBUG_INTERNAL bit is set and in the final prep (don't report in binary search)
    if ( (IS_DEBUG_BIT(rSeqLim, DEBUG_INTERNAL)) && (! rSeqLim.isContextPrepForBinarySearch()) )
    {
        std::cout << "Upper check box is turned ";
        if (rMrProt.wipMemBlock().getalFree()[WIP_UpperCheckBox] == WIP_CheckBoxOn)
            std::cout << "ON"<< std::endl; else  std::cout << "OFF"<< std::endl;
        std::cout << "Lower check box is turned ";
        if (rMrProt.wipMemBlock().getalFree()[WIP_LowerCheckBox] == WIP_CheckBoxOn)
            std::cout << "ON"<< std::endl; else  std::cout << "OFF"<< std::endl;
        std::cout << "The selection box is set to ";
        switch (rMrProt.wipMemBlock().getalFree()[WIP_Selection_Box])
        {
            case WIP_SelectionBoxValue0 : std::cout << pszFirstChoiceTextInSelectionBox   << std::endl; break;
            case WIP_SelectionBoxValue1 : std::cout << pszSecondChoiceTextInSelectionBox  << std::endl; break;
            case WIP_SelectionBoxValue2 : std::cout << pszLastChoiceTextInSelectionBox    << std::endl; break;
            default : std::cout << " ERROR " << std::endl;
        }
        std::cout << "You entered the value "<< rMrProt.wipMemBlock().getalFree()[WIP_LongParameter] << std::endl;
    }

#endif

    //. ---------------------------------------------------------------------------
    //. End of sequence preparation
    //. ---------------------------------------------------------------------------
    DEBUG_BY_REGISTRY( 128, "  everything prepped! ");
    if ( lStatus == SEQU__NORMAL ) DEBUG_BY_REGISTRY( 128, "  SEQU_NORMAL ");;
    return (lStatus) ;


}



//  --------------------------------------------------------------------------
//
//  Name        :  FlashBack::check
//
//  Description :
/// \brief         Check of the sequence for gradient stimulation
///
///                This method is called by the framework prior to a
///                 measurement on the host to ensure, that
///                 - no gradient overflow occurs
///                 - the stimulation will not exceed the threshold
///
//  Return      :  NLS status
//
//  --------------------------------------------------------------------------
NLSStatus FlashBack::check (MrProt  &rMrProt, SeqLim &rSeqLim, SeqExpo &rSeqExpo, SEQCheckMode *pSEQCheckMode)
{

    static const char *ptModule = {"FlashBack::check"};
    NLS_STATUS   lStatus = SEQU__NORMAL;


    //  ----------------------------------------------------------------------
    //
    //  Sequence check:
    //     - max. gradient amplitude
    //     - GSWD look ahead
    //
    //  ----------------------------------------------------------------------

    // ...
     // debugging: show that fSEQCheck has been started
    PRINT_TRACE0 (rSeqLim, DEBUG_CHECK, DEBUG_CALL, "() >>>>") ;

        // Dummy to avoid compiler warning about unused variables
    #if !defined (VXWORKS) && !defined (BUILD_PLATFORM_LINUX)
        SEQCheckMode *dummy ;
        dummy = pSEQCheckMode ;
    #endif

        // For the stimultation monitor, several lines have to be checked.
        // so use the outermost k-lines for checking.
    long lL = 0;
    long alLinesToCheck[4]      = { 0, 1, rSeqExpo.getMeasuredPELines()-2     , rSeqExpo.getMeasuredPELines()-1      };
    long alPartitionsToCheck[4] = { 0, 1, rSeqExpo.getMeasured3dPartitions()-2, rSeqExpo.getMeasured3dPartitions()-1 };

    //. --------------------------------------------------------
    //. Loop over extreme k-space-points and call fSEQRunKernel
    //. --------------------------------------------------------
        // simple example: loop over outermost lines and partitions and call the
        //  Kernel, until either all cases are through or an error occurred

    while ( (lL < 4) && (((lStatus) & NLS_SEV) == NLS_SUCCESS) )
    {
        long lP = 0;
        lStatus = runKernel( rMrProt, rSeqLim, rSeqExpo, KERNEL_CHECK, 0, 0, alLinesToCheck[lL]);

        while ( rMrProt.kSpace().getucDimension() == SEQ::DIM_3    && (lP < 4) && (((lStatus) & NLS_SEV) == NLS_SUCCESS) )
        {
                lStatus = runKernel( rMrProt, rSeqLim, rSeqExpo, KERNEL_CHECK, 0, alPartitionsToCheck[lP], alLinesToCheck[lL]);
                lP++;
        }
        lL++;
    }

        // debugging: show that fSEQCheck has been finished
    PRINT_TRACE0 (rSeqLim, DEBUG_CHECK, DEBUG_RETURN, "() <<<<") ;





    return(lStatus);

}



//  --------------------------------------------------------------------------
//
//  Name        :  FlashBack::run
//
//  Description :
///     \brief     Execution of the sequence
//
//  Return      :  NLS status
//
//  --------------------------------------------------------------------------
NLSStatus FlashBack::run (MrProt &rMrProt, SeqLim &rSeqLim, SeqExpo &rSeqExpo)
{
    static const char *ptModule = {"FlashBack::run"};
    NLS_STATUS lStatus          = SEQU__NORMAL;


    //  ----------------------------------------------------------------------
    //
    //  Execution of sequence timing
    //
    //  ----------------------------------------------------------------------

    // ...
    long       lRepetition       ;
    long       lLine             ;
    long       lPartition        ;
    long       lPhase            ;
    long       lChronologicSlice ;


    PRINT_TRACE1 (rSeqLim, DEBUG_RUN, DEBUG_CALL, "() <%s> started", rSeqLim.getLinkedSeqFilename() ) ;

    //. ----------------------------------------
    //. Initialization of the unit test function
    //. ----------------------------------------
        //   The sequence unit test checks the sequence for correct timing,
        //    orientation, phase offsets etc.
        //   It is necessary to pass information to it independently from the
        //    actual gradient or timing events, so
        //    that it can be a completely unbiased observer.
        //   This is done via the mSEQTest function, which is initialized here:
    if(IS_UNIT_TEST_ACTIVE(rSeqLim))
    {
       mSEQTest(rMrProt,rSeqLim,rSeqExpo,RTEB_ORIGIN_fSEQRunStart,0,0,0,0,0); /*! EGA-All !*/
    }


        // Flexibility of loops, here shown by long/short term averaging
        // Averaging: If INNER_LOOP was selected, lAverageInnerMax is set to
        //  number of requested averages
    long lAverageInnerMax = (rMrProt.kSpace().getucAveragingMode() == SEQ::INNER_LOOP ) ? rMrProt.averages() : 1 ;
    long lAverageOuterMax = (rMrProt.kSpace().getucAveragingMode() == SEQ::INNER_LOOP ) ? 1 : rMrProt.averages() ;

    //. ---------------------------------------
    //. Set the line independent MDH parameters
    //. ---------------------------------------
    m_sADC01.getMDH().setKSpaceCentreLineNo      ((unsigned short) rMrProt.kSpace().echoLine());
    if (rMrProt.kSpace().getucDimension() == SEQ::DIM_3)
    {
        m_sADC01.getMDH().setKSpaceCentrePartitionNo ((unsigned short) rMrProt.kSpace().echoPartition());
    }
    else
    {
        m_sADC01.getMDH().setKSpaceCentrePartitionNo (0);
    }
    //. ---------------------------------------------------------------------------
    //. ---------------------------------------------------------------------------
    //. MAIN LOOP STRUCTURE
    //. ---------------------------------------------------------------------------
    //. ---------------------------------------------------------------------------

        // Instead of calling SeqLoop, in this sequence the loop structure is
        //  defined manually (and crazily)

    long lCurrKernelCalls = 0;

    for (lRepetition = 0; lRepetition <= m_lRepetitionsToMeasure ; lRepetition++)
        //-                           <= // because measurements = repetitions + 1
    {
        lCurrKernelCalls = 0;
            // Make the TokTokTok gradient sound at start of measurement
        if ( rMrProt.intro() )
        {
            if (! m_TokTokSBB.run(rMrProt, rSeqLim, rSeqExpo, &m_asSLC[0]) ) return (m_TokTokSBB.getNLSStatus()) ;
        }
            // Set the Mdh (measurement data header) information about the current
            //  repetition to tell the ADC event where the current data belongs
        m_sADC01.getMDH().setCrep ((unsigned short) lRepetition);

        for (lPartition = 0; lPartition < m_lPartitionsToMeasure ; lPartition++)
            {
                for (lPhase = 0; lPhase < m_lPhasesToMeasure; lPhase++)
                {
                        // set the Mdh for the current cardiac phase
                    m_sADC01.getMDH().setCphs ((unsigned short) lPhase);
                    for ( long lAverageOuter = 0 ; lAverageOuter < lAverageOuterMax ; lAverageOuter++ )
                    {
                        for (lChronologicSlice = 0; lChronologicSlice < m_lSlicesToMeasure; lChronologicSlice++ )
                        {
                                // start TR clock for UnitTest
                                // To check the correct calculation of TR, mSEQTest
                                //  is informed about the current slice index, since
                                //  this determines TR
                            if(IS_UNIT_TEST_ACTIVE(rSeqLim))
                            {
                                mSEQTest (rMrProt, rSeqLim, rSeqExpo, RTEB_ClockInitTR, 0, 0, m_asSLC[lChronologicSlice].getSliceIndex(), 0, 0);
                            }
                            for ( long lAverageInner = 0 ; lAverageInner < lAverageInnerMax ; lAverageInner++ )
                            {
                                    // Here comes the physiological triggering
                                if ( m_FirstMethod == SEQ::METHOD_TRIGGERING )
                                {
                                    OnErrorPrintAndReturn( lStatus = fSBBECGFillTimeRun (&m_sTriggerBit1, m_lTrigHaltDuration1 ),"fSBBECGFillTimeRun");
                                    if ( m_SecondMethod == SEQ::METHOD_TRIGGERING )
                                    {
                                        OnErrorPrintAndReturn( lStatus = fSBBECGFillTimeRun (&m_sTriggerBit2, m_lTrigHaltDuration2 ),"fSBBECGFillTimeRun");
                                    }

                                }
                                for (lLine = 0; lLine < m_lLinesToMeasure; lLine++ )
                                {       // in the innermost loop call the RunKernel
                                              //  defined below
                                    m_sADC01.getMDH().setCacq((unsigned short) (lAverageOuter+lAverageInner)) ;
                                    lCurrKernelCalls ++;
                                    if ( ! (lCurrKernelCalls % m_lKernelCallsPerRelevantSignal) )
                                    {
                                        m_sADC01.setRelevantForMeasTime() ;
                                    }

                                        // the LastScanInSlice-information is necessary for the ICE-program,
                                        //  e.g., to free memory in asynchronous reconstruction and to calculate time stamps
                                    m_sADC01.getMDH().setFirstScanInSlice ((lLine == 0) && (m_sADC01.getMDH().getCacq() == 0) );
                                    m_sADC01.getMDH().setLastScanInSlice  ((lLine == m_lLinesToMeasure -1) && (m_sADC01.getMDH().getCacq() == rMrProt.averages() -1 ) );
                                        // sequential slice order, so #concat = #slices
                                    m_sADC01.getMDH().setLastScanInConcat ((lLine == m_lLinesToMeasure -1) && (m_sADC01.getMDH().getCacq() == rMrProt.averages() -1 ) && (lPhase == m_lPhasesToMeasure-1)&&(lPartition == m_lPartitionsToMeasure-1));
                                    m_sADC01.getMDH().setLastScanInMeas   ((lLine == m_lLinesToMeasure -1) && (m_sADC01.getMDH().getCacq() == rMrProt.averages() -1 ) &&(lChronologicSlice == m_lSlicesToMeasure-1) && (lPhase == m_lPhasesToMeasure-1)&&(lPartition == m_lPartitionsToMeasure-1));

                                    lStatus = runKernel(
                                        rMrProt,
                                        rSeqLim,
                                        rSeqExpo,
                                        KERNEL_IMAGE,
                                        lChronologicSlice,
                                        lPartition,
                                        lLine  );
                                   OnErrorPrintAndReturn(lStatus,"runKernel");
                                }
                            }
                        }
                    }
                }
            }

        // Send SyncEvents between Measurement repeats
        lStatus = fSBBMeasRepetDelaysRun ( rMrProt, rSeqLim, rSeqExpo, lRepetition );
        OnErrorPrintAndReturn(lStatus,"fSBBMeasRepetDelaysRun");
        }

        // Tell sequence unit test that sequence run is finished.
    if(IS_UNIT_TEST_ACTIVE(rSeqLim))
   {
        mSEQTest(rMrProt,rSeqLim,rSeqExpo,RTEB_ORIGIN_fSEQRunFinish,0,0,0,0,0); /*! EGA-All !*/
    }
    PRINT_TRACE1 (rSeqLim, DEBUG_RUN, DEBUG_CALL | DEBUG_RETURN, "() <%s> finished",
        rSeqLim.getLinkedSeqFilename() ) ;

  return(lStatus);
}



//   --------------------------------------------------------------------------
//
//   Name        : FlashBack::runKernel
//
//   Description :
///                 Executes the basic timing of the real-time sequence.
//
//   Return      :  NLS status
//
//   --------------------------------------------------------------------------
NLS_STATUS FlashBack::runKernel(MrProt &rMrProt,SeqLim &rSeqLim, SeqExpo &rSeqExpo, long lKernelMode, long lChronologicSlice, long lPartition, long lLine)
{
    static const char *ptModule = {"FlashBack::runKernel"};
    NLS_STATUS         lStatus  = SEQU__NORMAL;


    //  ----------------------------------------------------------------------
    //
    //  Excecution of sequence kernel
    //
    //  ----------------------------------------------------------------------

    // ...
      unsigned long      ulTestIdent      = 0 ;                 // tell unit test whether we're running or checking the kernel
    long               lT               = 0 ;                 // used as clock time in the main event block
    long               lI ;

    PRINT_TRACE2 (rSeqLim, DEBUG_RUN, DEBUG_CALL, "(slice=%ld, line=%ld) ",  // Dump info about current line and slice
        m_asSLC[lChronologicSlice].getSliceIndex(), lLine  ) ;        //  if bits "RUN" and "CALL" are set

        // The following lines are for the unit test: If the Kernel is called in Check mode,
        //  pass this information to the unit test.
    if (lKernelMode == KERNEL_CHECK) ulTestIdent = RTEB_ORIGIN_fSEQCheck;
    else                             ulTestIdent = RTEB_ORIGIN_fSEQRunKernel;


    //. --------------------------------------------------------------------------
    //. Calculate the current phase-encoding table
    //. --------------------------------------------------------------------------

        // The preparation of the phase encoding gradients is done here:
        //  Tell prepPE, how far we are away from the k-space center
    if(! m_sGPhasTab   .prepPE(rMrProt,lLine - rMrProt.kSpace().echoLine() ) )
        return (m_sGPhasTab.getNLSStatus());

    if(! m_sGPhasTabRew.prepPE(rMrProt, rMrProt.kSpace().echoLine() - lLine) )
        return (m_sGPhasTabRew.getNLSStatus());
    if (rMrProt.kSpace().getucDimension() == SEQ::DIM_3)
    {
            // do the same for the partitions
        if(! m_sG3DTab.   prep3D(rMrProt,lPartition - rMrProt.kSpace().echoPartition() ) )
            return (m_sG3DTab.getNLSStatus());
        if(! m_sG3DTabRew.prep3D(rMrProt,rMrProt.kSpace().echoPartition() - lPartition ) )
            return (m_sG3DTabRew.getNLSStatus());
    }



    //. --------------------------------------------------------------------------
    //. Set the  MDH parameters
    //. --------------------------------------------------------------------------

        //  The reconstruction needs information about the k-space-coordinates
        //   of the currently read data
        //  This is done via a Measurement data header (Mdh) for each ADC structure
    m_sADC01.getMDH().setCslc ((unsigned short) lChronologicSlice); // what's the current slice
    m_sADC01.getMDH().setClin ((unsigned short) lLine);             // what's the current line?
    m_sADC01.getMDH().setCseg (0);                 // what's the current seg?
    m_sADC01.getMDH().setCpar ((unsigned short) lPartition);        // what's the current partition?
    m_sADC01.getMDH().setEvalInfoMask (m_sADC01.getMDH().getEvalInfoMask() | MDH_ONLINE) ;

        // One should tell the image reconstruction program when all lines are collected
        //  so that it can start with the phase FFT. This is done by a Mdh-entry:
        //  Set it in the last line and the last average.
    m_sADC01.getMDH().setPhaseFT    ((lLine+1 == m_lLinesToMeasure) && (m_sADC01.getMDH().getCacq()+1 == rMrProt.averages()) );

        // The same holds for the partition FT:
    m_sADC01.getMDH().setPartitionFT((lPartition + 1 == m_lPartitionsToMeasure) && (m_sADC01.getMDH().getCacq()+1 == rMrProt.averages()) );


    //. --------------------------------------------------------------------------
    //. Set the frequency/phase properties of the RF pulses
    //. --------------------------------------------------------------------------

        // This will define the slice position and is safety relevant!
    m_sSRF01zSet.prepSet (m_asSLC[lChronologicSlice], m_sSRF01) ;    /*! EGA-05 !*/
    m_sSRF01zNeg.prepNeg (m_asSLC[lChronologicSlice], m_sSRF01) ;    /*! EGA-05 !*/


    //. --------------------------------------------------------------------------
    //. Set the frequency/phase properties of the readout events
    //. --------------------------------------------------------------------------

            //  The line and partition number are used to increase/decrease the
            //  phase of the ADC, so a shift in phase enc. direction or
            //  partition (3D) is realized and is therefore safety relevant!
    m_sADC01zSet.prepSet (m_asSLC[lChronologicSlice], m_sADC01, m_sGradReadout,lLine - rMrProt.kSpace().echoLine(),lPartition - rMrProt.kSpace().echoPartition()) ;   /*! EGA-06 !*/
    m_sADC01zNeg.prepNeg (m_asSLC[lChronologicSlice], m_sADC01, m_sGradReadout,lLine - rMrProt.kSpace().echoLine(),lPartition - rMrProt.kSpace().echoPartition()) ;   /*! EGA-06 !*/


    //. ---------------------------------------------------------------------------
    //. Execute sequence building-block function(s)
    //. ---------------------------------------------------------------------------
            //  The Saturation-SBBs open and close their own event block, so they must be
            //   started by the .run method outside the main event block.
            //  They take care for themselves; if they haven't been prepared, they
            //   do not run, so here is no additional if statement necessary.

           // run MTC pulse
    if (! m_MSatSBB.run(rMrProt, rSeqLim, rSeqExpo, &m_asSLC[lChronologicSlice]) )
        return (m_MSatSBB.getNLSStatus()) ;
           // run regional sats
    for (lI=MAXRSATS-1; lI>=0; lI--) // send RSats in inverse order
    {
        if (! m_RSatSBB[lI].run(rMrProt, rSeqLim, rSeqExpo, &m_asSLC[lChronologicSlice]) )
            return (m_RSatSBB[lI].getNLSStatus()) ;
    }
        // do travelling sats
    if(! m_TSatSBB.run (rMrProt, rSeqLim, rSeqExpo, &m_asSLC[lChronologicSlice]) )
        return (m_TSatSBB.getNLSStatus()) ;
        // run FatSats
    if(! m_CSatFatSBB.run (rMrProt, rSeqLim, rSeqExpo, &m_asSLC[lChronologicSlice]) )
        return (m_CSatFatSBB.getNLSStatus()) ;
    if(! m_CSatWatSBB.run (rMrProt, rSeqLim, rSeqExpo, &m_asSLC[lChronologicSlice]) )
        return (m_CSatWatSBB.getNLSStatus()) ;
        // run the spoiler
    if(! m_SpoilSBB.run (rMrProt, rSeqLim, rSeqExpo, &m_asSLC[lChronologicSlice]) )
        return (m_SpoilSBB.getNLSStatus()) ;


    //. ---------------------------------------------------------------------------
    //. Handle RF spoiling
    //. ---------------------------------------------------------------------------

    if ( rMrProt.fastImaging().getulEnableRFSpoiling() )  {

            // This function checks whether it is the same slice that is acquired
            //  to keep the Spoilphase counter for each slice
            //  and sets dRFSpoilPhase / dRFSpoilIncrement accordingly
        lStatus = fSUVerifyRFSpoil ( rMrProt, rSeqLim, lChronologicSlice, lChronologicSlice, &m_dRFSpoilPhase, &m_dRFSpoilIncrement, &m_dRFSpoilPhasePrevSlice,
                                       &m_dRFSpoilIncrementPrevSlice, &m_dRFPrevSlicePosSag, &m_dRFPrevSlicePosCor, &m_dRFPrevSlicePosTra, &m_dRFPrevSliceNormalSag, &m_dRFPrevSliceNormalCor, &m_dRFPrevSliceNormalTra );
             // if this fails, return with Error
        OnErrorPrintAndReturn(lStatus,"fSUVerifyRFSpoiling");

            // For every RF-pulse the phase difference to the previous pulse is
            //  incremented by an increasing multiple of 50 deg
        m_dRFSpoilIncrement += RFSPOIL_INCREMENTdeg ;
        m_dRFSpoilPhase += m_dRFSpoilIncrement ;
            // keep phase smaller than 1000 * 2*Pi
        m_dRFSpoilPhase     = fmod(m_dRFSpoilPhase,     (double) RFMAXPHASEdeg);
        m_dRFSpoilIncrement = fmod(m_dRFSpoilIncrement, (double) RFMAXPHASEdeg);
        m_sADC01zSet.increasePhase(m_dRFSpoilPhase);
        m_sADC01zNeg.decreasePhase(m_dRFSpoilPhase);
        m_sSRF01zSet.increasePhase(m_dRFSpoilPhase);
        m_sSRF01zNeg.decreasePhase(m_dRFSpoilPhase);

    }




            // The following lines serve as an example of how to get rid of the
            //  strict timing table concept:
            // You can define (and calculate) the start time for any event at any time
            //  (inside the event block!)
            // For the slice sel gradient, it is easy: it shall start at t = 0
    m_sGSliSel.setStartTime ( 0 );
            // The gradient direction is well known...
    m_sGSliSel.setAxis ( SEQ::AXIS_SLICE );
            // ... but the event itself is not sent yet. (We're not in inside an event block!)
            //   The .run command you'll find near the end of this file...

            // (I admit, this example is a little bit silly, but shall demonstrate the
            //  capabilities of the event concept.
            // A more sensible example would be a spoil gradient that is sent on
            //  different gradient axis depending on some parameter
            // In the timing table, you would have to define a gradient direction,
            //  with the setAxis command you can switch them on the run.

            // Anyway, let's continue:

    //. ---------------------------------------------------------------------------
    //. Begin of event block
    //. ---------------------------------------------------------------------------
            // Now, start the RealTimeEventBlock (RTEB)
            //  It has to be initialized with a rotation matrix

    fRTEBInit(m_asSLC[lChronologicSlice].getROT_MATRIX());    /* EGA-07 */

    //- ***************************************************** S E Q U E N C E   T I M I N G *************************************
    //- *           Start Time    |    NCO    |  SRF  |  ADC  |             Gradient Events             | Sync
    //- *             (usec)      |   Event   | Event | Event |     phase    |   read     |    slice    | Event
    //- *fRTEI(                   ,           ,       ,       ,              ,            ,             ,         );
    //- ***********************************************************************************************************************
    lT=0; // Set the clock to zero

            // send the OSC bit
    fRTEI(                       0,          0,      0,      0,            0,            0,            0, &m_sOscBit);

            // send Slice Selection gradient.
            // The following line is replaced for demonstration purposes by the lines of code explained above.
            //   The gradient is sent at the correct time, but the corresponding command you'll find near the
            // end of this file (sGSliSel.run)
    //- fRTEI(                   0,          0,      0,      0,            0,            0,    &sGSliSel,       0);

            // start RF pulse so that it ends at the end of the slice sel grad
    long lStartSRFTime = m_sGSliSel.getDuration() - m_sSRF01.getDuration() ;  // calculate time
            // and send the SRF and the NCO (numerical crystal oscillator) event that ajusts the phase
    fRTEI(lStartSRFTime           ,&m_sSRF01zSet,&m_sSRF01,      0,            0,            0,            0,       0);
            // at the end of the RF pulse reset the phase
    fRTEI(lStartSRFTime+fSDSRoundUpGRT(m_sSRF01.getDuration()),
                                   &m_sSRF01zNeg,      0,      0,            0,            0,            0,       0);

            // Send the Phase encoding and Read dephaser at the end of the SliceSel flat top.
    fRTEI(lT + m_sGSliSel.getDuration()     ,  0,      0,      0,   &m_sGPhasTab, &m_sGReadDeph,             0,       0);

            // Send the slice rephaser (or 3D-slice-table) at the very end of the SliceSel gradient
    if ( rMrProt.kSpace().getucDimension() == SEQ::DIM_2 )
        fRTEI(lT+  m_sGSliSel.getTotalTime(),  0,      0,      0,            0,            0,&m_sGSliSelReph,       0);
    else
        fRTEI(lT+  m_sGSliSel.getTotalTime(),  0,      0,      0,            0,            0,     &m_sG3DTab,       0);

            // Calculate, when the Readout gradient can be started:
    lT +=  m_sGSliSel.getDuration() + m_lInterDuration + m_alTEFil[ 0];
            // At this time, kick off the Readout gradient and increase the time counter
    fRTEI(lT                     ,           0,      0,      0,            0,&m_sGradReadout,            0,       0);
            // The ADC is started just after the ramp of the RO gradient, so calculate this time and increase lT
            //  Also set the receiver phase at this time point
    fRTEI(lT+=m_sGradReadout.getRampUpTime(),
                                   &m_sADC01zSet,      0,&m_sADC01,            0,            0,            0,       0);
             // The receiver phase rewinder has to be sent at the end of the ADC.
    fRTEI(lT+m_sADC01.getRoundedDuration(),
                                   &m_sADC01zNeg,      0,      0,            0,            0,            0,       0);
            // The spoiler/rewinder start after the ADC, but must be kept on the Gradient raster time
            //  Increase counter correspondingly, to stay on the gradient raster time for (possibly) following gradients
    fRTEI(lT+=m_sADC01.getRoundedDuration(GRAD_RASTER_TIME)
                                  ,          0,      0,      0,&m_sGPhasTabRew,            0,            0,       0);
            // The duration of the event block is given by the last event
            //  Therefore, here an event at t = TR is generated
            // Note that the gradients do not necessarily need to have finished their action at the end of the
            //  event block. However, you must take care not to use more than two gradients at the same time on the same axis,
            //   whether they are in the same event block or not.
    fRTEI(m_lDurationMainEventBlock  ,          0,      0,      0,            0,           0,            0,       0);


            // Here is the .run - example continued.
            //  Since now everything about the event is know, the run procedure can be put
            //  (nearly) anywhere in the event block.
    if(! m_sGSliSel.run ())        return (m_sGSliSel.getNLSStatus()) ;

            // Run the spoilers if the 3rd check box on The Sequence/Special card is activated
    if (rMrProt.wipMemBlock().getalFree()[WIP_LowerCheckBox] == WIP_CheckBoxOn)
        {
            m_asGSpoil[Read ].setStartTime(lT);
            if(! m_asGSpoil[Read ].run ())     return (m_asGSpoil[Read ].getNLSStatus()) ;
            if ( rMrProt.kSpace().getucDimension() == SEQ::DIM_2 )
            {
                m_asGSpoil[Slice].setStartTime(lT);
                if(! m_asGSpoil[Slice].run ())     return (m_asGSpoil[Slice].getNLSStatus()) ;
            }
            else
            {
                m_sG3DTabRew.setStartTime(lT);
                if(! m_sG3DTabRew.run ()) return (m_sG3DTabRew.getNLSStatus()) ;
            }
        }

    //. ---------------------------------------------------------------------------
    //. Handle Unit test
    //. ---------------------------------------------------------------------------

            // The most crucial mSEQTest lines for the sequence unit test:
            //  Give information about the current line and slice INSIDE the event block
    if(IS_UNIT_TEST_ACTIVE(rSeqLim))
  {
    mSEQTest (rMrProt, rSeqLim, rSeqExpo, ulTestIdent    , 10, lLine,
            m_asSLC[lChronologicSlice].getSliceIndex(), 0, 0) ;
    mSEQTest (rMrProt, rSeqLim, rSeqExpo, RTEB_ClockCheck, 10, lLine,
            m_asSLC[lChronologicSlice].getSliceIndex(), 0, 0) ;
  }
            // Finally, close the Event block
    OnErrorPrintAndReturn(lStatus = fRTEBFinish(),"fRTEBFinish [*0100*]");

    //. ---------------------------------------------------------------------------
    //. End of event block
    //. ---------------------------------------------------------------------------





    return (lStatus);

}


// * -------------------------------------------------------------------------- *
// *                                                                            *
// * Name        :  FlashBack::createUI                                           *
// *                                                                            *
// * Description :  Instantiation of UI classes                                 *
// *                                                                            *
// * Return      :  NLS status                                                  *
// *                                                                            *
// * -------------------------------------------------------------------------- *



NLS_STATUS FlashBack::createUI (SeqLim&)
{

    static const char *ptModule = {"FlashBack::createUI"};

    #ifdef WIN32

        //  ----------------------------------------------------------------------
        //  Delete existing instance if necessary
        //  ----------------------------------------------------------------------
        if ( m_pUI )  {
            delete m_pUI;
            m_pUI = NULL;
        }



        //  ----------------------------------------------------------------------
        //  Instantiation of the UI class
        //  ----------------------------------------------------------------------
        try  {
            m_pUI = new FLASHBackUI();
        }

        catch (...)  {
            delete m_pUI;
            m_pUI = NULL;

            TRACE_PUT1(TC_ALWAYS, TF_SEQ,"%s: Cannot instantiate UI class !", ptModule);
            return ( SEQU_ERROR );
        }

    #endif

    return ( SEQU_NORMAL );

}   // end:FlashBack::createUI



const FLASHBackUI* FlashBack::getUI (void) const
{
    return ( m_pUI );
}



long   FlashBack::getKernelRequestsPerMeasurement(void)
{
     return (m_lKernelRequestsPerMeasurement);

}


long   FlashBack::getKernelCallsPerRelevantSignal(void)
{
      return (m_lKernelCallsPerRelevantSignal);

}

long   FlashBack::getDurationMainEventBlock(void)
{
      return (m_lDurationMainEventBlock);

}

long   FlashBack::getScanTimeAllSats(void)
{
      return (m_lScanTimeAllSats);

}

double FlashBack::getdMinRiseTime(void)
{
     return (m_dMinRiseTime);

}

double FlashBack::getdGradMaxAmpl(void)
{
      return (m_dGradMaxAmpl);
}


/*---------------------------------------------------------------------------*/
/*  Copyright (C) Siemens AG 1998  All Rights Reserved.  Confidential        */
/*---------------------------------------------------------------------------*/
