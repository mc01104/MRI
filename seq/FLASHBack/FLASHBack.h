//    -----------------------------------------------------------------------------
//      Copyright (C) Siemens AG 1998  All Rights Reserved.
//    -----------------------------------------------------------------------------
//
//     Project: NUMARIS/4
//        File: \n4_servers1\pkg\MrServers\MrImaging\seq\FLASHBack\FLASHBack.h
//     Version: \main\9
//      Author: Clinical
//        Date: 2011-09-07 11:42:33 +02:00
//
//        Lang: C++
//
//     Descrip: Deklarations for FLASHBack.cpp
//
//
/// \brief  File containing declarations for the sequences
///         - FlashBack
///         - Flash1
///
/// This file contains the declaration of the class FlashBack.
/// The sequence FlashBack and Flash1 use it to generate very nice images.
///
///     Remarks: This is the demo sequence FLASHBack.
///              DO NOT base any diagnosis on images generated by this sequence.
///
//  ***************************************************************************/
///



#ifndef FLASH_BACK_h
#define FLASH_BACK_h 1


//  --------------------------------------------------------------------------
//  General Includes
//  --------------------------------------------------------------------------
#include "MrServers/MrImaging/libSBB/StdSeqIF.h"
#include "MrServers/MrMeasSrv/MeasUtils/nlsmac.h"       // * definition of type NLS_STATUS  *
#include "ProtBasic/Interfaces/MrWipMemBlock.h"

//  --------------------------------------------------------------------------
//  Application includes
//  --------------------------------------------------------------------------

#include "MrServers/MrImaging/libSBB/SBBTSat.h"
#include "MrServers/MrImaging/seq/SystemProperties.h"        // Siemens system properties
#include "MrServers/MrImaging/libSeqSysProp/SysProperties.h"

#include  "MrServers/MrImaging/libSBB/SEQLoop.h"          // class SeqLoop




#ifdef WIN32    // VXWORKS is only defined for the MARS. In that case, no Solve handlers are needed.
#include "MrServers/MrProtSrv/MrProtocol/UILink/MrStdNameTags.h"
#include "MrServers/MrProtSrv/MrProtocol/libUILink/UILinkLimited.h"
#include "MrServers/MrProtSrv/MrProtocol/libUILink/UILinkSelection.h"
#include "MrServers/MrProtSrv/MrProtocol/libUILink/UILinkArray.h"
#include "MrServers/MrProtSrv/MrProtocol/UILink/StdProtRes/StdProtRes.h"
#include "MrServers/MrProtSrv/MrProtocol/libUICtrl/UICtrl.h"
#include "MrServers/MrMeasSrv/SeqIF/Sequence/Sequence.h" // Definition of class Sequence
#include <vector>
#endif

// ....




#ifdef BUILD_SEQU
    #define __OWNER
#endif
#include "MrCommon/MrGlobalDefinitions/ImpExpCtrl.h"


//. ----------------------------------------------------------
//. Instantiate Sequence Building Blocks (SBBs)
//. ----------------------------------------------------------
#define MAXRSATS 8
// Maximum number of allowed RSats: limited by the user interface
// given in the define K_NO_SAT_MAX in "MrServers/MrProtSrv/MrProt/prot.h"

// Instantiation of most Proxies not necessary since VB13A; relevant information is available via SysProperties

// Hints for debugging:
//   Avoid printf-statements (or cout-streams) because they are slow.
//   Use TRACE_PUT-macros instead.
//     The output will appear in the File c:\MedCom\Log\MrMeas_container.log (and MrUIBackends_container.log)
//-        TRACE_PUT1(TC_ALWAYS, TF_SEQ, "%s: initialized WIP Parameters.\n",ptModule);
//-                 ^        ^     ^                     ^                     ^
//             #parameters  when  cause                Text                parameter
//
//   Additionally, you can view the output using "MrTraceViewer(d).exe"
//
//   The TRACE_PUT macro writes also data to a log on the MARS, this log can be viewed
//    by entering "mstart mpcutracelogger" on the MRC host.
//
//-        mPrintTrace2 (DEBUG_RUN, DEBUG_CALL, "(slice=%ld, line=%ld) ", asSLC[lChronologicSlice].getSliceIndex(), lLine  ) ;
//
//   is an alternative method (calls also TRACE_PUT) but the names (DEBUG_CALL) correspond to the
//      debug bits that can be set via the IDEA "mask" command.
//


// define some constants that make the code more readable:
//   The elements on the Sequence/Special card, sorted by type (first the "long", then the "double")
enum eSeqSpecialParameters {WIP_Selection_Box = 1, WIP_UpperCheckBox, WIP_LowerCheckBox, WIP_LongParameter, WIP_Double_Array_Elm1, WIP_Double_Array_Elm2, WIP_Double_Array_Elm3 };

// The states that the SELECTION box or the checkboxes can have, is stored as an enum, too. It starts with
//  1 to avoid a zero value indicating that the parameter was not yet initialized.
enum eSeqSpecialParameterValues {WIP_SelectionBoxValue0 = 1, WIP_SelectionBoxValue1, WIP_SelectionBoxValue2, WIP_CheckBoxOn, WIP_CheckBoxOff };

// To be able to access the double paramater values getsWiPMemBlock().getadFree()[] from index 0 on,
//  a variable is defined that contains the
//  value of the first parameter card containing double values
long const lWIP_IndexDoubleValues_Start = WIP_Double_Array_Elm1;


//  --------------------------------------------------------------------------
//  Forward declarations
//  --------------------------------------------------------------------------
namespace MrProtocolData
{
class MrProtData;
}
class MrProt;
class SeqLim;
class SeqExpo;
class Sequence;




//  --------------------------------------------------------------------------
//
/// \brief <b> Class definition of FlashBack. This class is used by the sequences
///         - FlashBack
///         - Flash1    </b>
///
/// This file contains the declaration of the class FlashBack.
/// The sequence FlashBack and Flash1 use it to generate very nice images.
///
//  --------------------------------------------------------------------------

namespace SEQ_NAMESPACE
{

class FLASHBackUI;

/**
 * @brief This class is used by the sequences
 * - FlashBack
 * - Flash1
 */
class FlashBack : public StdSeqIF
{

    public:
		/**
		 * @brief Standard constructor of the FlashBack sequence object. The class members are initialized
		 * with default values.
		 */
        FlashBack();



        /**
		 * @brief Destructor of the FlashBack sequence object. The FLASHBackUI object is destructed as well.
		 */
        virtual ~FlashBack();



        //   --------------------------------------------------------------------------
        //
        //   Name        :  FlashBack::initialize
        //
        //   Description :
        ///  \brief        Initialization of the sequence
        ///
        ///                On the host, the object m_pUI will actually contain sensible
        ///                  data after FlashBack::initialize. On the measurement system, it
        ///                  is basically an empty object behind it.
        ///
        //   Return      :  NLS status
        //
        //   --------------------------------------------------------------------------
        virtual NLSStatus initialize (SeqLim &rSeqLim);



        //  --------------------------------------------------------------------------
        //
        //  Name        :  FlashBack::prepare
        //
        //  Description :
        /// \brief <b>     Preparation of the sequence during binary search and prior
        ///                 to sequence execution  </b>
        //
        //  Return      :  NLS status
        //
        //  --------------------------------------------------------------------------
        virtual NLSStatus prepare (MrProt &rMrProt, SeqLim &rSeqLim, SeqExpo &rSeqExpo);



        //  --------------------------------------------------------------------------
        //
        //  Name        :  FlashBack::check
        //
        //  Description :
        /// \brief  <b>    Check of the sequence for gradient stimulation </b>
        ///
        ///                This method is called by the framework prior to a
        ///                 measurement on the host to ensure, that
        ///                 - no gradient overflow occurs
        ///                 - the stimulation will not exceed the threshold
        ///
        //  Return      :  NLS status
        //
        //  --------------------------------------------------------------------------
        virtual NLSStatus check (MrProt  &rMrProt, SeqLim &rSeqLim, SeqExpo &rSeqExpo, SEQCheckMode *  pSEQCheckMode);


        //  --------------------------------------------------------------------------
        //
        //  Name        :  FlashBack::run
        //
        //  Description :
        ///     \brief     Execution of the sequence
        //
        //  Return      :  NLS status
        //
        //  --------------------------------------------------------------------------
        virtual NLSStatus run (MrProt &rMrProt, SeqLim &rSeqLim, SeqExpo &rSeqExpo);



        //   --------------------------------------------------------------------------
        //
        //   Name        :  FlashBack::runKernel
        //
        //   Description :
        ///  \brief <b>     Executes the basic timing of the real-time sequence.   </b>
        ///
        ///                 The method runKernel plays out a sequence "Kernel",
        ///                  consisting of one or more lines in k-Space.
        ///                 It is called by SeqLoop.
        ///
        //   Return      :  NLS status
        //
        //   --------------------------------------------------------------------------
        virtual NLS_STATUS runKernel(MrProt &rMrProt,SeqLim &rSeqLim, SeqExpo &rSeqExpo, long lKernelMode, long lSlice, long lPartition, long lLine);





        //  --------------------------------------------------------------
        //
        //  Name        :  getUI
        //
        //  Description :
        /// \brief <b>     Returns the pointer to the FlashBack UI class  </b>
        ///
        ///                This method is only sensible on the host.
        ///                On the measurement system, it will return an nearly empty object.
        ///
        //  Return      :  FLASHBackUI*
        //
        //  --------------------------------------------------------------
        const FLASHBackUI* getUI (void) const;




        //  ------------------------------------------------------------------
        //  Declare additional P U B L I C member functions, e.g. functions
        //  that will be accessed in UI handlers (outside the class).
        //  ------------------------------------------------------------------

       long   getKernelRequestsPerMeasurement(void);

       long   getKernelCallsPerRelevantSignal(void);

       long   getDurationMainEventBlock(void);

       long   getScanTimeAllSats(void);

       double getdMinRiseTime(void);

       double getdGradMaxAmpl(void);



    protected:



        //  ------------------------------------------------------------------
        ///  No of phase encoding lines with iPAT
        ///  CAUTION: This member is intended as an example and can be removed
        ///  if not required for the actual sequence
        //  ------------------------------------------------------------------
        long       m_alTEFil[K_NO_TIME_ELEMENTS]               ;
        int32_t    m_lLinesToMeasure                           ;
        long       m_lRepetitionsToMeasure                     ;
        long       m_lPhasesToMeasure                          ;
        long       m_lSlicesToMeasure                          ;
        int32_t    m_lPartitionsToMeasure                      ;
        long       m_lScanTimeAllSats                          ;
        long       m_lDurationMainEventBlock                   ;
        long       m_lKernelRequestsPerMeasurement             ;
        long       m_lKernelCallsPerRelevantSignal             ;
        long       m_lInterDuration                            ;
        long       m_lTrigHaltDuration1                        ;
        long       m_lTrigHaltDuration2                        ;

        double     m_dRFSpoilIncrement                         ;
        double     m_dRFSpoilPhase                             ;
        long       m_lMySliSelRampTime                         ;
        double     m_dMinRiseTime                              ;
        double     m_dGradMaxAmpl                              ;

            // Variables for trigger mode
        SEQ::PhysioSignal m_FirstSignal                        ;
        SEQ::PhysioMethod m_FirstMethod                        ;
        SEQ::PhysioSignal m_SecondSignal                       ;
        SEQ::PhysioMethod m_SecondMethod                       ;

         // Slice position information (rotation matrices and shifts)
        sSLICE_POS m_asSLC[K_NO_SLI_MAX]                       ;


        // These variables are needed to remember the last excited slice to use the correct rf spoil phase
        double      m_dRFSpoilPhasePrevSlice          ;       // Remember RF spoil phase of previous slice
        double      m_dRFSpoilIncrementPrevSlice      ;       // Remember RF spoil phase increment
        double      m_dRFPrevSlicePosSag              ;  // These are used to check whether we're dealing
        double      m_dRFPrevSlicePosCor              ;  // with a different slice when RF spoiling is used
        double      m_dRFPrevSlicePosTra              ;
        double      m_dRFPrevSliceNormalSag           ;
        double      m_dRFPrevSliceNormalCor           ;
        double      m_dRFPrevSliceNormalTra           ;


        //. ----------------------------------------------------------
        //. Instantiate RF Pulse objects
        //. ----------------------------------------------------------

        // every rf-pulse must (!) have an unique name
        //  (e.g. fl_Flash_ex = flash template excitation)"
        //  maximium of 12 chars
        sRF_PULSE_SINC           m_sSRF01                   ;
        // define an event that sets the transmitter phase
        sFREQ_PHASE              m_sSRF01zSet               ;
        // define an event that resets the transmitter phase
        sFREQ_PHASE              m_sSRF01zNeg              ;

        //. ----------------------------------------------------------
        //. Instantiate Gradient Pulse objects
        //. ----------------------------------------------------------

        // every gradient pulse event should have an unique name,
        // (e.g. the name of its structure)
        sGRAD_PULSE            m_sGSliSel                ;           // Slice-select pulse
        sGRAD_PULSE            m_sGReadDeph              ;
        sGRAD_PULSE            m_sGSliSelReph            ;   // Slice-select rephaser pulse
        sGRAD_PULSE            m_asGSpoil[2];                    // spoiler gradient pulse:
        // note that one can use arrays of gradient


        enum eGradientAxis            { Read, Slice, None };          // pulses and use enums to make them more readable


        // the readout gradient pulse event belongs to a different class:
        sGRAD_PULSE_RO                   m_sGradReadout     ;   // Readout gradient


        //. ----------------------------------------------------------
        //. Instantiate Gradient Table objects
        //. ----------------------------------------------------------

        // identify the type of phase encoding table
        sGRAD_PULSE_PE         m_sGPhasTab                   ; // phase encode
        sGRAD_PULSE_PE         m_sGPhasTabRew                ; // phase encode rewinder
        sGRAD_PULSE_3D         m_sG3DTab                     ; // partition encode
        sGRAD_PULSE_3D         m_sG3DTabRew                  ; // partition rewind


        //. ----------------------------------------------------------
        //. Instantiate Readout objects
        //. ----------------------------------------------------------
        // every readout event must have an unique identifier
        sREADOUT               m_sADC01                      ;
        // define an event that sets the receiver phase
        sFREQ_PHASE            m_sADC01zSet                  ;
        // define an event that undoes the receiver phase
        sFREQ_PHASE            m_sADC01zNeg                  ;

        //. ----------------------------------------------------------
        //. Instantiate Sync objects: Osc bit and triggering
        //. ----------------------------------------------------------

        sSYNC_OSC              m_sOscBit;
        sSYNC_PHYSIO1_HALT     m_sTriggerBit1;
        sSYNC_PHYSIO2_HALT     m_sTriggerBit2;


        // The SBBList connects all Sequence Building Blocks (SBBs). It therefore knows
        //  all prepulses and can pass this information e.g. to the RSatSBBs

        SBBList                m_mySBBList;

        // SeqBuildBlockTokTokTok: Gradient knocking before measurement start (intro)
        SeqBuildBlockTokTokTok m_TokTokSBB               ;
        // SeqBuildBlockRSat: Regional saturation bands
        SeqBuildBlockRSat      m_RSatSBB[MAXRSATS]       ;
        // SeqBuildBlockCSat: Chemical shift selective saturation; can saturate water or fat
        SeqBuildBlockCSat      m_CSatFatSBB              ;
        SeqBuildBlockCSat      m_CSatWatSBB              ;
        // SeqBuildBlockMSat: MTC contrast prepulse
        SeqBuildBlockMSat      m_MSatSBB                 ;
        // SeqBuildBlockTSat: Traveling Sats that follow the excited slice in a certain distance
        SeqBuildBlockTSat      m_TSatSBB                 ;
        // SeqBuildBlockSpoilGrad: Sends spoiler gradients
        SeqBuildBlockSpoilGrad m_SpoilSBB                ;




        //  ------------------------------------------------------------------
        //  Declare additionl member variables of the sequence, here.
        //
        //  Initialization should be done in the constructor of the class.
        //  Maybe, that these variables have to be deleted in the destructor.
        //  ------------------------------------------------------------------

        // ....




        //  ------------------------------------------------------------------
        //  Declare additional member functions of the sequence
        //  ------------------------------------------------------------------

        // ....




        //  --------------------------------------------------------------
        /// \brief <b> UI class for FlashBack
        ///
        ///         This class is basically empty on the measurement system
        //  --------------------------------------------------------------
        FLASHBackUI* m_pUI;




        //  ------------------------------------------------------------------
        //
        //  Name        :  FlashBack::createUI
        //
        //  Description :
        /// \brief <b>     Instantiation of UI classes   </b>
        //
        //  Return      :  NLS status
        //
        //  ------------------------------------------------------------------
        virtual NLS_STATUS createUI (SeqLim &rSeqLim);



        //  ------------------------------------------------------------------
        //
        //  Name        :  FlashBack::UnusedArg
        //
        //  Description :
        /// \brief         Used to avoid compiler warnings
        //
        //  Return      :  void
        //
        //  ------------------------------------------------------------------
        template< class TYPE > void UnusedArg (TYPE Argument) const { if( false ) { TYPE Dummy; Dummy = Argument; } };


    private:

        long run_kernel_counter;

        //  ------------------------------------------------------------------
        ///  Copy constructor not implemented
        //  ------------------------------------------------------------------
        FlashBack (const FlashBack &right);



        //  ------------------------------------------------------------------
        ///  Assignment operator not implemented
        //  ------------------------------------------------------------------
       FlashBack & operator=(const FlashBack &right);




};


}

#endif

