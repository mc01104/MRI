//    -----------------------------------------------------------------------------
//      Copyright (C) Siemens AG 1998  All Rights Reserved.
//    -----------------------------------------------------------------------------
//
//     Project: NUMARIS/4
//        File: \n4_servers1\pkg\MrServers\MrImaging\seq\FLASHBack\FLASHBack_UI.cpp
//     Version:
//      Author: Clinical
//        Date: n.a.
//
//        Lang: C++
//
//     Remarks: This is the demo sequence FLASHBack.
//              DO NOT base any diagnosis on images generated by this sequence.
//
//  ***************************************************************************/

// --------------------------------------------------------------------------
// General Includes
// --------------------------------------------------------------------------
#include "MrServers/MrMeasSrv/SeqIF/Sequence/Sequence.h"
#ifdef WIN32
    #include "MrServers/MrProtSrv/MrProtocol/UILink/MrStdNameTags.h"
#endif






//  --------------------------------------------------------------------------
//  Application includes
//  --------------------------------------------------------------------------
#include "MrServers/MrImaging/seq/FLASHBack/FLASHBack.h"
#include "MrServers/MrImaging/seq/FLASHBack/FLASHBack_UI.h"



#ifndef SEQ_NAMESPACE
    #error SEQ_NAMESPACE not defined
#endif
using namespace SEQ_NAMESPACE;



#ifdef WIN32





    //  ----------------------------------------------------------------------
    //
    //  Name        :  getSeq
    //
    //  Description :
    /// \brief         Returns the pointer to the sequence flash
    //
    //  Return      :  FlashBack*
    //
    //  ----------------------------------------------------------------------
    FlashBack* getSeq (MrUILinkBase* const pThis)
    {
        return ( static_cast<FlashBack*>(pThis->sequence().getSeq()) );
    }




    //  ----------------------------------------------------------------------
    //
    //  Name        :  getUI
    //
    //  Description :
    /// \brief         Returns the pointer to the UI class of the flash
    ///                 sequence
    //
    //  Return      :  FLASHBackUI*
    //
    //  ----------------------------------------------------------------------
    const FLASHBackUI* getUI (MrUILinkBase* const pThis)
    {
        return ( static_cast<FlashBack*>(pThis->sequence().getSeq())->getUI() );
    }




    //  --------------------------------------------------------------------------
    //  --------------------------------------------------------------------------
    //
    //                         Definition of solve handler
    //
    //  --------------------------------------------------------------------------
    //  --------------------------------------------------------------------------


   //+ [ Function ***************************************************************
   //+
   //+  Name        : fSSolveSelectionConflict
   //+
   //+  Description : Solve handler for  UI Conflicts of type Selection
   //+                    (solves with TeTrTi)
   //+  Return      :
   //+
   //+ **************************************************************************
    // In this module we solve the conflict of switching Fat suppression on while the
    //  TR is too little. The method  fUICSolveSelectionConflict  tries to solve this
    //  problem by tyring different values for TE, TR and TI.

    unsigned fSSolveSelectionConflict
        (
        LINK_SELECTION_TYPE*  const pThis,           // ...
        char**                      arg_list,       // receives confirmation message
        const void*                 pAddMem,        // for internal use
        const MrProtocolData::MrProtData*               pOrigProt,      // Original protocol with old fat suppression mode
        long                        lIndex          // Array index reserved
        )
    {
        return ( fUICSolveSelectionConflict ( pThis, arg_list, pAddMem, pOrigProt, lIndex, NULL, NULL, NULL ) );
    }



    //+  [ Function **************************************************************
    //+
    //+  Name        : fDSolveDoubleConflict
    //+
    //+  Description : Solve handler for  UI Conflicts of type double
    //+                    (solves with TeTrTi)
    //+  Return      :
    //+
    //+ **************************************************************************
    // With this module we solve the conflict of decreasing the bandwidth while
    //  TR is too little. The method  fUICSolveDoubleParamConflict  tries to solve this
    //  problem by tyring different values for TE, TR and TI.
    unsigned fDSolveDoubleConflict
        (
        LINK_DOUBLE_TYPE* const pThis,
        char**                  arg_list,  // receives confirmation message
        const void*             pAddMem,   // for internal use
        const MrProtocolData::MrProtData*           pOrigProt, // Original protocol with old bandwidth
        long                    lIndex     // Array index reserved
        )
    {
        return ( fUICSolveDoubleParamConflict ( pThis, arg_list, pAddMem, pOrigProt, lIndex, NULL, NULL, NULL ) );
    }


    //+ [ Function ****************************************************************
    //+
    //+  Name        : fBSolveFunnyModeConflict1
    //+
    //+  Description : Solve handler for demonstration of a self-written solve-handler
    //+
    //+                For some unknown reason, we do not like to have triggering and
    //+                 the TokTokTok on at the same time.
    //+                To manage this home-made conflict, we turn off triggering if the
    //+                 user selects "Introduction".
    //+                Note: To handle the other way (turn off Introduction when selecting
    //+                 triggering) one would have to write another function
    //+
    //+  Return      : 0              if no solution possible
    //+                MRI_STD_STRING on success. The text in arg_list is then used
    //+                                to format the confirmation message.
    //+ ***************************************************************************
    unsigned fBSolveFunnyModeConflict1
        (
        LINK_BOOL_TYPE* const pThis,   // ...
        char*                arg_list[],      // receives confirmation message
        const void*           /* pToAddMemory */,
        const MrProtocolData::MrProtData* /*pOrigProt*/, // Original protocol with Intro = OFF
        long                  /* lIndex  */  // Array index reserved
        )
    {

        static  const char tConfirmationText[] = "$&OK$&Undo$$Switching Introduction ON has disabled triggering";
        MrProt rNewProt (pThis->prot());     // new protocol with Intro = ON
        // const SeqLim*         pSeqLim    = &pThis->seqLimits();
        SEQ::PhysioSignal FirstSignal ;
        SEQ::PhysioMethod FirstMethod ;
        SEQ::PhysioSignal SecondSignal ;
        SEQ::PhysioMethod SecondMethod ;
        // Can we solve this problem?
        rNewProt.physiology().getPhysioMode (FirstSignal, FirstMethod, SecondSignal, SecondMethod);
        if ( (rNewProt.intro() ) &&
            (FirstMethod == SEQ::METHOD_TRIGGERING) )
        {
            // Solve it, disable triggering
            rNewProt.physiology().setPhysioMode(SEQ::SIGNAL_NONE, SEQ::METHOD_NONE, SecondSignal, SecondMethod);
            // Set the user dialog text (if arg_list exists)
            if(arg_list) arg_list[0] = (char*) tConfirmationText;
            return MRI_STD_STRING;
        }
        //  we can't solve the problem
        return 0;
    }

    //+ [ Function ****************************************************************
    //+
    //+  Name        : fBSolveFunnyModeConflict2
    //+
    //+  Description : Solve handler for demonstration of a self-written solve-handler
    //+                If we hadn't written this 2nd solve handler, only the conflict
    //+                 when trying to turn intro() on would be solved.
    //+                This handler takes care of the SELECTION-type Trigger-Mode-switch
    //+
    //+  Return      : 0              if no solution possible
    //+                MRI_STD_STRING on success. The text in arg_list is then used
    //+                                to format the confirmation message.
    //+ ***************************************************************************

    unsigned fBSolveFunnyModeConflict2
        (
        LINK_SELECTION_TYPE* const pThis,   // ...
        char*                      arg_list[],      // receives confirmation message
        const void*                /* pToAddMemory */,
        const MrProtocolData::MrProtData* /*pOrigProt*/,     // Original protocol with Intro = OFF
        long                       /* lIndex    */      // Array index reserved
        )
    {

        static  const char tConfirmationText[] = "$&OK$&Undo$$Switching triggering on will turn off Introduction";
        MrProt rNewProt (pThis->prot());     // new protocol with Trigger = ON
        // const SeqLim*         pSeqLim    = &pThis->seqLimits();
        SEQ::PhysioSignal FirstSignal ;
        SEQ::PhysioMethod FirstMethod ;
        SEQ::PhysioSignal SecondSignal ;
        SEQ::PhysioMethod SecondMethod ;
        // Can we solve this problem?
        rNewProt.physiology().getPhysioMode (FirstSignal, FirstMethod, SecondSignal, SecondMethod);
        if ( (rNewProt.intro() ) &&
            (FirstMethod == SEQ::METHOD_TRIGGERING) )
        {
            // Solve it, disable TokTokTok
            rNewProt.intro(false);
            // Set the user dialog text (if arg_list exists)
            if(arg_list) arg_list[0] = (char*) tConfirmationText;
            return MRI_STD_STRING;
        }
        //  we can't solve the problem
        return 0;
    }







//. -------------------------------------------------------------------------------
//. User defined UI parameters on Sequence/Special
//. -------------------------------------------------------------------------------
// The following code is only used to create sequence-specific dialogs on the
//  Parameter card Sequence/Special. As example, two check boxes, a selection
//  box, a box for long values, and a box containing an array of doubles
//  are created. The corresponding functions are
//  named _WIP_... to indicate that these functions can be used to create
//  Works-In-Progress applications.
// The information contained in these new parameters can be put into the
//  pMrProt->getsWiPMemBlock().getalFree()[]-array (for long values) or
//  pMrProt->getsWiPMemBlock().getadFree()[]-array (for double values)
//
// The general UI concept is:
//  - define the functions needed
//  - fSEQInit: Register them with the user interface (like the solve handlers)
//  - fSEQPrep: Initialize the values by forcing a ContextPrepForMrProtUpdate


// The array of the double values needs some global variables
    long const lWIP_IndexDoubleArray_Start = WIP_Double_Array_Elm1;
    long const lWIP_IndexDoubleArray_End   = WIP_Double_Array_Elm3;


//+ [ Function ****************************************************************
        //+  Name        : _WIP_SELECTION_GetLabelId
        //+  Description : Selects the text to be placed in front of selection boxes
        //+ ***************************************************************************

        unsigned _WIP_SELECTION_GetLabelId(LINK_SELECTION_TYPE* const /* pThis */, char* arg_list[], long lIndex)
        {
            static const char pszLabelSelectionBox[] = "Selection box";
            static const char pszInvalid[]           = "Invalid";

            switch (lIndex)
            {
            case WIP_Selection_Box : arg_list[0] = (char*) pszLabelSelectionBox; break;
            default                : arg_list[0] = (char*) pszInvalid          ; break;
            }

            return MRI_STD_STRING;
        }


        //+ [ Function ****************************************************************
        //+  Name        : _WIP_SELECTION_Format
        //+  Description : Selects the text of the alternatives in the selection boxes
        //+ ***************************************************************************

        int _WIP_SELECTION_Format(LINK_SELECTION_TYPE* const /* pThis */, unsigned nID, char* arg_list[], long lIndex)
        {
            unsigned uVal = GET_MODIFIER(nID);

            if (lIndex == WIP_Selection_Box)
            {
                switch(uVal)
                {
                case WIP_SelectionBoxValue0: arg_list[0] = (char*) pszFirstChoiceTextInSelectionBox ; break;
                case WIP_SelectionBoxValue1: arg_list[0] = (char*) pszSecondChoiceTextInSelectionBox; break;
                case WIP_SelectionBoxValue2: arg_list[0] = (char*) pszLastChoiceTextInSelectionBox  ; break;
                }
            }

            return 1;
        }

        //+ [ Function ****************************************************************
        //+  Name        : _WIP_SELECTION_GetValue
        //+  Description : Get the value of the selection box with ID lIndex
        //+ ***************************************************************************

        unsigned _WIP_SELECTION_GetValue(LINK_SELECTION_TYPE* const pThis, long lIndex)
        {
            unsigned nRet = MRI_STD_STRING;
            SET_MODIFIER(nRet, (unsigned char) (pThis->prot().getsWipMemBlock().getalFree()[lIndex]));
            return nRet;
        }

        //+ [ Function ****************************************************************
        //+  Name        : _WIP_SELECTION_GetOptions
        //+  Description : Get the possible options of Selection box with ID lIndex
        //+ ***************************************************************************

        bool _WIP_SELECTION_GetOptions(LINK_SELECTION_TYPE* const /* pThis */ , std::vector<unsigned>& rOptionVector, unsigned long& rulVerify, long lIndex)
        {
            if (lIndex == WIP_Selection_Box)
            {
                rulVerify = LINK_SELECTION_TYPE::VERIFY_ON;
                rOptionVector.resize(3);
                for (long lI=0; lI<3; lI++) {rOptionVector[lI] = MRI_STD_STRING;};

                SET_MODIFIER(rOptionVector[0],WIP_SelectionBoxValue0);
                SET_MODIFIER(rOptionVector[1],WIP_SelectionBoxValue1);
                SET_MODIFIER(rOptionVector[2],WIP_SelectionBoxValue2);

                return true;
            } else return false;
        }

        //+ [ Function ****************************************************************
        //+  Name        : _WIP_SELECTION_SetValue
        //+  Description : Set a specified value to the selection box lIndex
        //+ ***************************************************************************

        unsigned _WIP_SELECTION_SetValue(LINK_SELECTION_TYPE* const pThis, unsigned nNewVal, long lIndex)
        {
            pThis->prot().getsWipMemBlock().getalFree()[lIndex]=GET_MODIFIER(nNewVal);

            return pThis->value(lIndex);
        }

        //+ [ Function ****************************************************************
        //+  Name        : _WIP_SELECTION_Solve
        //+  Description : The solve handler for the selection box
        //+ ***************************************************************************

        unsigned _WIP_SELECTION_Solve(LINK_SELECTION_TYPE* const pThis, char* arg_list[], const void* pVoid, const MrProt &rMrProt, long lIndex)
        {
            return fSSolveSelectionConflict(pThis,arg_list,pVoid,rMrProt,lIndex);
        }

        //
        // Here are the coresponding functions for the check boxes in the
        //  Sequence/Special card
        //

        //+ [ Function ****************************************************************
        //+  Name        : _WIP_CheckBox_GetLabelId
        //+  Description : Selects the text to be placed in front of checkboxes
        //+ ***************************************************************************

        unsigned _WIP_CheckBox_GetLabelId(LINK_BOOL_TYPE* const, char* arg_list[], long lIndex)
        {
            static const char* const pszLabel0    = "Online ICE  ";
            static const char* const pszLabel1    = "Spoil me!   ";
            static const char* const pszLabelHaeh = "NotSupported";

            switch(lIndex)
            {
            case WIP_UpperCheckBox  : arg_list[0] = (char*)pszLabel0   ; break;
            case WIP_LowerCheckBox  : arg_list[0] = (char*)pszLabel1   ; break;
            default                 : arg_list[0] = (char*)pszLabelHaeh; break;
            }
            return MRI_STD_STRING;
        }

        //. --------------------------------------------------------
        //. Implementation of UI functions for the check boxes
        //. --------------------------------------------------------


        //+ [ Function ****************************************************************
        //+  Name        : _WIP_CheckBox_GetOptions
        //+  Description : Defines the alternatives for the check box  (true/false)
        //+ ***************************************************************************

        bool _WIP_CheckBox_GetOptions(LINK_BOOL_TYPE* const /*pThis*/ , std::vector<unsigned>& rOptionVector, unsigned long& rulVerify, long /*lIndex*/)
        {
            rulVerify = LINK_BOOL_TYPE::VERIFY_ON;
            rOptionVector.resize(2);
            rOptionVector[0] = false;
            rOptionVector[1] = true;
            return true;
        }

        //+ [ Function ****************************************************************
        //+  Name        : _CheckBox_GetValue
        //+  Description : Get the current value from checkbox lIndex
        //+ ***************************************************************************

        bool _WIP_CheckBox_GetValue(LINK_BOOL_TYPE* const pThis , long lIndex)
        {
            return pThis->prot().getsWipMemBlock().getalFree()[lIndex] != WIP_CheckBoxOff;
        }

        //+ [ Function ****************************************************************
        //+  Name        : _WIP_CheckBox_SetValue
        //+  Description : Set a value in checkbox lIndex
        //+ ***************************************************************************

        bool _WIP_CheckBox_SetValue(LINK_BOOL_TYPE* const pThis, bool value, long lIndex)
        {
            switch(lIndex)
            {
            case WIP_UpperCheckBox  :
            case WIP_LowerCheckBox  :
                if (value)
                {
                    pThis->prot().getsWipMemBlock().getalFree()[lIndex] = WIP_CheckBoxOn;
                } else {
                    pThis->prot().getsWipMemBlock().getalFree()[lIndex] = WIP_CheckBoxOff;
                }
                return true;
            default : break;
            }
            return false;
        }

        //. --------------------------------------------------------
        //. Implementation of UI functions for a 'long' UI field
        //. --------------------------------------------------------


        //+ [ Function ****************************************************************
        //+  Name        : _WIP_LONG_GetLabelId
        //+  Description : Defines the text in front of the box for long values
        //+ ***************************************************************************

        unsigned _WIP_LONG_GetLabelId(LINK_LONG_TYPE* const, char* arg_list[], long lIndex)
        {
            static const char* const pszLabel0    = "Test Time";
            static const char* const pszLabelHaeh = "NotSupported";

            switch(lIndex) // depending on the Index of available boxes give them a name
            {
            case WIP_LongParameter : arg_list[0] = (char*)pszLabel0   ; break;
            default                : arg_list[0] = (char*)pszLabelHaeh; break;
            }
            return MRI_STD_STRING;
        }

        //+ [ Function ****************************************************************
        //+  Name        : _WIP_LONG_GetUnitId
        //+  Description : Defines the text behind the box for long values
        //+ ***************************************************************************

        unsigned _WIP_LONG_GetUnitId(LINK_LONG_TYPE* const, char* arg_list[], long lIndex)
        {
            static const char* const pszLabel0    = "ms";
            static const char* const pszLabelHaeh = "NotSupported";

            // depending on the Index of available long boxes, set the correct text behind them
            switch(lIndex)
            {
            case WIP_LongParameter : arg_list[0] = (char*)pszLabel0   ; break;
            default                : arg_list[0] = (char*)pszLabelHaeh; break;
            }
            return MRI_STD_STRING;
        }

        //+ [ Function ****************************************************************
        //+  Name        : _WIP_LONG_GetValue
        //+  Description : Get the long value entered in the box
        //+ ***************************************************************************

        long _WIP_LONG_GetValue(LINK_LONG_TYPE* const pThis, long lIndex)
        {
            return pThis->prot().getsWipMemBlock().getalFree()[lIndex];
        }

        long _WIP_LONG_SetValue(LINK_LONG_TYPE* const pThis, long value, long lIndex)
        {
            return (pThis->prot().getsWipMemBlock().getalFree()[lIndex] = value);
        }

        //+ [ Function ****************************************************************
        //+  Name        : _WIP_LONG_GetLimits
        //+  Description : Defines the valid range of the long parameter
        //+ ***************************************************************************

        bool _WIP_LONG_GetLimits(LINK_LONG_TYPE* const /* pThis */, std::vector<MrLimitLong>& rLimitVector, unsigned long& rulVerify, long lIndex)
        {
            long lMin, lMax, lInc;

            switch(lIndex) // depending on the index of available long boxes, define a
            {              //  range for valid values.
            case WIP_LongParameter  : lMin= 10 ; lMax=   2000; lInc=1; break;
            default                 : lMin= 0  ; lMax=      0; lInc=1; break;
            }

            rulVerify = LINK_LONG_TYPE::VERIFY_BINARY_SEARCH;
            rLimitVector.resize(1);
            rLimitVector[0].setEqualSpaced(lMin,lMax,lInc);
            return true;
        }

        //. -------------------------------------------------------------------------------
        //. Tooltips for user defined UI parameters on Sequence/Special
        //. -------------------------------------------------------------------------------

        // It is possible to have tooltips appearing at the dialog elements,
        //  this is demonstrated below.
        // Note that this can be used to pass dynamic information to the user.

        //+ [ Function ****************************************************************
        //+  Name        : _WIP_SELECTION_GetToolTipId
        //+  Description : Searches for the correct tool tip text for selection boxes
        //+ ***************************************************************************

        unsigned _WIP_SELECTION_GetToolTipId(LINK_SELECTION_TYPE* const pThis, char* arg_list[], long lIndex)
        {
            static char tLine[64];
            static char tToolTip[1000];

            tToolTip[0] = '\0';
            MrProt rMrProt (pThis->prot());
            if (lIndex == WIP_Selection_Box)
            {
                MrProt rMrProt (pThis->prot());

                const SeqExpo &rSeqExpo = pThis->sequence().getSEQ_BUFF()->getSeqExpo();

                // prepare protocol to have access to pSeqExpo
                if( !pThis->sequence().prepareForBinarySearch(rMrProt) )
                {
                    //  Can't prepare current protocol-this should never happen
                    std::cout << "Unexpected ERROR" << std::endl;
                    return 0;
                }


                // Now add all the text you want to tToolTip ...
                sprintf(tLine,"You can see: This is a selection box"); strcat(tToolTip,tLine);
                long lLinesToMeasure = rSeqExpo.getMeasuredPELines();
                sprintf(tLine,"\nUseful information: "); strcat(tToolTip,tLine);
                sprintf(tLine,"\nLines to measure       \t=\t%ld" ,lLinesToMeasure); strcat(tToolTip,tLine);
                long lPartitionsToMeasure = rSeqExpo.getMeasured3dPartitions();
                sprintf(tLine,"\nPartitions to measure  \t=\t%ld" ,lPartitionsToMeasure); strcat(tToolTip,tLine);
                sprintf(tLine,"\nkSpace().echoLine()    \t=\t%ld" ,rMrProt.kSpace().echoLine()); strcat(tToolTip,tLine);
                sprintf(tLine,"\nkSpace().echoPartition()\t=\t%ld" ,rMrProt.kSpace().echoPartition()); strcat(tToolTip,tLine);
                sprintf(tLine,"\nlScanTimeAllSats       \t=\t%ld" , getSeq(pThis)->getScanTimeAllSats()); strcat(tToolTip,tLine);
                sprintf(tLine,"\nlDurationMainEventBlock\t=\t%ld" , getSeq(pThis)->getDurationMainEventBlock()); strcat(tToolTip,tLine);
                sprintf(tLine,"\nlKernelRequestsPerMeasurement \t=\t%ld" ,getSeq(pThis)->getKernelRequestsPerMeasurement()); strcat(tToolTip,tLine);
                sprintf(tLine,"\nlKernelCallsPerRelevantSignal \t=\t%ld" ,getSeq(pThis)->getKernelCallsPerRelevantSignal()); strcat(tToolTip,tLine);
                sprintf(tLine,"\ndMinRiseTime \t=\t%f" ,getSeq(pThis)->getdMinRiseTime()); strcat(tToolTip,tLine);
                sprintf(tLine,"\ndGradMaxAmpl \t=\t%f" ,getSeq(pThis)->getdGradMaxAmpl()); strcat(tToolTip,tLine);




                arg_list[0] = tToolTip;
                return MRI_STD_STRING;  // return this to signal that arg_list is a text to be printed
            }
            return 0;
        }

        //+ [ Function ****************************************************************
        //+  Name        : _WIP_CheckBox_GetToolTipId
        //+  Description : Searches for the correct tool tip text for CheckBoxes
        //+ ***************************************************************************


        unsigned _WIP_CheckBox_GetToolTipId(LINK_BOOL_TYPE* const pThis, char* arg_list[], long lIndex)
        {
            static char tLine    [100];
            static char tToolTip[1000];
            MrProt rMrProt (pThis->prot());

            tToolTip[0] = '\0';

            switch (lIndex)
            {
            case WIP_UpperCheckBox :
                sprintf(tLine,"You can see: This is a check box"); strcat(tToolTip,tLine);
                sprintf(tLine,"\nUseful information:"); strcat(tToolTip,tLine);
                if (rMrProt.wipMemBlock().getalFree()[WIP_UpperCheckBox] == WIP_CheckBoxOn)
                    sprintf(tLine,"\nCurrently this check box is SELECTED - online ICE" );
                else
                    sprintf(tLine,"\nCurrently this check box is deselected - offline ICE" );

                strcat(tToolTip,tLine);
                arg_list[0] = tToolTip;
                return MRI_STD_STRING;
                break;

            case WIP_LowerCheckBox :
                sprintf(tLine,"A spoiler a day"); strcat(tToolTip,tLine);
                sprintf(tLine,"\nKeeps the doctor away"); strcat(tToolTip,tLine);
                sprintf(tLine,"\nIf selected, spoiler gradients are used" ); strcat(tToolTip,tLine);
                arg_list[0] = tToolTip;
                return MRI_STD_STRING;
                break;

            default : break;
            }

            return 0;
        }

        //+ ***************************************************************************
        //+ The array of double values in the Sequence/Special card

        //+  _WIP_DOUBLE_ARRAY_MAXSize
        //+  Description : returns the maximum array size of the double array box

        long _WIP_DOUBLE_ARRAY_MAXSize(MrUILinkArray* const, long)
        {
            return lWIP_IndexDoubleArray_End-lWIP_IndexDoubleArray_Start+1;
        }

        //+  _WIP_DOUBLE_ARRAY_CurrentSize
        //+  Description : returns the current array size of the double array box

        long _WIP_DOUBLE_ARRAY_CurrentSize(MrUILinkArray* const, long)
        {
            return lWIP_IndexDoubleArray_End-lWIP_IndexDoubleArray_Start+1;
        }


        //+  return the label of the double array box

        unsigned _WIP_DOUBLE_ARRAY_GetLabelId(LINK_DOUBLE_TYPE* const, char* arg_list[], long lIndex)
        {
            static const char* const pszDouble1 = "dARRAY";
            static char tLine[100];
            sprintf(tLine,"%s [%ld]",pszDouble1,lIndex+1);
            arg_list[0] = tLine;
            return MRI_STD_STRING;
        }
        //+  return the unit of the double array box

        unsigned _WIP_DOUBLE_ARRAY_GetUnitId(LINK_DOUBLE_TYPE* const, char* arg_list[], long)
        {
            static const char* const pszDouble1 = "[UnitArr]";
            arg_list[0] = (char*) pszDouble1;
            return MRI_STD_STRING;
        }

        //+  return, whether double array box is visible
        bool _WIP_DOUBLE_ARRAY_IsAvailable(LINK_DOUBLE_TYPE* const /* pThis */, long)
        {
            return true;
        }

        //+  Define the limits for the values in the double array box
        bool _WIP_DOUBLE_ARRAY_GetLimits(LINK_DOUBLE_TYPE* const /* pThis */, std::vector<MrLimitDouble>& rLimitVector, unsigned long& rulVerify, long lIndex)
        {
            double dMin, dMax, dInc;

            switch(lIndex)
            {
            case  0: dMin= 1.0 ; dMax=  10.0; dInc=0.100; break;
            case  1: dMin=10.0 ; dMax=  20.0; dInc=0.200; break;
            case  2: dMin=20.0 ; dMax=  40.0; dInc=0.250; break;
            default: dMin= 0.0 ; dMax=   0.0; dInc=1.000; break;
            }

            rulVerify = LINK_DOUBLE_TYPE::VERIFY_BINARY_SEARCH;

            rLimitVector.resize(1);
            rLimitVector[0].setEqualSpaced(dMin,dMax,dInc);
            return true;
        }

        //+  return the current value in the double array box
        double _WIP_DOUBLE_ARRAY_GetValue(LINK_DOUBLE_TYPE* const pThis, long lIndex)
        {
            if (lIndex < lWIP_IndexDoubleArray_End-lWIP_IndexDoubleArray_Start+1)
            {
                return pThis->prot().getsWipMemBlock().getadFree()[lWIP_IndexDoubleArray_Start-lWIP_IndexDoubleValues_Start+lIndex];
            }
            else
            {
                return -1.0;
            }
        }

        //+  set the current value in the double array box
        double _WIP_DOUBLE_ARRAY_SetValue(LINK_DOUBLE_TYPE* const pThis, double value, long lIndex)
        {
            if (lIndex < lWIP_IndexDoubleArray_End-lWIP_IndexDoubleArray_Start+1)
            {
                return (pThis->prot().getsWipMemBlock().getadFree()[lWIP_IndexDoubleArray_Start-lWIP_IndexDoubleValues_Start+lIndex] = value);
            }
            else
            {
                return -1.0;
            }
        }

        //+  define Solve Handlers (though here not needed) for the double array box
        
        unsigned _WIP_DOUBLE_ARRAY_Solve(LINK_DOUBLE_TYPE* const pThis, char* arg_list[], const void* pVoid, const MrProtocolData::MrProtData* pOrigProt, long lIndex)
        {
            return fUICSolveDoubleParamConflict(pThis,arg_list,pVoid,pOrigProt,lIndex,NULL,NULL,NULL);
        }

        //+  give the ToolTip text for the double array box
        unsigned _WIP_DOUBLE_ARRAY_GetToolTipId(LINK_DOUBLE_TYPE* const /* pThis */, char* arg_list[], long lIndex)
        {
            static char tLine    [100];
            static char tToolTip[1000];

            tToolTip[0] = '\0';

            if (lIndex < lWIP_IndexDoubleArray_End-lWIP_IndexDoubleArray_Start+1)
            {
                sprintf(tLine,"tooltip for double array element %ld",lIndex+1);
                strcat(tToolTip,tLine);

                arg_list[0] = tToolTip;
                return MRI_STD_STRING;
            }

            return 0;
        }

#endif


    ///  \brief Constructor
    ///
    FLASHBackUI::FLASHBackUI(){}


    ///  \brief Destructor
    ///
    FLASHBackUI::~FLASHBackUI(){}




    //  --------------------------------------------------------------------------
    //
    //  Name        : registerUI
    //
    //  Description :
    /// \brief        This method registers all given set / get / Solve - handlers
    ///
    ///               It can be executed on the measuement system, too, but is empty there.
    ///
    ///
    ///               It returns an NLS status
    ///
    //  Return      : long
    //
    //  --------------------------------------------------------------------------

    NLS_STATUS FLASHBackUI::registerUI (SeqLim &rSeqLim)
    {

        static const char * const ptModule = {"FLASHBackUI::registerUI"};

        char tMrTag[64];

#ifdef WIN32

          fStdImagingInitPost (rSeqLim);

            // ----------------------------------------------------------------------------------
            // Registration of set handler methods
            //
            //                                           parameter tag     new handler function
            // ----------------------------------------------------------------------------------




            // ----------------------------------------------------------------------------------
            // Registration of solve handler methods
            //
            //                                        parameter tag         new handler function
            // ----------------------------------------------------------------------------------
        //char tMrTag[sizeof(MR_TAG_BANDWIDTH)+3];
        sprintf (tMrTag, "%s.0\0", MR_TAG_BANDWIDTH );
        m_bandwidth.registerSolveHandler   (rSeqLim, tMrTag                  ,         fDSolveDoubleConflict    );
        m_fatSuppres.registerSolveHandler (rSeqLim, MR_TAG_FAT_SUPPRESSION   ,         fSSolveSelectionConflict );
        m_TriggerTok.registerSolveHandler (rSeqLim, MR_TAG_INTRO             ,         fBSolveFunnyModeConflict1);
        m_TokTrigger.registerSolveHandler (rSeqLim, MR_TAG_FIRST_SIGNAL_MODE ,         fBSolveFunnyModeConflict2);



    // only necessary for non-MPCU- processors, since this UI stuff
        //  will only run on the host computer

        //. -----------------------------------------------------------------------------
        //. Register Sequence/Special card parameters
        //. -----------------------------------------------------------------------------

        // Now register the dialog boxes on the sequence/Special card with
        //  the user interface
        if (LINK_SELECTION_TYPE* pSelection = _create< LINK_SELECTION_TYPE >(rSeqLim, MR_TAG_SEQ_WIP2, WIP_Selection_Box))
        {       //    this is for the selection box  (Type LINK_SELECTION)                    //    ^ this defines the position on the card
            pSelection->registerGetLabelIdHandler  (_WIP_SELECTION_GetLabelId);
            pSelection->registerGetOptionsHandler  (_WIP_SELECTION_GetOptions);
            pSelection->registerGetValueHandler    (_WIP_SELECTION_GetValue);
            pSelection->registerSetValueHandler    (_WIP_SELECTION_SetValue);
            pSelection->registerFormatHandler      (_WIP_SELECTION_Format);
            pSelection->registerGetToolTipIdHandler(_WIP_SELECTION_GetToolTipId);
        }

        if (LINK_BOOL_TYPE* pBool = _create< LINK_BOOL_TYPE >(rSeqLim, MR_TAG_SEQ_WIP1, WIP_UpperCheckBox))
        {       // This is the upper checkbox of type BOOL
            pBool->registerGetLabelIdHandler  (_WIP_CheckBox_GetLabelId);
            pBool->registerGetOptionsHandler  (_WIP_CheckBox_GetOptions);
            pBool->registerGetValueHandler    (_WIP_CheckBox_GetValue);
            pBool->registerSetValueHandler    (_WIP_CheckBox_SetValue);
            pBool->registerGetToolTipIdHandler(_WIP_CheckBox_GetToolTipId);
        }

        if (LINK_BOOL_TYPE* pBool = _create< LINK_BOOL_TYPE >(rSeqLim, MR_TAG_SEQ_WIP4, WIP_LowerCheckBox))
        {       // This is the lower checkbox of type BOOL
            pBool->registerGetLabelIdHandler  (_WIP_CheckBox_GetLabelId);
            pBool->registerGetOptionsHandler  (_WIP_CheckBox_GetOptions);
            pBool->registerGetValueHandler    (_WIP_CheckBox_GetValue);
            pBool->registerSetValueHandler    (_WIP_CheckBox_SetValue);
            pBool->registerGetToolTipIdHandler(_WIP_CheckBox_GetToolTipId);
        }


        if (LINK_LONG_TYPE* pLong = _create< LINK_LONG_TYPE >(rSeqLim, MR_TAG_SEQ_WIP5, WIP_LongParameter))
        {       // This is a box that allows to enter LONG values
            pLong->registerGetLabelIdHandler  (_WIP_LONG_GetLabelId);
            pLong->registerGetUnitIdHandler   (_WIP_LONG_GetUnitId);
            pLong->registerGetValueHandler    (_WIP_LONG_GetValue);
            pLong->registerSetValueHandler    (_WIP_LONG_SetValue);
            pLong->registerGetLimitsHandler   (_WIP_LONG_GetLimits);
        }

        // here is the registration of the array of double parameters
        LINK_DOUBLE_TYPE* pDoubleElm = NULL;
        if( MrUILinkArray* pDoubleArray = _createArray<LINK_DOUBLE_TYPE>(rSeqLim,MR_TAG_SEQ_WIP11,_WIP_DOUBLE_ARRAY_MAXSize,pDoubleElm) )
        {
            pDoubleArray->registerSizeHandler(_WIP_DOUBLE_ARRAY_CurrentSize);

            pDoubleElm->registerGetLabelIdHandler  (_WIP_DOUBLE_ARRAY_GetLabelId  );
            pDoubleElm->registerGetUnitIdHandler   (_WIP_DOUBLE_ARRAY_GetUnitId   );
            pDoubleElm->registerIsAvailableHandler (_WIP_DOUBLE_ARRAY_IsAvailable );
            pDoubleElm->registerGetLimitsHandler   (_WIP_DOUBLE_ARRAY_GetLimits   );
            pDoubleElm->registerGetValueHandler    (_WIP_DOUBLE_ARRAY_GetValue    );
            pDoubleElm->registerSetValueHandler    (_WIP_DOUBLE_ARRAY_SetValue    );
            pDoubleElm->registerSolveHandler       (_WIP_DOUBLE_ARRAY_Solve       );
            pDoubleElm->registerGetToolTipIdHandler(_WIP_DOUBLE_ARRAY_GetToolTipId);
        }


        // file containing the default postprocessing protocol (EVAProtocol)
        //  The corresponding card in the UI is activated via setApplicationCard() in fSEQPrep

        rSeqLim.setDefaultEVAProt (_T("%SiemensEvaDefProt%\\Inline\\Inline.evp"));

#endif

        return ( SEQU__NORMAL );

    }





