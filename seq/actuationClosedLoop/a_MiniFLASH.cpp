//-----------------------------------------------------------------------------
//  Copyright (C) Siemens AG 1998-2006  All Rights Reserved.  Confidential
//-----------------------------------------------------------------------------
//
// Project: NUMARIS/4
//
//    File: \n4\pkg\MrServers\MrImaging\seq\a_MiniFLASH\a_MiniFLASH.cpp
//
// Authors: Mark Brown;       SMS MED US CSG TDC;
//          Brian Dale;       SMS MED US CSG MR R&D;
//          Wolfgang Rehwald; SMS MED US CSG MR R&D;
//          Keith Heberlein;  SMS MED US CSG MR R&D;
//
//          Original Author:  Anonymous
//
//    Lang: C++
//
// Descrip: This is the demo sequence MiniFLASH.
//          DO NOT base any diagnosis on images generated by this sequence.
//
//////////////////////////////////////////////////////////////////////////////////////////
//
//                                MiniFLASH Sequence Diagram
//
//                       |-----------TE-------------|
//
//              RF --|sSRF01|--------------------------------------------
//
//              Gs -|sGSliSel|-|sGSliSelReph|-------------|sGSpoil|------
//
//              Gp ----------|sGPhasEnc|------------------|sGPhasEncRew|-
//
//              Gr ----------|sGReadDeph|-------|sGradRO|----------------
//
//             ADC -----------------------------|sADC01|-----------------
//
//                |------------------------------TR----------------------|
//
///////////////////////////////////////////////////////////////////////////////////////////

#include "MrServers/MrImaging/seq/actuationClosedLoop/a_MiniFLASH.h"
#include "MrServers/MrImaging/seq/common/feedbackData.h"
#include "MrServers/MrImaging/seq/actuationClosedLoop/a_MiniFLASH_UI.h"
#include "MrServers/MrMeasSrv/SeqIF/csequence.h"
#include "MrServers/MrImaging/libSeqSysProp/SysProperties.h"
#include "MrServers/MrImaging/seq/SystemProperties.h"        // Siemens system properties
#include "MrServers/MrImaging/ut/libsequt.h"                 // for mSEQTest

#ifdef WIN32
    #include "MrServers/MrMeasSrv/SeqIF/Sequence/Sequence.h"
    #include <iostream>
    #include <fstream>
	using namespace std;
#endif

//#include <iostream>
// Macro: return S, if S is an error code
// (applies to functions returning MRRESULT-values)
#define OnErrorReturn(S) if(!MrSucceeded(S)) return(S)


#ifndef SEQ_NAMESPACE
    #error SEQ_NAMESPACE not defined
#endif



//  --------------------------------------------------------------------------
//
//  Name        :  SEQIF_DEFINE
//
//  Description :
///  \brief        Create instance of the sequence
//
//  Return      :  SeqIF *
//
//  --------------------------------------------------------------------------
#ifdef SEQUENCE_CLASS_MiniFLASH
    SEQIF_DEFINE (SEQ_NAMESPACE::MiniFlash)
#endif
using namespace SEQ_NAMESPACE;
using namespace WPT_NAMESPACE;

double gThetaFinal1;
//double gThetaFinal2;
double gK1;
double gK2;
double gtMeas;
double gtRTFeedBack;
double gtRTFeedBack2;
double g_theta = 0.0;
double g_deltaTheta = 2*M_PI;
double g_time_sin = 0.0;

#ifdef WIN32
	const uint16_t CAPACITY = 10000;
	double g_gradValuesHistory[CAPACITY] = {0};
	uint16_t g_gradIndex = 0;
	fstream g_fileID;
#endif




MiniFlash::MiniFlash()
        : m_sGActuateX          ("sGActuateX")
		, m_sGActuateY          ("sGActuateY")
		, m_sGActuateZ          ("sGActuateZ")
		, m_sWakeUp             ("sWakeUp")
		, m_sSRF01				("sSRF01")
		, m_sSRF01zSet          ("sSRF01zSet")
		, m_sSRF01zNeg			("sSRF01zNeg")
		, m_sSRF02				("sSRF02")
		, m_sSRF02zSet          ("sSRF02zSet")
		, m_sSRF02zNeg			("sSRF02zNeg")
		, m_sSRF01OffsetNegative     ("sSRF01OffsetNegative")
		, m_sSRF01zSetOffsetNegative ("sSRF01zSetOffsetNegative")
		, m_sSRF01zNegOffsetNegative ("sSRF01zNegOffsetNegative")
		, m_sSRF01OffsetPositive     ("sSRF01OffsetPositive")
		, m_sSRF01zSetOffsetPositive ("sSRF01zSetOffsetPositive")
		, m_sSRF01zNegOffsetPositive ("sSRF01zNegOffsetPositive")
		, m_sSRF02OffsetNegative     ("sSRF02OffsetNegative")
		, m_sSRF02zSetOffsetNegative ("sSRF02zSetOffsetNegative")
		, m_sSRF02zNegOffsetNegative ("sSRF02zNegOffsetNegative")
		, m_sSRF02OffsetPositive     ("sSRF02OffsetPositive")
		, m_sSRF02zSetOffsetPositive ("sSRF02zSetOffsetPositive")
		, m_sSRF02zNegOffsetPositive ("sSRF02zNegOffsetPositive")
		, m_sSRFActiveMarker         ("m_sSRFActiveMarker")
		, m_sSRFzSetActiveMarker     ("m_sSRF02zSetActiveMArker")
		, m_sSRFzNegActiveMarker     ("m_sSRF02zNegActiveMarker")
		, m_sSRFActiveMarkerRefocus  ("m_sSRFActiveMarkerRefocus")
		, m_sSRFzSetActiveMarkerRefocus("m_sSRFzSetActiveMarkerRefocus")
		, m_sSRFzNegActiveMarkerRefocus("m_sSRFzNegActiveMarkerRefocus")
		, m_sADCX				("sADCX")
		, m_sADCX_zSet			("sADCX_zSet")
		, m_sADCX_zNeg			("sADCX_zNeg")
		, m_sADCY				("sADCY")
		, m_sADCY_zSet			("sADCY_zSet")
		, m_sADCY_zNeg			("sADCY_zNeg")
		, m_sADCZ				("sADCZ")
		, m_sADCZ_zSet			("sADCZ_zSet")
		, m_sADCZ_zNeg			("sADCZ_zNeg")
		, m_sADCCom             ("sADCCom")
		, m_sADCCom_zSet        ("sADCCom_zSet")
		, m_sADCCom_zNeg        ("sADCCom_zNeg")
		, m_sADCCom2            ("sADCCom2")
		, m_sADCCom2_zSet       ("sADCCom2_zSet")
		, m_sADCCom2_zNeg       ("sADCCom2_zNeg")
		, m_sADCXCapusle        ("sADCXCapusle")
		, m_sADCX_zSetCapusle   ("sADCX_zSetCapusle")
		, m_sADCX_zNegCapusle   ("sADCX_zNegCapusle")
		, m_sADCYCapusle        ("sADCYCapusle")
		, m_sADCY_zSetCapusle   ("sADCY_zSetCapusle")
		, m_sADCY_zNegCapusle   ("sADCY_zNegCapusle")
		, m_sADCZCapusle        ("sADCZCapusle")
		, m_sADCZ_zSetCapusle   ("sADCZ_zSetCapusle")
		, m_sADCZ_zNegCapusle   ("sADCZ_zNegCapusle")
		, m_sGradRO				("sGradRO")
		, m_sGReadDeph			("sGReadDeph")
		, m_feedbackReceived    (false)
        , m_nbStep              (MAX_NB_STEP)   //MAX_NB_STEP     
		, m_lLinesToMeasure     (0)
        , m_lLinesPerSec        (0)
        , m_lCenterLine         (0)
        , m_dRFSpoilIncrement   (0)
        , m_dRFSpoilPhase       (0)
        , m_dMinRiseTime        (100000)
		, m_loop_test           (0)
		, m_loopTestClosedLoop  (0)
        , m_dGradMaxAmpl        (0)
		, tOff1                 (0)
		, tOff2                 (0)
		, tOffActiveMarker		(0)
        , m_pUI                 (new MiniFlashUI()) 
		, m_WIPParamTool        (*this)
{
   for (int i =0; i<m_nbStep; i++)
	   m_SinActuatePulse[i].setIdent("SinActuatePulse");

   for (int i =0; i<MAX_NB_EXTERN_STEP; i++)
   {
	   m_ExternActuatePulseX[i].setIdent("ExternActuatePulseX");
	   m_ExternActuatePulseY[i].setIdent("ExternActuatePulseY");
	   m_ExternActuatePulseZ[i].setIdent("ExternActuatePulseZ");
   }

   m_isRotorCenterAndRaduisFound = false;
   m_isDataSentToIce = false;
   m_isPause = false;

   m_tCycle = 0.0;
   m_tTracking = 0.0;
   m_nbGradBeforeTrack = -1;
   m_nbGradAfterTrack = -1;
   m_nbGradAtWakeUp = -1;
	m_timeAfterTrack = 0;
	m_interleavedOrSimult = 0; //Default interleaved
	m_imagingPlane = 0;

}


MiniFlash::~MiniFlash() {
    if(NULL != m_pUI) {
        // delete the user interface (UI) instance (if a UI instance has been created)
        delete m_pUI;
        m_pUI = NULL;
    }
}



NLSStatus MiniFlash::initialize(SeqLim &rSeqLim) {
    // This string is intended to store, where we are in the code (used for debugging by the MRTRACE macro).
    static const char *ptModule = {"MiniFLASH::initialize"};

    // Default return value
    NLS_STATUS lStatus = SEQU__NORMAL;

	rSeqLim.setMyOrigFilename ( __FILE__ );
	rSeqLim.setSequenceOwner ("USER");
    // -----------------------
    // Setting the hard limits
    // -----------------------
   // Define selectable gradient modes
    rSeqLim.setGradients(
        SEQ::GRAD_FAST,
        SEQ::GRAD_NORMAL,
        SEQ::GRAD_WHISPER,
        SEQ::GRAD_FAST_GSWD_RISETIME,
        SEQ::GRAD_NORMAL_GSWD_RISETIME,
        SEQ::GRAD_WHISPER_GSWD_RISETIME
    );

	rSeqLim.disableSAFEConsistencyCheck();
    // RF frequency is given as a long integer number in Hertz
    // The maximum allowed RF frequency is sufficient for 1H (hydrogen nuclei) in a 3-Tesla-system
    //                         (    min,       max)
    rSeqLim.setAllowedFrequency(8000000, 130850000);


    // The repetition time (TR) and echo time (TE) are given as long integer numbers in micro seconds.
    //                              (index,  min,        max,    increment,  default)
    rSeqLim.setTR                   (    0,  100,    5000000,           10,    20000);
    rSeqLim.setTE                   (    0,  100,     100000,           10,    10000);
    rSeqLim.setBandWidthPerPixel    (    0,   80,        900,           10,      260);


    // The flip angle is given as a double number in degrees.
    //                              (        min,        max,    increment,  default)
    rSeqLim.setFlipAngle            (       10.0,       90.0,          1.0,   90.000);
    //rSeqLim.setExtSrfFilename                                     ("%MEASDAT%/extrf.dat")  ;


    // The base resolution tells how many samples in readout direction are acquired in k-space. The increment-value
    // is not set directly. Instead, a key is used which is connected to values of 16, 32, 64, etc. The allowed
    // values can be looked up in "kSpaceDefines.h".
    //                              (        min,        max,    increment,  default)
    rSeqLim.setBaseResolution       (         64,        512,  SEQ::INC_64,      512); //INC_BASE2 also available
 
	

    // The field-of-view (FOV) is given as double numbers in mm.
    //                              (        min,        max,    increment,  default)
    rSeqLim.setReadoutFOV           (        100,        500,            1,      300);
    rSeqLim.setPhaseFOV             (        100,        500,            1,      300);


    // Here, we set the number of lines in phase encoding(PE)-direction.
    //                              (        min,        max,    increment,  default)
    rSeqLim.setPELines              (         32,       1024,            1,      128);


    // The MiniFLASH sequence is intended for single-slice measurements only.
    //                              (        min,        max,    increment,  default)
    rSeqLim.setSlices               (          1,          1,            1,        1);


    // The slice thickness is given as a double number in mm.
    //                              (        min,        max,    increment,  default)
    rSeqLim.setSliceThickness       (      2.000,     10.000,        0.500,    5.000);


    // --------------------------------------
    // Instantiation of the MiniFlashUI-class
    // --------------------------------------

    

    // MRRESULT_SEV is a mask for the "severity" bits. This if-statement checks whether the severity bits
    // are set (which indicates that something went wrong).
   //if((MRRESULT_SEV & (lStatus = createUI(rSeqLim))) == MRRESULT_SEV) {

        // The MRTRACE macro is used to log information for debugging purposes
       // MRTRACE("Instantiation of MiniFlashUI class failed!");
       // return lStatus;
    //}


    // This compiler directive restricts this code to the HOST version dll.
    // In this way the same source code can be compiled for both the Host and the MARS.
/*
    if(NULL == m_pUI) {
        MRTRACE("MiniFlashUI object pointer is null (creation failed probably)!");
        return ( SEQU_ERROR );
    }
*/

    // ----------------------------------------------
    // Declaration of pointer to UI parameter classes
    // ----------------------------------------------
    lStatus = m_pUI->registerUI(rSeqLim, m_WIPParamTool);
	//lStatus = m_pUI->registerUI(rSeqLim);
    if(MrSeverity(lStatus) != MRRESULT_SUCCESS) {
        MRTRACE("Registering MiniFlashUI object failed! Errorcode: %i", lStatus);
        return lStatus;
    }

    // -----------------------------------------------------------------
    // file containing the default postprocessing protocol (EVAProtocol)
    // -----------------------------------------------------------------
 #ifdef WIN32   
    // The _T(x) macro deals with the unicode conversion of strings.
    rSeqLim.setDefaultEVAProt (_T("%SiemensEvaDefProt%\\Inline\\Inline.evp"));
#endif
    return lStatus;
}



//. -------------------------------------------------------------------------
//.. fSEQPrep: prepare real time elements and calculate energy and timing
//. -------------------------------------------------------------------------
NLSStatus MiniFlash::prepare(MrProt &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo)
{
    static const char *ptModule = {"MiniFlash::prepare"};
    NLS_STATUS   lStatus = SEQU__NORMAL;                     // * Return status *
    long         lTEFil;
    double       dMeasureTimeUsec      = 0.0;
	long durationExt;
    // --------------------
    // get some information
    // --------------------

    OnErrorReturn(rMrProt.kSpace().linesToMeasure(m_lLinesToMeasure));

    m_dMinRiseTime = SysProperties::getGradMinRiseTime(rMrProt.gradSpec().mode());
    m_dGradMaxAmpl = SysProperties::getGradMaxAmpl(rMrProt.gradSpec().mode());
    dMeasureTimeUsec = (double)m_lLinesToMeasure * rMrProt.tr()[0];

	// make sure that m_lLinesPerSec is at least 1.
    m_lLinesPerSec =  std::max<long>(1,long(m_lLinesToMeasure * 1000000. /dMeasureTimeUsec));

    m_lCenterLine  = rMrProt.kSpace().echoLine();

	// TODO: Open a file to write inside the gradients values 
	// used for DEBUG mode to make sure that the gradients are updated correctly

	//. Prepare RF pulse for rotor imaging
    m_sSRF01.setTypeExcitation   ();
    m_sSRF01.setDuration         (1000) ;
    m_sSRF01.setFlipAngle        (rMrProt.flipAngle());
    m_sSRF01.setInitialPhase     (90);
    m_sSRF01.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF01.setSamples          (100);
	m_sSRF01.setBandwidthTimeProduct(2.70);
    if(! m_sSRF01.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF01.getNLSStatus());

    //. Prepare refocusing RF pulse for rotor imaging
    m_sSRF02.setTypeRefocussing  ();
    m_sSRF02.setDuration         (1280) ;
    m_sSRF02.setFlipAngle        (180);
    m_sSRF02.setInitialPhase     (0);
    m_sSRF02.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF02.setSamples          (128);
    m_sSRF02.setBandwidthTimeProduct(2.70);
    if(! m_sSRF02.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF02.getNLSStatus());
	

	//. Prepare RF pulses for capsule imaging
	// Negative offset used for the z-axis
    m_sSRF01OffsetNegative.setTypeExcitation   ();
    m_sSRF01OffsetNegative.setDuration         (1000) ;
    m_sSRF01OffsetNegative.setFlipAngle        (rMrProt.flipAngle());
    m_sSRF01OffsetNegative.setInitialPhase     (90);
    m_sSRF01OffsetNegative.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF01OffsetNegative.setSamples          (100);
	m_sSRF01OffsetNegative.setBandwidthTimeProduct(2.70);
    if(! m_sSRF01OffsetNegative.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF01OffsetNegative.getNLSStatus());
	// Negative refocusing pulse
    m_sSRF02OffsetNegative.setTypeRefocussing  ();
    m_sSRF02OffsetNegative.setDuration         (1280) ;
    m_sSRF02OffsetNegative.setFlipAngle        (180);
    m_sSRF02OffsetNegative.setInitialPhase     (0);
    m_sSRF02OffsetNegative.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF02OffsetNegative.setSamples          (128);
    m_sSRF02OffsetNegative.setBandwidthTimeProduct(2.70);
    if(! m_sSRF02OffsetNegative.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF02OffsetNegative.getNLSStatus());
	// Positive offset used for the x and y-axis
	m_sSRF01OffsetPositive.setTypeExcitation   ();
    m_sSRF01OffsetPositive.setDuration         (1000) ;
    m_sSRF01OffsetPositive.setFlipAngle        (rMrProt.flipAngle());
    m_sSRF01OffsetPositive.setInitialPhase     (90);
    m_sSRF01OffsetPositive.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF01OffsetPositive.setSamples          (100);
	m_sSRF01OffsetPositive.setBandwidthTimeProduct(2.70);
    if(! m_sSRF01OffsetPositive.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF01OffsetPositive.getNLSStatus());
	// Negative refocusing pulse
    m_sSRF02OffsetPositive.setTypeRefocussing  ();
    m_sSRF02OffsetPositive.setDuration         (1280) ;
    m_sSRF02OffsetPositive.setFlipAngle        (180);
    m_sSRF02OffsetPositive.setInitialPhase     (0);
    m_sSRF02OffsetPositive.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF02OffsetPositive.setSamples          (128);
    m_sSRF02OffsetPositive.setBandwidthTimeProduct(2.70);
    if(! m_sSRF02OffsetPositive.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF02OffsetPositive.getNLSStatus());
	//Prepare RF for active tracking
	m_sSRFActiveMarker.setTypeExcitation   ();
    m_sSRFActiveMarker.setDuration         (60) ;
    m_sSRFActiveMarker.setFlipAngle        ((long) m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleK2));
    m_sSRFActiveMarker.setInitialPhase     (90);
    m_sSRFActiveMarker.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRFActiveMarker.setSamples          (10);
	m_sSRFActiveMarker.setBandwidthTimeProduct(2.70);
    if(! m_sSRFActiveMarker.prepSinc(rMrProt,rSeqExpo)) return (m_sSRFActiveMarker.getNLSStatus());
    //. Prepare refocusing RF pulse for rotor imaging
    m_sSRFActiveMarkerRefocus.setTypeRefocussing  ();
    m_sSRFActiveMarkerRefocus.setDuration         (1280) ;
    m_sSRFActiveMarkerRefocus.setFlipAngle        (180);
    m_sSRFActiveMarkerRefocus.setInitialPhase     (0);
    m_sSRFActiveMarkerRefocus.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRFActiveMarkerRefocus.setSamples          (128);
    m_sSRFActiveMarkerRefocus.setBandwidthTimeProduct(2.70);
    if(! m_sSRFActiveMarkerRefocus.prepSinc(rMrProt,rSeqExpo)) return (m_sSRFActiveMarkerRefocus.getNLSStatus());


	
    //. Prepare ADCs for rotor imaging
    m_sADCX.setColumns (rMrProt.kSpace().getlBaseResolution());
    m_sADCX.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
    m_sADCX.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));
	m_sADCX.getMDH().setIceProgramPara(ADC_TYPE,SIGNAL_DATA); // Signal Data
	m_sADCX.getMDH().setIceProgramPara(NO_CHANNEL,(uint16_t) m_WIPParamTool.getLongValue (rMrProt, WIPLongChannelID)); // Communication Data

	m_sADCY.setColumns (rMrProt.kSpace().getlBaseResolution());
    m_sADCY.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
    m_sADCY.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));
	m_sADCY.getMDH().setIceProgramPara(ADC_TYPE,SIGNAL_DATA); // Signal Data
	m_sADCY.getMDH().setIceProgramPara(NO_CHANNEL,(uint16_t) m_WIPParamTool.getLongValue (rMrProt, WIPLongChannelID)); // Communication Data
  
	m_sADCZ.setColumns (rMrProt.kSpace().getlBaseResolution());
    m_sADCZ.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
    m_sADCZ.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));
	m_sADCZ.getMDH().setIceProgramPara(ADC_TYPE,SIGNAL_DATA); // Signal Data
	m_sADCZ.getMDH().setIceProgramPara(NO_CHANNEL,(uint16_t) m_WIPParamTool.getLongValue (rMrProt, WIPLongChannelID)); // Communication Data

	//. Prepare ADCs for capsule imaging
	
	m_sADCXCapusle.setColumns (rMrProt.kSpace().getlBaseResolution());
	m_sADCXCapusle.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
	m_sADCXCapusle.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));
	m_sADCXCapusle.getMDH().setIceProgramPara(ADC_TYPE,SIGNAL_DATA); // Signal Data
	m_sADCXCapusle.getMDH().setIceProgramPara(NO_CHANNEL,(uint16_t) m_WIPParamTool.getLongValue (rMrProt, WIPLongChannelID)); // Communication Data

	m_sADCYCapusle.setColumns (rMrProt.kSpace().getlBaseResolution());
	m_sADCYCapusle.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
	m_sADCYCapusle.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));
	m_sADCYCapusle.getMDH().setIceProgramPara(ADC_TYPE,SIGNAL_DATA); // Signal Data
	m_sADCYCapusle.getMDH().setIceProgramPara(NO_CHANNEL,(uint16_t) m_WIPParamTool.getLongValue (rMrProt, WIPLongChannelID)); // Communication Data

	m_sADCZCapusle.setColumns (rMrProt.kSpace().getlBaseResolution());
	m_sADCZCapusle.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
	m_sADCZCapusle.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));
	m_sADCZCapusle.getMDH().setIceProgramPara(ADC_TYPE,SIGNAL_DATA); // Signal Data
	m_sADCZCapusle.getMDH().setIceProgramPara(NO_CHANNEL,(uint16_t) m_WIPParamTool.getLongValue (rMrProt, WIPLongChannelID)); // Communication Data

	// Set some timming variables
	gThetaFinal1 = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleThetaF1);
	gK1 = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleK1);
	gK2 = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleK2);
	gtMeas = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT);
	gtRTFeedBack = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleRTDelay);
	gtRTFeedBack2= m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleWakeUpDelay);
	m_tCycle = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT)*1000000;

	m_imagingPlane = m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane);

	//. Prepare readout gradient
    if(!m_sGradRO.prepRO(600,(fSDSRoundUpGRT(m_sADCX.getDuration()+600)),
        600,rMrProt,m_sADCX.getDwellTime()))return(m_sGradRO.getNLSStatus());

	if( !( m_sGradRO.prep() ) || !( m_sGradRO.check() ) )
			return m_sGradRO.getNLSStatus();
    //. Prepare and check readout dephasing gradient
    m_sGReadDeph.setMaxMagnitude(m_dGradMaxAmpl);
    m_sGReadDeph.setMinRiseTime(m_dMinRiseTime);
	/*
	if (! m_sGReadDeph.prepSymmetricTOTShortestTime(-m_sGradRO.getMomentum(
        0,(long)(m_sGradRO.getRampUpTime() + m_sADCX.getDuration()/2))))
        return (m_sGReadDeph.getNLSStatus());
	*/
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == SPIN_ECHO){

		if (! m_sGReadDeph.prepSymmetricTOTShortestTime(m_sGradRO.getMomentum(
			0,(long)(m_sGradRO.getRampUpTime() + m_sADCX.getDuration()/2))))
			return (m_sGReadDeph.getNLSStatus());
	}
	else
	{
		if (! m_sGReadDeph.prepSymmetricTOTShortestTime(-m_sGradRO.getMomentum(
			0,(long)(m_sGradRO.getRampUpTime() + m_sADCX.getDuration()/2))))
			return (m_sGReadDeph.getNLSStatus());
	}

	// Calculation of the total tracking duration
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_TRACKACTUATE)
	{
		m_tTracking = m_sSRF01.getDuration()+m_sGReadDeph.getTotalTime()+abs(tOff1)+500 +m_sSRF02.getDuration()+500 +m_sGradRO.getRampUpTime()+m_sGradRO.getTotalTime();
	}
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == SPIN_ECHO)
	{
		m_tTracking = m_sSRF01.getDuration()+m_sGReadDeph.getTotalTime()+abs(tOff1)+500;
		m_tTracking += m_sSRF02.getDuration() +500 + m_sGradRO.getRampUpTime();
		m_tTracking += m_sGradRO.getDuration()- m_sGradRO.getRampDownTime() +m_sGradRO.getRampDownTime()+500;
		m_tTracking += m_sSRF02.getDuration() + 500 + m_sGradRO.getRampUpTime() + m_sGradRO.getTotalTime();
	}
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == GRADIENT_ECHO)
	{
		m_tTracking = m_sSRF01.getDuration()+m_sGReadDeph.getDuration()+m_sGReadDeph.getRampDownTime();
		m_tTracking += m_sGradRO.getRampUpTime() +  m_sGradRO.getDuration();
		m_tTracking += m_sGReadDeph.getDuration()+ m_sGReadDeph.getRampDownTime() + m_sGradRO.getRampUpTime() + m_sGradRO.getTotalTime();
	}
#ifdef WIN32
	cout << "************************************************************************" << endl;
	cout << "m_tTracking " <<  m_tTracking << endl;
	cout << "m_tCycle "    <<  m_tCycle << endl;
	cout << "************************************************************************" << endl;
#endif

	durationExt = (((long) ((m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT)*1000000)-m_tTracking) /MAX_NB_EXTERN_STEP)/GRAD_RASTER_TIME) * GRAD_RASTER_TIME ; //micro seconds, pulse length
	if(durationExt == 0)
		durationExt = 100000;
	
	m_nbGradBeforeTrack = (m_tCycle - m_tTracking - gtRTFeedBack)/durationExt;
	//m_nbGradAtWakeUp = (m_tCycle - m_tTracking - gtRTFeedBack2)/durationExt;
	m_nbGradAtWakeUp = m_tCycle - gtRTFeedBack2;
	m_nbGradAfterTrack = (MAX_NB_EXTERN_STEP - m_nbGradBeforeTrack);
	m_timeAfterTrack = m_nbGradAfterTrack*durationExt;
	if(m_nbGradBeforeTrack < 0 || m_nbGradAfterTrack < 0)
	{
#ifdef WIN32
		cout << "ERREUR DANS LE TIMMING" << endl;
#endif
		return (SEQU_ERROR);
	}
	prepareExternalPulse(rMrProt, durationExt);
	prepareInitPulse(rMrProt);

#ifdef WIN32
	cout << "m_nbGradBeforeTrack "    <<  m_nbGradBeforeTrack << endl;
	cout << "m_nbGradAtWakeUp "       <<  m_nbGradAtWakeUp    << endl;
	cout << "m_nbGradAfterTrack "     <<  m_nbGradAfterTrack  << endl;
#endif

    // Prepare ADC used to communicate data between Sequence and ICE
    m_sADCCom.setColumns (rMrProt.kSpace().getlBaseResolution());
	m_sADCCom.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
	m_sADCCom.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));
	   
	m_sADCCom2.setColumns (rMrProt.kSpace().getlBaseResolution());
	m_sADCCom2.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
	m_sADCCom2.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));

	prepareComADC(rMrProt);


	prepareSinusoidalPulse(rMrProt);
	//. Prepare Gradient
	m_sGActuateX.setMaxMagnitude(42.9);

	m_sGActuateX.setAmplitude(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitude));

	m_sGActuateX.setDuration((long)((m_WIPParamTool.getDoubleValue (rMrProt, WIPDoublePeriod)/2)*1000000/GRAD_RASTER_TIME) * GRAD_RASTER_TIME);
	m_sGActuateX.setRampUpTime(300);
	m_sGActuateX.setRampDownTime(300);
 
	if( !( m_sGActuateX.prep() ) ||
        !( m_sGActuateX.check() ) )
      return m_sGActuateX.getNLSStatus();

	m_sGActuateY.setMaxMagnitude(42.9);
		
	m_sGActuateY.setAmplitude(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitude));

	m_sGActuateY.setDuration((long)((m_WIPParamTool.getDoubleValue (rMrProt, WIPDoublePeriod)/2)*1000000/GRAD_RASTER_TIME) * GRAD_RASTER_TIME);
	m_sGActuateY.setRampUpTime(300);
	m_sGActuateY.setRampDownTime(300);

	if( !( m_sGActuateY.prep() ) ||
        !( m_sGActuateY.check() ) )
      return m_sGActuateY.getNLSStatus();

	m_sGActuateZ.setMaxMagnitude(42.9);
		
	m_sGActuateZ.setAmplitude(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitude));

	m_sGActuateZ.setDuration((long)((m_WIPParamTool.getDoubleValue (rMrProt, WIPDoublePeriod)/2)*1000000/GRAD_RASTER_TIME) * GRAD_RASTER_TIME);
	m_sGActuateZ.setRampUpTime(300);
	m_sGActuateZ.setRampDownTime(300);

	if( !( m_sGActuateZ.prep() ) ||
        !( m_sGActuateZ.check() ) )
      return m_sGActuateZ.getNLSStatus();

	// calcul time for balancing the timing table for spin echo tracking kernel
	tOffActiveMarker = (m_sSRFActiveMarker.getDuration()/2 + m_sGReadDeph.getTotalTime() + m_sSRFActiveMarkerRefocus.getDuration()/2)
						-(m_sSRFActiveMarkerRefocus.getDuration()/2 + m_sGradRO.getTotalTime()/2 );

	tOff1 = (m_sSRF01.getDuration()/2 + m_sGReadDeph.getTotalTime() + m_sSRF02.getDuration()/2)
		   -(m_sSRF02.getDuration()/2 + m_sGradRO.getTotalTime()/2 );

	tOff2 = (m_sSRF02.getDuration()/2 + m_sGradRO.getDuration() + m_sGReadDeph.getTotalTime() + m_sSRF02.getDuration()/2)
		   -(m_sSRF02.getDuration()/2 + m_sGradRO.getTotalTime()/2 );

#ifdef WIN32
	cout << "************************************************************************" << endl;
	cout << tOff2 << endl;
	cout << "************************************************************************" << endl;
	g_fileID.open("RTGradientsTest.txt", ios::out);
	if(g_fileID.fail())
		cout << "File open error" << endl;

#endif


    // ------------------------------------------------
    // Preparation of all required real time components
    // ------------------------------------------------
    rSeqExpo.setRelevantReadoutsForMeasTime(m_lLinesToMeasure / m_lLinesPerSec);
    // Set receiver gain
    OnErrorReturn(fSSLSetRxGain(K_RX_GAIN_CODE_HIGH,rMrProt,rSeqLim));
    // Prepare the slice position array
    OnErrorReturn(fSUPrepSlicePosArray (rMrProt, rSeqLim, m_asSLC));
    // Set sequence string for display in images
    //fSUSetSequenceString              ("fl", rMrProt, rSeqExpo);
	fSUSetSequenceString              ("se", rMrProt, rSeqExpo);
    //. Fill export section
	// oufel RF ENERGY CALCULATION
    rSeqExpo.setRFEnergyInSequence_Ws(m_WIPParamTool.getLongValue (rMrProt, WIPLongRepetition)
        * (m_sSRF01.getPulseEnergyWs() + m_sSRF02.getPulseEnergyWs()));
    rSeqExpo.setMeasuredPELines      (m_lLinesToMeasure);
    rSeqExpo.setMeasureTimeUsec      (dMeasureTimeUsec);
    rSeqExpo.setTotalMeasureTimeUsec (dMeasureTimeUsec);
    rSeqExpo.setPCAlgorithm          (SEQ::PC_ALGORITHM_NONE);
    rSeqExpo.setOnlineFFT            (SEQ::ONLINE_FFT_PHASE);
    //rSeqExpo.setICEProgramFilename   ("%SiemensIceProgs%\\IceProgramOnline2D");    // Only 2D reconstruction allowed
    rSeqExpo.setICEProgramFilename   ("%CustomerIceProgs%\\IceProgActuationCloseLoopV2");    // We Only Use MRI for gradient
    rSeqExpo.setICEProgramParam(ICE_PROGRAM_PARA_SHOW_OFFLINE, SEQ::SO_SHOW_NO);

    return (lStatus);
}

//. -------------------------------------------------------------------------
//.. fSEQCheck: check lines at the border of k-space (gradient overflow, GSWD)
//. -------------------------------------------------------------------------
NLSStatus MiniFlash::check(MrProt &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo, SEQCheckMode * /*pSEQCheckMode*/)
{
    
    static const char *ptModule = {"MiniFlash::check"};
    NLS_STATUS   lStatus = SEQU__NORMAL;
    long        lL                = 0;
    long        alLCk[4]          = {0, 1, rSeqExpo.getMeasuredPELines() - 2, rSeqExpo.getMeasuredPELines() - 1};
    while (lL < 4 )
    {
        OnErrorReturn(runKernel(rMrProt,rSeqLim,rSeqExpo,KERNEL_CHECK,0, 0, alLCk[lL]));
        lL++;
    }
    return(lStatus);
}

//. -------------------------------------------------------------------------
//.. fSEQRun: run the sequence
//. -------------------------------------------------------------------------
NLSStatus MiniFlash::run(MrProt  &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo)
{
    static const char *ptModule = {"MiniFlash::run"};
    NLS_STATUS lStatus          = SEQU__NORMAL;
	long n_rep;
		

    //. Initialize sequence test
    if(IS_UNIT_TEST_ACTIVE(rSeqLim))
    {
        mSEQTest(rMrProt,rSeqLim,rSeqExpo,RTEB_ORIGIN_fSEQRunStart,0,0,0,0,0);
    }
    long lLine;
	long lCurrKernelCalls = 0;

    //. Send the delay between measurements
    //OnErrorReturn(fSBBMeasRepetDelaysRun ( rMrProt, rSeqLim, rSeqExpo, 0 ));

    if(IS_UNIT_TEST_ACTIVE(rSeqLim))
    {
        mSEQTest (rMrProt, rSeqLim, rSeqExpo, RTEB_ClockInitTR, 0, 0, m_asSLC[0].getSliceIndex(), 0, 0);
    }

	m_sADCX.getMDH().setFreeParameterByIndex(1,0); // no of the acquisition
	m_sADCY.getMDH().setFreeParameterByIndex(1,0); // Will be incremented in the receive method
	m_sADCXCapusle.getMDH().setFreeParameterByIndex(1,0);
	m_sADCYCapusle.getMDH().setFreeParameterByIndex(1,0);
	m_sADCZCapusle.getMDH().setFreeParameterByIndex(1,0);
	m_sADCX.getMDH().setFreeParameterByIndex(4,0); // no of the acquisition
	m_sADCY.getMDH().setFreeParameterByIndex(4,0); // Will be incremented in the receive method
	m_sADCXCapusle.getMDH().setFreeParameterByIndex(4,0);
	m_sADCYCapusle.getMDH().setFreeParameterByIndex(4,0);
	m_sADCZCapusle.getMDH().setFreeParameterByIndex(4,0);

	n_rep = m_WIPParamTool.getLongValue (rMrProt, WIPLongRepetition);
    for( lLine=0; lLine<n_rep; lLine++ )    
    {
		lCurrKernelCalls++;

        // Call Kernel function
        OnErrorReturn(runKernel(rMrProt, rSeqLim,
            rSeqExpo,KERNEL_IMAGE,0, 0, lLine));
    }

	// DEBIG mode only : Write the real-time gradients amplitude into a file
#ifdef WIN32

		
	if(g_fileID.is_open() == true)
		cout << "File open" << endl;
	else
		cout << "File not Open" << endl;

	for(int i = 0; i < g_gradIndex; i++)
	{
		if (i != 0 && i%10 == 0)
			g_fileID << endl;

		g_fileID << g_gradValuesHistory[i] << " ";
	}
#endif	

    if(IS_UNIT_TEST_ACTIVE(rSeqLim))
    {
        mSEQTest(rMrProt,rSeqLim,rSeqExpo,RTEB_ORIGIN_fSEQRunFinish,0,0,0,0,0);
    }
    return(SEQU__NORMAL);
}


//. -------------------------------------------------------------------------
//.. runKernel
//. -------------------------------------------------------------------------
NLS_STATUS MiniFlash::runKernel(MrProt &rMrProt, SeqLim &rSeqLim,
								MrProtocolData::SeqExpo &rSeqExpo, long lKernelMode, long /* lSlice */, long /* lPartition */, long lLine)
{
	static const char *ptModule = {"MiniFlash::runKernel"};
	NLS_STATUS         lStatus  = SEQU__NORMAL;

	long lT;



    //Send data to ICE. Apply only once at the beginning of the sequence
	if(m_isDataSentToIce == false && lKernelMode == KERNEL_IMAGE)
	{
		sendComDataToIce(m_sADCCom, m_sADCCom_zSet, m_sADCCom_zNeg,1);
		sendComDataToIce(m_sADCCom2, m_sADCCom2_zSet, m_sADCCom2_zNeg, 2);

		m_isDataSentToIce = true;
	}
		//m_sADCX.getMDH().setFreeParameterByIndex(3,0); // Switch between max speed and position control disabled
		//m_sADCY.getMDH().setFreeParameterByIndex(3,0); // Disable = 0, Enable = 1

	// Debug only
	//m_isRotorCenterAndRaduisFound = true; // debug only, remove before release compile
	/*
	if(m_isRotorCenterAndRaduisFound == false)// Change the amplitude of the sine
	{
		durationSin = (((long)(durationTab[(m_loop_test++)%5]*1000000) /MAX_NB_STEP)/GRAD_RASTER_TIME) * GRAD_RASTER_TIME ; //micro seconds, pulse length
		for(int i = 0; i<m_nbStep; i++){
			m_SinActuatePulse[i].setRampTimes( durationSin ); // 
			m_SinActuatePulse[i].setDuration(durationSin);
			if( !( m_SinActuatePulse[i].prep() ) || !( m_SinActuatePulse[i].check() ) )
				return m_SinActuatePulse[i].getNLSStatus();
		}
	}
	*/
	/*
		if(lLine > 99 && lKernelMode == KERNEL_IMAGE)
		{
			m_isRotorCenterAndRaduisFound = true;
			++m_loopTestClosedLoop;
			m_interleavedOrSimult = 1;

		}
*/

	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_TRACKACTUATE && m_isRotorCenterAndRaduisFound == true)
	{
		//Circle found and mode is simultaneous actuation and tracking, update the rotation matrix based on received feedback
		if(m_interleavedOrSimult == 0)
		{
			applyRotMatrix(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane));
		}
		else
		{
			//g_theta = -2.83;
			applyRotMatrix(g_theta);
			
		}
	  // cout << "g_theta " << g_theta << endl;
	//cout << "trackStartTime " << trackStartTime << endl;
	//cout << "nbGradBeforeTrack " << nbGradBeforeTrack << endl;
	   // cout << " /////////////////////////////////////////////////////////////////////////////"<< endl;

	}
	else
	{
		//Apply Rotation Matrix for 2D acquisition  
		applyRotMatrix(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane));
		if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_LYAPUNOV_VEL)	
			applyRotMatrix((int32_t) X_Y);
		if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_LYAPUNOV_POS)	
			applyRotMatrix((int32_t) X_Y);
	}
	/*
	double deltaTheta = 2*M_PI;
    double time_sin = 0.0;

	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_TRACKACTUATE && lKernelMode == KERNEL_IMAGE && m_isRotorCenterAndRaduisFound == true)
	{
		//cout << " /////////////////////////////////////////////////////////////////////////////"<< endl;
	    time_sin = 0;
		for(int i = 0; i < MAX_NB_EXTERN_STEP; i++)
		{	
			m_ExternActuatePulseY[i].setAmplitude(0.0);
			m_ExternActuatePulseZ[i].setAmplitude(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitude)*sin((deltaTheta*time_sin)   ));
			m_ExternActuatePulseX[i].setAmplitude(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitude)*cos((deltaTheta*time_sin)  ));

			//m_ExternActuatePulseY[i].setAmplitude(0.0);
			//m_ExternActuatePulseZ[i].setAmplitude(0.0);

			//cout << "cos((g_deltaTheta*g_time_sin) " << cos(g_deltaTheta*g_time_sin)    << endl;
			//cout << "sin(-(g_deltaTheta*g_time_sin) " << sin(-(g_deltaTheta*g_time_sin))    << endl;

			if( !( m_ExternActuatePulseX[i].prep() ) || !( m_ExternActuatePulseX[i].check() ) )
				return m_ExternActuatePulseX[i].getNLSStatus();

			if( !( m_ExternActuatePulseY[i].prep() ) || !( m_ExternActuatePulseY[i].check() ) )
				return m_ExternActuatePulseY[i].getNLSStatus();

			if( !( m_ExternActuatePulseZ[i].prep() ) || !( m_ExternActuatePulseZ[i].check() ) )
				return m_ExternActuatePulseZ[i].getNLSStatus();

			time_sin += 0.01;
			g_theta += deltaTheta * 0.01;

		}
	}



	
	
	if(lKernelMode == KERNEL_IMAGE)
	{
		for(int i = 0; i < MAX_NB_EXTERN_STEP; i++)
		{	
			m_ExternActuatePulseY[i].setAmplitude(0.0);
			m_ExternActuatePulseX[i].setAmplitude(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitude)*cos((g_deltaTheta*g_time_sin)   ));
			m_ExternActuatePulseZ[i].setAmplitude(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitude)*sin(-(g_deltaTheta*g_time_sin)  ));

			//m_ExternActuatePulseX[i].setAmplitude(5.0);
			//m_ExternActuatePulseZ[i].setAmplitude(5.0);

			//cout << "cos((g_deltaTheta*g_time_sin) " << cos(g_deltaTheta*g_time_sin)    << endl;
			//cout << "sin(-(g_deltaTheta*g_time_sin) " << sin(-(g_deltaTheta*g_time_sin))    << endl;

			if( !( m_ExternActuatePulseX[i].prep() ) || !( m_ExternActuatePulseX[i].check() ) )
				return m_ExternActuatePulseX[i].getNLSStatus();

			if( !( m_ExternActuatePulseY[i].prep() ) || !( m_ExternActuatePulseY[i].check() ) )
				return m_ExternActuatePulseY[i].getNLSStatus();

			if( !( m_ExternActuatePulseZ[i].prep() ) || !( m_ExternActuatePulseZ[i].check() ) )
				return m_ExternActuatePulseZ[i].getNLSStatus();

			g_time_sin += 0.01;
			g_theta += g_deltaTheta * 0.01;

		}
	}
	
	*/



	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_PI_CAPSULE)
		m_isRotorCenterAndRaduisFound = true;

	fRTEBInit( m_asSLC[0].getROT_MATRIX());

	lT = 0;
    /////////////////////////////////////////////////////////////////////////////
    // Apply actuation sequence  
	/////////////////////////////////////////////////////////////////////////////
	//if (m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == SINUSOIDALE || (m_isRotorCenterAndRaduisFound == false && m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) >= EXTERNGRD_TRACKACTUATE ))
	
	if (m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == SINUSOIDALE)
	{
		OnErrorReturn((NLS_STATUS)applySinusoidalActuation(rMrProt, lT, lLine));
	}
	else if (m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == CONSTANTGRD)
	{
		OnErrorReturn((NLS_STATUS)applyConstantActuation(rMrProt, lT, lLine));
	}
	else if (m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == SQUAREWAVE)
	{
		OnErrorReturn((NLS_STATUS)applySquareWaveActuation(rMrProt, lT, lLine));
	}
	else if (m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_PI_CAPSULE)
	{
		//OnErrorReturn((NLS_STATUS)applySEImagingForCapsules(rMrProt, lT, lLine));
		OnErrorReturn((NLS_STATUS)applyExternActuation(rMrProt, lT, lLine));
	}
	else if (m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXT_MULTI_ORTHO_ROTORS)
	{
		OnErrorReturn((NLS_STATUS)applyExternActuation(rMrProt, lT, lLine));
		//OnErrorReturn((NLS_STATUS)applySETracking3Axis(rMrProt, lT, lLine));
	}
	else if (m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) >= EXTERNGRD_TRACKACTUATE)
	{
		
		if(m_isRotorCenterAndRaduisFound == false)
		{
			OnErrorReturn((NLS_STATUS)applyInitPulse(rMrProt, lT, lLine));
		}
		else
		{
		
			OnErrorReturn((NLS_STATUS)applyExternActuation(rMrProt, lT, lLine));
		}
	}

	OnErrorReturn((NLS_STATUS)fRTEBFinish());

	if (m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) >= EXTERNGRD_TRACKACTUATE)
	{
			
		// DEBUG mode only : Write the real-time gradients amplitude into an array

	#ifdef WIN32
		for(int i = 0; i< MAX_NB_EXTERN_STEP; i++)
		{
			if(g_gradIndex < CAPACITY)
				g_gradValuesHistory[g_gradIndex++] = m_ExternActuatePulseX[i].getAmplitude();
		}
	#endif
	}

	// Apply the first actuation bloc, the tracking bloc and the second actuation bloc and wait for
	// feedback. Once feedback received resume loading blocs into MARS.
	fRTWaitForWakeup();
	//m_sFeedbackSemaphore.acquire();

	//m_sFeedbackSemaphore.release();

	//Send a notification to ICE if whether or not the feedback was received
	if(m_feedbackReceived == true)
	{
		m_feedbackReceived = false;
		m_sADCX.getMDH().setFreeParameterByIndex(2,1); // Feedback received
		m_sADCY.getMDH().setFreeParameterByIndex(2,1); // Feedback received
		m_sADCXCapusle.getMDH().setFreeParameterByIndex(2,1);
		m_sADCYCapusle.getMDH().setFreeParameterByIndex(2,1);
		m_sADCZCapusle.getMDH().setFreeParameterByIndex(2,1);

	}
	else
	{
		m_sADCX.getMDH().setFreeParameterByIndex(2,0); // No Feedback received
		m_sADCY.getMDH().setFreeParameterByIndex(2,0); // No Feedback received
		m_sADCXCapusle.getMDH().setFreeParameterByIndex(2,0);
		m_sADCYCapusle.getMDH().setFreeParameterByIndex(2,0);
		m_sADCZCapusle.getMDH().setFreeParameterByIndex(2,0);

	}
	//. Call sequence unit test
	if(IS_UNIT_TEST_ACTIVE(rSeqLim))
	{
		if (lKernelMode == KERNEL_CHECK)
			mSEQTest(rMrProt, rSeqLim, rSeqExpo, RTEB_ORIGIN_fSEQCheck,  10, lLine, m_asSLC[0].getSliceIndex(), 0, 0);
		else
			mSEQTest(rMrProt, rSeqLim, rSeqExpo, RTEB_ORIGIN_fSEQRunKernel,10,lLine,m_asSLC[0].getSliceIndex(), 0, 0);
		mSEQTest    (rMrProt, rSeqLim, rSeqExpo, RTEB_ClockCheck,        10, lLine, m_asSLC[0].getSliceIndex(), 0, 0);
	}


	return(lStatus);
}


NLSStatus MiniFlash::receive(SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo, SEQData& rSEQData)
{
	static const char *ptModule = {"MiniFlash::receive"};
	NLSStatus         lStatus  = SEQU__NORMAL;

	//double durationTab[5] = {0.15, 0.75, 1, 0.5, 0.25};
	//double durationSin;

	// Check if the feedback is the expected one
	if(strcmp(rSEQData.getID(),"MRIR"))
	{
		UTRACE (Debug, iUTraceMarker, "**************************************************************** " );
		UTRACE (Debug, iUTraceMarker, "Feedback data in " << ptModule << " has wrong ID " << rSEQData.getID());
		UTRACE (Debug, iUTraceMarker, "**************************************************************** " );
		return lStatus;
	}
	m_feedbackReceived = true;
	//--------------------------------------------------------------------------------------------
	// Reserve Semaphore HERE
	//--------------------------------------------------------------------------------------------
	m_sFeedbackSemaphore.acquire();
	
	// Used for Debug. Increase a counter so we know that receive is called
	m_sADCX.getMDH().setFreeParameterByIndex(1,++m_loop_test); 
	m_sADCY.getMDH().setFreeParameterByIndex(1,m_loop_test); // 
	m_sADCXCapusle.getMDH().setFreeParameterByIndex(1,m_loop_test);
	m_sADCYCapusle.getMDH().setFreeParameterByIndex(1,m_loop_test);
	m_sADCZCapusle.getMDH().setFreeParameterByIndex(1,m_loop_test);
	m_sADCX.getMDH().setFreeParameterByIndex(4,m_loop_test); 
	m_sADCY.getMDH().setFreeParameterByIndex(4,m_loop_test); // 
	m_sADCXCapusle.getMDH().setFreeParameterByIndex(4,m_loop_test);
	m_sADCYCapusle.getMDH().setFreeParameterByIndex(4,m_loop_test);
	m_sADCZCapusle.getMDH().setFreeParameterByIndex(4,m_loop_test);

	// Get the feedback data
	FBData fbData;
	fbData = *(FBData*) rSEQData.getData();

	// The ICE program will send a 1 in fbData.lShot if the Circle is found
	//if (fbData.lShot == 1 && m_isPause == true)
	if (fbData.lShot == 1)
	{
		m_isRotorCenterAndRaduisFound = true;
		++m_loopTestClosedLoop;
	}
	g_theta = fbData.prjAngle;

	if(fbData.SimultORInterleaved == 1)
		m_interleavedOrSimult = 1;
	else
		m_interleavedOrSimult = 0;

	//if (fbData.lShot == 1 && m_isPause == false && m_isRotorCenterAndRaduisFound == false)
	//{
	//	m_isPause = true;
	//}


	// Pause 10 seconds after the rotor's center and radius are found

	// Change the period of the open loop sine wave if the circle is not found

	if(m_isRotorCenterAndRaduisFound == false)// Change the period of the sine
	{
		/*
		if (m_isPause == true)
		{
			durationSin = (((long)(10*1000000) /MAX_NB_STEP)/GRAD_RASTER_TIME) * GRAD_RASTER_TIME ; //micro seconds, pulse length
			for(int i = 0; i<m_nbStep; i++){
				m_SinActuatePulse[i].setAmplitude( 0.0 ); //
				m_SinActuatePulse[i].setRampTimes( durationSin ); // 
				m_SinActuatePulse[i].setDuration(durationSin);
				if( !( m_SinActuatePulse[i].prep() ) || !( m_SinActuatePulse[i].check() ) )
					return m_SinActuatePulse[i].getNLSStatus();
			}
		}
		else
		{
			durationSin = (((long)(durationTab[m_loop_test%5]*1000000) /MAX_NB_STEP)/GRAD_RASTER_TIME) * GRAD_RASTER_TIME ; //micro seconds, pulse length
			for(int i = 0; i<m_nbStep; i++){
				m_SinActuatePulse[i].setRampTimes( durationSin ); // 
				m_SinActuatePulse[i].setDuration(durationSin);
				if( !( m_SinActuatePulse[i].prep() ) || !( m_SinActuatePulse[i].check() ) )
					return m_SinActuatePulse[i].getNLSStatus();
			}
		}
		*/
	}
	else
	{
		// Change the external gradient amplitude based on feedback from ICE
		for(int i = 0; i< MAX_NB_EXTERN_STEP; i++)
		{	
			m_ExternActuatePulseX[i].setAmplitude(fbData.uValx[i]);
			m_ExternActuatePulseZ[i].setAmplitude(fbData.uValy[i]);
			m_ExternActuatePulseY[i].setAmplitude(fbData.uValz[i]);

			if( !( m_ExternActuatePulseX[i].prep() ) || !( m_ExternActuatePulseX[i].check() ) )
				return m_ExternActuatePulseX[i].getNLSStatus();

			if( !( m_ExternActuatePulseY[i].prep() ) || !( m_ExternActuatePulseY[i].check() ) )
				return m_ExternActuatePulseY[i].getNLSStatus();

			if( !( m_ExternActuatePulseZ[i].prep() ) || !( m_ExternActuatePulseZ[i].check() ) )
				return m_ExternActuatePulseZ[i].getNLSStatus();

		}
	}
	m_sFeedbackSemaphore.release();

	return lStatus;

}



NLS_STATUS MiniFlash::createUI (SeqLim&)
{
	static const char *ptModule = {"MiniFlash::createUI"};
    #ifdef WIN32

        

        //  ----------------------------------------------------------------------
        //  Delete existing instance if necessary
        //  ----------------------------------------------------------------------
        if(m_pUI)  {
            delete m_pUI;
            m_pUI = NULL;
        }



        //  ----------------------------------------------------------------------
        //  Instantiation of the UI class
        //  ----------------------------------------------------------------------
        try  {
            m_pUI = new MiniFlashUI();
        }

        catch (...)  {
            delete m_pUI;
            m_pUI = NULL;

            TRACE_PUT1(TC_ALWAYS, TF_SEQ,"%s: Cannot instantiate UI class !", ptModule);
            return ( SEQU_ERROR );
        }

    #endif

    return ( SEQU_NORMAL );

}   // end: MiniFlash::createUI



const MiniFlashUI* MiniFlash::getUI (void) const
{
	return ( m_pUI );
}


// --------------------------------------------------------------------------------------------
///  \brief    This method apply a rotation matrix 
///
///
///  \param    axis : A value set by the user interface card      
///
///  \return   NONE
// --------------------------------------------------------------------------------------------
void MiniFlash::applyRotMatrix(int32_t axis)
{
	sROT_MATRIX mat;
	switch (axis){
		case X_Y:
			mat.dMat[0][0] = 1; 
			mat.dMat[0][1] = 0;
			mat.dMat[0][2] = 0;

			mat.dMat[1][0] = 0;
			mat.dMat[1][1] = 1;
			mat.dMat[1][2] = 0;

			mat.dMat[2][0] = 0;
			mat.dMat[2][1] = 0;
			mat.dMat[2][2] = 0;
			break;
		case X_Z:
			mat.dMat[0][0] = 1; 
			mat.dMat[0][1] = 0;
			mat.dMat[0][2] = 0; 

			mat.dMat[1][0] = 0;
			mat.dMat[1][1] = 0;
			mat.dMat[1][2] = 0;

			mat.dMat[2][0] = 0;
			mat.dMat[2][1] = 1;
			mat.dMat[2][2] = 0;
			break;
		case Y_Z:
			mat.dMat[0][0] = 0; 
			mat.dMat[0][1] = 0;
			mat.dMat[0][2] = 0;

			mat.dMat[1][0] = 1;
			mat.dMat[1][1] = 0;
			mat.dMat[1][2] = 0;

			mat.dMat[2][0] = 0;
			mat.dMat[2][1] = 1;
			mat.dMat[2][2] = 0;
			break;
		default:
			break;
	}

	/*
	switch (axis){
		case X_Y:
			mat.dMat[0][0] = 1; 
			mat.dMat[0][1] = 0;
			mat.dMat[0][2] = 0;

			mat.dMat[1][0] = 0;
			mat.dMat[1][1] = 1;
			mat.dMat[1][2] = 0;

			mat.dMat[2][0] = 0;
			mat.dMat[2][1] = 0;
			mat.dMat[2][2] = 1;
			break;
		case X_Y_PRIME:
			mat.dMat[0][0] = 1; 
			mat.dMat[0][1] = 0;
			mat.dMat[0][2] = 0;

			mat.dMat[1][0] = 0;
			mat.dMat[1][1] = -1;
			mat.dMat[1][2] = 0;

			mat.dMat[2][0] = 0;
			mat.dMat[2][1] = 0;
			mat.dMat[2][2] = -1;
			break;
		case Y_Z:
			mat.dMat[0][0] = cos(M_PI/2.0); 
			mat.dMat[0][1] = 0;
			mat.dMat[0][2] = sin(M_PI/2.0);

			mat.dMat[1][0] = 0;
			mat.dMat[1][1] = 1;
			mat.dMat[1][2] = 0;

			mat.dMat[2][0] = -sin(M_PI/2.0);
			mat.dMat[2][1] = 0;
			mat.dMat[2][2] = cos(M_PI/2.0);
			break;
		case Y_Z_PRIME:
			mat.dMat[0][0] = cos(-M_PI/2.0); 
			mat.dMat[0][1] = 0;
			mat.dMat[0][2] = sin(-M_PI/2.0);

			mat.dMat[1][0] = 0;
			mat.dMat[1][1] = 1;
			mat.dMat[1][2] = 0;

			mat.dMat[2][0] = -sin(-M_PI/2.0);
			mat.dMat[2][1] = 0;
			mat.dMat[2][2] = cos(-M_PI/2.0);
			break;
		case X_Z_PRIME:
			mat.dMat[0][0] = 1; 
			mat.dMat[0][1] = 0;
			mat.dMat[0][2] = 0; 

			mat.dMat[1][0] = 0;
			mat.dMat[1][1] = cos(-M_PI/2.0);//cos(M_PI/2.0);
			mat.dMat[1][2] = -sin(-M_PI/2.0);//-sin(M_PI/2.0);

			mat.dMat[2][0] = 0;
			mat.dMat[2][1] = sin(-M_PI/2.0);//sin(M_PI/2.0);
			mat.dMat[2][2] = cos(-M_PI/2.0);//cos(M_PI/2.0);
			break;
		case X_Z:
			mat.dMat[0][0] = 1; 
			mat.dMat[0][1] = 0;
			mat.dMat[0][2] = 0; 

			mat.dMat[1][0] = 0;
			mat.dMat[1][1] = cos(M_PI/2.0);
			mat.dMat[1][2] = -sin(M_PI/2.0);

			mat.dMat[2][0] = 0;
			mat.dMat[2][1] = sin(M_PI/2.0);
			mat.dMat[2][2] = cos(M_PI/2.0);
			break;
		case ARB1:
			mat.dMat[0][0] = 0.707;
			mat.dMat[0][1] = 0;
			mat.dMat[0][2] = 0.707;

			mat.dMat[1][0] = 0;
			mat.dMat[1][1] = 1;
			mat.dMat[1][2] = 0;

			mat.dMat[2][0] = -0.707;
			mat.dMat[2][1] = 0;
			mat.dMat[2][2] = 0.707;

			break;
		case ARB2:
			mat.dMat[0][0] = 0.57735;
			mat.dMat[0][1] = -0.57735;
			mat.dMat[0][2] = -0.57735;

			mat.dMat[1][0] = 0.57735;
			mat.dMat[1][1] = 0.788675;
			mat.dMat[1][2] = -0.211325;

			mat.dMat[2][0] = 0.57735;
			mat.dMat[2][1] = -0.211325;
			mat.dMat[2][2] = 0.788675;

			break;
		case X_X:
		case Y_Y:
		case Z_Z:
			mat.dMat[0][0] = 1; 
			mat.dMat[0][1] = 0;
			mat.dMat[0][2] = 0;

			mat.dMat[1][0] = 0;
			mat.dMat[1][1] = 1;
			mat.dMat[1][2] = 0;

			mat.dMat[2][0] = 0;
			mat.dMat[2][1] = 0;
			mat.dMat[2][2] = 1;
			break;
		default:
			break;
	}
	*/
	m_asSLC[0].setROT_MATRIX(mat);
}
// --------------------------------------------------------------------------------------------
///  \brief    This method apply a rotation matrix 
///
///
///  \param    axis : A value set by the user interface card      
///
///  \return   NONE
// --------------------------------------------------------------------------------------------
void MiniFlash::applyRotMatrix(double theta)
{
	sROT_MATRIX mat;
	
	mat.dMat[0][0] = cos(theta); 
	mat.dMat[0][1] = -sin(theta);
	mat.dMat[0][2] = 0;//sin(theta); 

	mat.dMat[1][0] = 0;
	mat.dMat[1][1] = 0;
	mat.dMat[1][2] = 1;

	mat.dMat[2][0] = sin(theta);
	mat.dMat[2][1] = cos(theta);
	mat.dMat[2][2] = 0;

	m_asSLC[0].setROT_MATRIX(mat);
}
// --------------------------------------------------------------------------------------------
///  \brief    This method send specific actuation data to the ICE 
///            Data to send to ICE : 
///                    
///            
///				- First ADC : 
///
///  \param    NONE      
///
///  \return   \arg \c SEQU__NORMAL  : If the Real time event bloc is okay
///            \arg \c SEQU_ERROR    : Otherwise
// --------------------------------------------------------------------------------------------
NLS_STATUS MiniFlash::sendComDataToIce(sREADOUT &adc, sFREQ_PHASE &adcSet, sFREQ_PHASE &adcNeg, int index)
{

	NLS_STATUS         lStatus  = SEQU__NORMAL;

	long lT = 0;
	adc.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	adc.getMDH().setFreeParameterByIndex(0,index); // 
	adc.getMDH().setFreeParameterByIndex(1,0); // 

	//m_sADCCom.getMDH().setFreeParameterByIndex(1,0); 

	fRTEBInit( m_asSLC[0].getROT_MATRIX());
	//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
	//- *                             Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
	//- *                               (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
	//- *fRTEI(                                                    ,              ,          ,          ,                ,              ,                ,      );
	//- **********************************************************************************************************************************************************
	fRTEI ( lT                                                     , &adcSet,        0,   &adc,  0,   0, 0,    0 );
	fRTEI ( lT + adc.getDuration()                                 , &adcNeg,        0,      0,  0,   0, 0,    0 );
	fRTEI ( lT += 20000                                            ,       0,        0,      0,  0,   0, 0,    0 );
	
	OnErrorReturn((NLS_STATUS)fRTEBFinish());

	return lStatus;

}
// --------------------------------------------------------------------------------------------
///  \brief    This method apply a Spin echo tracking sequence kernel 
///            getMDH().setFreeParameterByIndex(0,...); used for projection
///            getMDH().setFreeParameterByIndex(1,...); used for loop
///            getMDH().setFreeParameterByIndex(2,...); used for Errors
///
///  \param    rMrProt      
///
///  \return   \arg \c SEQU__NORMAL  : If the Real time event bloc is okay
///            \arg \c SEQU_ERROR    : Otherwise
// --------------------------------------------------------------------------------------------
NLS_STATUS MiniFlash::applySETracking(MrProt &rMrProt, long& lT, long lLine)
{
	NLS_STATUS         lStatus  = SEQU__NORMAL;
	//long lT = 0;
	//fRTEBInit( m_asSLC[0].getROT_MATRIX());
    //. Prepare FrequencyPhase objects of the RF pulse

	double offsetFreqTab[5] = {0, -50, 50, -100, 100};
	double freqOffset = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset) + offsetFreqTab[m_loop_test % 5];

    m_sSRF01zSet.prepSet (m_asSLC[0], m_sSRF01) ;
    m_sSRF01zNeg.prepNeg (m_asSLC[0], m_sSRF01) ;

	m_sSRF01zSet.setFrequency(freqOffset);
	m_sSRF01zNeg.setFrequency(freqOffset);

	m_sSRF02zSet.prepSet (m_asSLC[0], m_sSRF02) ;
    m_sSRF02zNeg.prepNeg (m_asSLC[0], m_sSRF02) ;

	m_sSRF02zSet.setFrequency(freqOffset);
	m_sSRF02zNeg.setFrequency(freqOffset);
    /* -------------------------------------------------------- */
    /* Set the frequency/phase properties of the readout events */
    /* -------------------------------------------------------- */
    m_sADCX.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCX.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCX.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCX.getMDH().setFreeParameterByIndex(0,1); // 1 means x-axis

	// TO DO ADD the other combinations for the planes
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane) == X_Y)
	{
		m_sADCX.getMDH().setFreeParameterByIndex(3,0); // X_Y plane
	}
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane) == Y_Z)
	{
		m_sADCX.getMDH().setFreeParameterByIndex(3,2); // X_Y plane
	}
	else//(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane) == X_Z)
	{
		m_sADCX.getMDH().setFreeParameterByIndex(3,1); // X_Y plane
	}

	m_sADCX_zSet.prepSet (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCX_zNeg.prepNeg (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/

	m_sADCX_zSet.setFrequency(freqOffset);
	m_sADCX_zNeg.setFrequency(freqOffset);

	m_sADCY.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCY.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCY.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCY.getMDH().setFreeParameterByIndex(0,2); // 2 means y-axis
	// TO DO ADD the other combinations for the planes
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane) == X_Y)
	{
		m_sADCY.getMDH().setFreeParameterByIndex(3,0); // X_Y plane
	}
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane) == Y_Z)
	{
		m_sADCY.getMDH().setFreeParameterByIndex(3,2); // X_Y plane
	}
	else//(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane) == X_Z)
	{
		m_sADCY.getMDH().setFreeParameterByIndex(3,1); // X_Y plane
	}
	m_sADCY_zSet.prepSet (m_asSLC[0], m_sADCY, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCY_zNeg.prepNeg (m_asSLC[0], m_sADCY, m_sGradRO) ;   /*! EGA-06 !*/

	m_sADCY_zSet.setFrequency(freqOffset);
	m_sADCY_zNeg.setFrequency(freqOffset);

	if(lLine%2)
	{
		m_sSRF01zSet.increasePhase (180.0);
		m_sSRF01zNeg.decreasePhase (180.0);
		m_sADCX_zSet.increasePhase (180.0);
		m_sADCX_zNeg.decreasePhase (180.0);
		m_sADCY_zSet.increasePhase (180.0);
		m_sADCY_zNeg.decreasePhase (180.0);
	}



	// Apply tracking sequence, then actuation sequence
	// oufel ADD PHASE CYCLING
	// Tracking sequence based on a spin echo kernel
	//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
	//- *          Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
	//- *            (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
	//- *fRTEI(                                 ,              ,          ,          ,                ,              ,                ,      );
	//- **********************************************************************************************************************************************************
	fRTEI ( lT                                  , &m_sSRF01zSet,    &m_sSRF01,         0,               0,             0,               0,    0 );
	fRTEI ( lT + m_sSRF01.getDuration()         , &m_sSRF01zNeg,            0,         0,   &m_sGReadDeph,             0,               0,    0 );

	lT += m_sSRF01.getDuration()+m_sGReadDeph.getTotalTime()+abs(tOff1)+500;
	fRTEI ( lT                                  , &m_sSRF02zSet,  m_sSRF02,    0,               0,             0,               0,    0 );
	fRTEI ( lT + m_sSRF02.getDuration()         , &m_sSRF02zNeg,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT += m_sSRF02.getDuration() +500   ,             0,            0,         0,      &m_sGradRO,             0,               0,    0 );
	
	lT += m_sGradRO.getRampUpTime();
	/*
	if (m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT) < 0.091)
		m_sADCX.getMDH().setFreeParameterByIndex(3,lT);
	else
		m_sADCX.getMDH().setFreeParameterByIndex(3,lT - 60000);
*/
	fRTEI ( lT                                  , &m_sADCX_zSet,            0,  &m_sADCX,               0,             0,               0,    0 );
	fRTEI ( lT + m_sADCX.getDuration()          , &m_sADCX_zNeg,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT += m_sGradRO.getDuration()- m_sGradRO.getRampDownTime(),0, 0,           0,               0, &m_sGReadDeph,               0,    0 );
	fRTEI ( lT += m_sGradRO.getRampDownTime()+500, &m_sSRF02zSet,  m_sSRF02,    0,                       0,            0,               0,    0 );
	fRTEI ( lT + m_sSRF02.getDuration()         , &m_sSRF02zNeg,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT += m_sSRF02.getDuration()        ,             0,            0,         0,   &m_sGReadDeph,             0,               0,    0 );
	fRTEI ( lT += 500                           ,             0,            0,         0,               0,    &m_sGradRO,               0,    0 );
	
	lT += m_sGradRO.getRampUpTime();
	/*
	if (m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT) < 0.091)
		m_sADCY.getMDH().setFreeParameterByIndex(3,lT);
	else
		m_sADCY.getMDH().setFreeParameterByIndex(3,lT - 60000);
*/
	fRTEI ( lT                                  , &m_sADCY_zSet,            0,  &m_sADCY,               0,             0,               0,    0 );
	fRTEI ( lT + m_sADCX.getDuration()          , &m_sADCY_zNeg,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT += m_sGradRO.getDuration()       ,             0,            0,         0,               0,             0,               0,    0 );

	//OnErrorReturn((NLS_STATUS)fRTEBFinish());

	return lStatus;
}
// --------------------------------------------------------------------------------------------
///  \brief    This method apply a Spin echo tracking sequence kernel 
///            getMDH().setFreeParameterByIndex(0,...); used for projection
///            getMDH().setFreeParameterByIndex(1,...); used for loop
///            getMDH().setFreeParameterByIndex(2,...); used for Errors
///
///  \param    rMrProt      
///
///  \return   \arg \c SEQU__NORMAL  : If the Real time event bloc is okay
///            \arg \c SEQU_ERROR    : Otherwise
// --------------------------------------------------------------------------------------------
NLS_STATUS MiniFlash::applySETracking3Axis(MrProt &rMrProt, long& lT, long lLine)
{
	NLS_STATUS         lStatus  = SEQU__NORMAL;
	//long lT = 0;
	//fRTEBInit( m_asSLC[0].getROT_MATRIX());
    //. Prepare FrequencyPhase objects of the RF pulse

	//double offsetFreqTab[5] = {0, -50, 50, -100, 100};
	//double freqOffset = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset) + offsetFreqTab[m_loop_test % 5];
	
	double freqOffset = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset);

	// First Rotor
	freqOffset = 2500.0;

	m_sSRF01zSet.prepSet (m_asSLC[0], m_sSRF01) ;
    m_sSRF01zNeg.prepNeg (m_asSLC[0], m_sSRF01) ;

	m_sSRF01zSet.setFrequency(fabs(freqOffset)*-1);
	m_sSRF01zNeg.setFrequency(fabs(freqOffset)*-1);

	m_sSRF02zSet.prepSet (m_asSLC[0], m_sSRF02) ;
    m_sSRF02zNeg.prepNeg (m_asSLC[0], m_sSRF02) ;

	m_sSRF02zSet.setFrequency(fabs(freqOffset)*-1);
	m_sSRF02zNeg.setFrequency(fabs(freqOffset)*-1);
    /* -------------------------------------------------------- */
    /* Set the frequency/phase properties of the readout events */
    /* -------------------------------------------------------- */
/*
    m_sADCX.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCX.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCX.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCX.getMDH().setFreeParameterByIndex(0,5); // 5 means x-axis third rotor
	m_sADCX.getMDH().setFreeParameterByIndex(3,INTERLEAVED); // Interleaved actuation and imaging

	m_sADCX_zSet.prepSet (m_asSLC[0], m_sADCX, m_sGradRO) ;   
    m_sADCX_zNeg.prepNeg (m_asSLC[0], m_sADCX, m_sGradRO) ;  

	m_sADCX_zSet.setFrequency(fabs(freqOffset)*-1);
	m_sADCX_zNeg.setFrequency(fabs(freqOffset)*-1);
*/

	m_sADCZ.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCZ.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCZ.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCZ.getMDH().setFreeParameterByIndex(0,1); // 1 means z-axis first rotor
	m_sADCZ.getMDH().setFreeParameterByIndex(3,INTERLEAVED); // Interleaved actuation and imaging

	m_sADCZ_zSet.prepSet (m_asSLC[0], m_sADCY, m_sGradRO) ;   
    m_sADCZ_zNeg.prepNeg (m_asSLC[0], m_sADCY, m_sGradRO) ;   

	m_sADCZ_zSet.setFrequency(fabs(freqOffset)*-1);
	m_sADCZ_zNeg.setFrequency(fabs(freqOffset)*-1);


	m_sADCY.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCY.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCY.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCY.getMDH().setFreeParameterByIndex(0,2); // 2 means y-axis first rotor
	m_sADCY.getMDH().setFreeParameterByIndex(3,INTERLEAVED); // Interleaved actuation and imaging

	m_sADCY_zSet.prepSet (m_asSLC[0], m_sADCY, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCY_zNeg.prepNeg (m_asSLC[0], m_sADCY, m_sGradRO) ;   /*! EGA-06 !*/

	m_sADCY_zSet.setFrequency(fabs(freqOffset)*-1);
	m_sADCY_zNeg.setFrequency(fabs(freqOffset)*-1);




	//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
	//- *          Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
	//- *            (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
	//- *fRTEI(                                 ,              ,          ,          ,                ,              ,                ,      );
	//- **********************************************************************************************************************************************************
	fRTEI ( lT                                  , &m_sSRF01zSet,    &m_sSRF01,         0,               0,             0,               0,    0 );
	fRTEI ( lT + m_sSRF01.getDuration()         , &m_sSRF01zNeg,            0,         0,               0,             0,   &m_sGReadDeph,    0 );

	lT += m_sSRF01.getDuration()+m_sGReadDeph.getTotalTime()+abs(tOff1)+500;
	fRTEI ( lT                                  , &m_sSRF02zSet,  m_sSRF02,            0,               0,             0,               0,    0 );
	fRTEI ( lT + m_sSRF02.getDuration()         , &m_sSRF02zNeg,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT += m_sSRF02.getDuration() +500   ,             0,            0,         0,               0,             0,      &m_sGradRO,    0 );
	
	lT += m_sGradRO.getRampUpTime();
	/*
	if (m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT) < 0.091)
		m_sADCX.getMDH().setFreeParameterByIndex(3,lT);
	else
		m_sADCX.getMDH().setFreeParameterByIndex(3,lT - 60000);
*/
	fRTEI ( lT                                  , &m_sADCY_zSet,            0,  &m_sADCY,               0,             0,               0,    0 );
	fRTEI ( lT + m_sADCY.getDuration()          , &m_sADCY_zNeg,            0,         0,               0,             0,               0,    0 );
	
	
	fRTEI ( lT += m_sGradRO.getDuration()- m_sGradRO.getRampDownTime(),0, 0,           0,               0, &m_sGReadDeph,               0,    0 );
	fRTEI ( lT += m_sGradRO.getRampDownTime()+500, &m_sSRF02zSet,  m_sSRF02,    0,                      0,             0,               0,    0 );
	fRTEI ( lT + m_sSRF02.getDuration()         , &m_sSRF02zNeg,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT += m_sSRF02.getDuration()        ,             0,            0,         0,               0,             0,   &m_sGReadDeph,    0 );
	fRTEI ( lT += 500                           ,             0,            0,         0,               0,    &m_sGradRO,               0,    0 );
	
	lT += m_sGradRO.getRampUpTime();
	/*
	if (m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT) < 0.091)
		m_sADCY.getMDH().setFreeParameterByIndex(3,lT);
	else
		m_sADCY.getMDH().setFreeParameterByIndex(3,lT - 60000);
*/
	fRTEI ( lT                                  , &m_sADCZ_zSet,            0,  &m_sADCZ,               0,             0,               0,    0 );
	fRTEI ( lT + m_sADCZ.getDuration()          , &m_sADCZ_zNeg,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT += m_sGradRO.getDuration()       ,             0,            0,         0,               0,             0,               0,    0 );


	// Second Rotor
    freqOffset = 1500.0;

	m_sSRF01zSet.prepSet (m_asSLC[0], m_sSRF01) ;
    m_sSRF01zNeg.prepNeg (m_asSLC[0], m_sSRF01) ;

	m_sSRF01zSet.setFrequency(fabs(freqOffset)*-1);
	m_sSRF01zNeg.setFrequency(fabs(freqOffset)*-1);

	m_sSRF02zSet.prepSet (m_asSLC[0], m_sSRF02) ;
    m_sSRF02zNeg.prepNeg (m_asSLC[0], m_sSRF02) ;

	m_sSRF02zSet.setFrequency(fabs(freqOffset)*-1);
	m_sSRF02zNeg.setFrequency(fabs(freqOffset)*-1);
    /* -------------------------------------------------------- */
    /* Set the frequency/phase properties of the readout events */
    /* -------------------------------------------------------- */
    m_sADCX.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCX.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCX.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCX.getMDH().setFreeParameterByIndex(0,3); // 3 means x-axis second rotor
	m_sADCX.getMDH().setFreeParameterByIndex(3,INTERLEAVED); // Interleaved actuation and imaging

	m_sADCX_zSet.prepSet (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCX_zNeg.prepNeg (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/

	m_sADCX_zSet.setFrequency(fabs(freqOffset)*-1);
	m_sADCX_zNeg.setFrequency(fabs(freqOffset)*-1);
/*
	m_sADCY.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCY.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCY.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCY.getMDH().setFreeParameterByIndex(0,4); // 4 means y-axis second rotor
	m_sADCY.getMDH().setFreeParameterByIndex(3,INTERLEAVED); // Interleaved actuation and imaging

	m_sADCY_zSet.prepSet (m_asSLC[0], m_sADCY, m_sGradRO) ;   
    m_sADCY_zNeg.prepNeg (m_asSLC[0], m_sADCY, m_sGradRO) ;   

	m_sADCY_zSet.setFrequency(fabs(freqOffset)*-1);
	m_sADCY_zNeg.setFrequency(fabs(freqOffset)*-1);
*/
	m_sADCZ.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCZ.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCZ.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCZ.getMDH().setFreeParameterByIndex(0,4); // 4 means z-axis second rotor
	m_sADCZ.getMDH().setFreeParameterByIndex(3,INTERLEAVED); // Interleaved actuation and imaging

	m_sADCZ_zSet.prepSet (m_asSLC[0], m_sADCY, m_sGradRO) ;   
    m_sADCZ_zNeg.prepNeg (m_asSLC[0], m_sADCY, m_sGradRO) ;   

	m_sADCZ_zSet.setFrequency(fabs(freqOffset)*-1);
	m_sADCZ_zNeg.setFrequency(fabs(freqOffset)*-1);
	
/*
	if(lLine%2)
	{
		m_sSRF01zSet.increasePhase (180.0);
		m_sSRF01zNeg.decreasePhase (180.0);
		m_sADCX_zSet.increasePhase (180.0);
		m_sADCX_zNeg.decreasePhase (180.0);
		m_sADCY_zSet.increasePhase (180.0);
		m_sADCY_zNeg.decreasePhase (180.0);
		m_sADCZ_zSet.increasePhase (180.0);
		m_sADCZ_zNeg.decreasePhase (180.0);
	}
*/
	// Apply tracking sequence, then actuation sequence
	// oufel ADD PHASE CYCLING
	// Tracking sequence based on a spin echo kernel
	//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
	//- *          Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
	//- *            (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
	//- *fRTEI(                                 ,              ,          ,          ,                ,              ,                ,      );
	//- **********************************************************************************************************************************************************
	fRTEI ( lT                                  , &m_sSRF01zSet,    &m_sSRF01,         0,               0,             0,               0,    0 );
	fRTEI ( lT + m_sSRF01.getDuration()         , &m_sSRF01zNeg,            0,         0,   &m_sGReadDeph,             0,               0,    0 );

	lT += m_sSRF01.getDuration()+m_sGReadDeph.getTotalTime()+abs(tOff1)+500;
	fRTEI ( lT                                  , &m_sSRF02zSet,  m_sSRF02,            0,               0,             0,               0,    0 );
	fRTEI ( lT + m_sSRF02.getDuration()         , &m_sSRF02zNeg,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT += m_sSRF02.getDuration() +500   ,             0,            0,         0,      &m_sGradRO,             0,               0,    0 );
	
	lT += m_sGradRO.getRampUpTime();
	/*
	if (m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT) < 0.091)
		m_sADCX.getMDH().setFreeParameterByIndex(3,lT);
	else
		m_sADCX.getMDH().setFreeParameterByIndex(3,lT - 60000);
*/
	fRTEI ( lT                                  , &m_sADCX_zSet,            0,  &m_sADCX,               0,             0,               0,    0 );
	fRTEI ( lT + m_sADCX.getDuration()          , &m_sADCX_zNeg,            0,         0,               0,             0,               0,    0 );
	
	
	fRTEI ( lT += m_sGradRO.getDuration()- m_sGradRO.getRampDownTime(),0, 0,           0,               0,             0,   &m_sGReadDeph,    0 );
	fRTEI ( lT += m_sGradRO.getRampDownTime()+500, &m_sSRF02zSet,  m_sSRF02,    0,                       0,            0,               0,    0 );
	fRTEI ( lT + m_sSRF02.getDuration()         , &m_sSRF02zNeg,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT += m_sSRF02.getDuration()        ,             0,            0,         0,   &m_sGReadDeph,             0,               0,    0 );
	fRTEI ( lT += 500                           ,             0,            0,         0,               0,             0,      &m_sGradRO,    0 );
	
	lT += m_sGradRO.getRampUpTime();
	/*
	if (m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT) < 0.091)
		m_sADCY.getMDH().setFreeParameterByIndex(3,lT);
	else
		m_sADCY.getMDH().setFreeParameterByIndex(3,lT - 60000);
*/
	fRTEI ( lT                                  , &m_sADCZ_zSet,            0,  &m_sADCZ,               0,             0,               0,    0 );
	fRTEI ( lT + m_sADCZ.getDuration()          , &m_sADCZ_zNeg,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT += m_sGradRO.getDuration()       ,             0,            0,         0,               0,             0,               0,    0 );

	// Third Rotor
	freqOffset = 2500.0;

	m_sSRF01zSet.prepSet (m_asSLC[0], m_sSRF01) ;
    m_sSRF01zNeg.prepNeg (m_asSLC[0], m_sSRF01) ;

	m_sSRF01zSet.setFrequency(fabs(freqOffset));
	m_sSRF01zNeg.setFrequency(fabs(freqOffset));

	m_sSRF02zSet.prepSet (m_asSLC[0], m_sSRF02) ;
    m_sSRF02zNeg.prepNeg (m_asSLC[0], m_sSRF02) ;

	m_sSRF02zSet.setFrequency(fabs(freqOffset));
	m_sSRF02zNeg.setFrequency(fabs(freqOffset));
    /* -------------------------------------------------------- */
    /* Set the frequency/phase properties of the readout events */
    /* -------------------------------------------------------- */
	m_sADCX.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCX.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCX.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCX.getMDH().setFreeParameterByIndex(0,5); // 5 means x-axis third rotor
	m_sADCX.getMDH().setFreeParameterByIndex(3,INTERLEAVED); // Interleaved actuation and imaging

	m_sADCX_zSet.prepSet (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCX_zNeg.prepNeg (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/

	m_sADCX_zSet.setFrequency(fabs(freqOffset));
	m_sADCX_zNeg.setFrequency(fabs(freqOffset));

	m_sADCY.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCY.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCY.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCY.getMDH().setFreeParameterByIndex(0,6); // 6 means y-axis third rotor
	m_sADCY.getMDH().setFreeParameterByIndex(3,INTERLEAVED); // Interleaved actuation and imaging

	m_sADCY_zSet.prepSet (m_asSLC[0], m_sADCY, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCY_zNeg.prepNeg (m_asSLC[0], m_sADCY, m_sGradRO) ;   /*! EGA-06 !*/

	m_sADCY_zSet.setFrequency(fabs(freqOffset));
	m_sADCY_zNeg.setFrequency(fabs(freqOffset));


	// Apply tracking sequence, then actuation sequence
	// oufel ADD PHASE CYCLING
	// Tracking sequence based on a spin echo kernel
	//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
	//- *          Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
	//- *            (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
	//- *fRTEI(                                 ,              ,          ,          ,                ,              ,                ,      );
	//- **********************************************************************************************************************************************************
	fRTEI ( lT                                  , &m_sSRF01zSet,    &m_sSRF01,         0,               0,             0,               0,    0);
	fRTEI ( lT + m_sSRF01.getDuration()         , &m_sSRF01zNeg,            0,         0,   &m_sGReadDeph,             0,               0,    0 );

	lT += m_sSRF01.getDuration()+m_sGReadDeph.getTotalTime()+abs(tOff1)+500;
	fRTEI ( lT                                  , &m_sSRF02zSet,  m_sSRF02,    0,               0,             0,               0,    0 );
	fRTEI ( lT + m_sSRF02.getDuration()         , &m_sSRF02zNeg,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT += m_sSRF02.getDuration() +500   ,             0,            0,         0,      &m_sGradRO,             0,               0,    0 );
	
	lT += m_sGradRO.getRampUpTime();
	/*
	if (m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT) < 0.091)
		m_sADCX.getMDH().setFreeParameterByIndex(3,lT);
	else
		m_sADCX.getMDH().setFreeParameterByIndex(3,lT - 60000);
*/
	fRTEI ( lT                                  , &m_sADCX_zSet,            0,  &m_sADCX,               0,             0,               0,    0 );
	fRTEI ( lT + m_sADCX.getDuration()          , &m_sADCX_zNeg,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT += m_sGradRO.getDuration()- m_sGradRO.getRampDownTime(),0, 0,           0,               0, &m_sGReadDeph,               0,    0 );
	fRTEI ( lT += m_sGradRO.getRampDownTime()+500, &m_sSRF02zSet,  m_sSRF02,    0,                       0,            0,               0,    0 );
	fRTEI ( lT + m_sSRF02.getDuration()         , &m_sSRF02zNeg,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT += m_sSRF02.getDuration()        ,             0,            0,         0,   &m_sGReadDeph,             0,               0,    0 );
	fRTEI ( lT += 500                           ,             0,            0,         0,               0,    &m_sGradRO,               0,    0 );
	
	lT += m_sGradRO.getRampUpTime();
	/*
	if (m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT) < 0.091)
		m_sADCY.getMDH().setFreeParameterByIndex(3,lT);
	else
		m_sADCY.getMDH().setFreeParameterByIndex(3,lT - 60000);
*/
	fRTEI ( lT                                  , &m_sADCY_zSet,            0,  &m_sADCY,               0,             0,               0,    0 );
	fRTEI ( lT + m_sADCY.getDuration()          , &m_sADCY_zNeg,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT += m_sGradRO.getDuration()       ,             0,            0,         0,               0,             0,               0,    0 );

	
	

	


/*
	fRTEI ( lT += m_sGradRO.getDuration()- m_sGradRO.getRampDownTime(),0, 0,           0,               0,             0,   &m_sGReadDeph,    0 );
	fRTEI ( lT += m_sGradRO.getRampDownTime()+500, &m_sSRF02zSet,  m_sSRF02,    0,                       0,            0,               0,    0 );
	fRTEI ( lT + m_sSRF02.getDuration()         , &m_sSRF02zNeg,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT += m_sSRF02.getDuration()        ,             0,            0,         0,               0, &m_sGReadDeph,               0,    0 );
	fRTEI ( lT += 500                           ,             0,            0,         0,               0,             0,      &m_sGradRO,    0 );
	
	lT += m_sGradRO.getRampUpTime();*/
	/*
	if (m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT) < 0.091)
		m_sADCY.getMDH().setFreeParameterByIndex(3,lT);
	else
		m_sADCY.getMDH().setFreeParameterByIndex(3,lT - 60000);
*/
/*	fRTEI ( lT                                  , &m_sADCZ_zSet,            0,  &m_sADCZ,               0,             0,               0,    0 );
	fRTEI ( lT + m_sADCZ.getDuration()          , &m_sADCZ_zNeg,            0,         0,               0,             0,               0,    0 );
	
	fRTEI ( lT += m_sGradRO.getDuration()       ,             0,            0,         0,               0,             0,               0,    0 );
*/

	//OnErrorReturn((NLS_STATUS)fRTEBFinish());

	return lStatus;
}
// --------------------------------------------------------------------------------------------
///  \brief    This method apply a Gradient echo tracking sequence kernel 
///
///
///  \param    rMrProt      
///
///  \return   \arg \c SEQU__NORMAL  : If the Real time event bloc is okay
///            \arg \c SEQU_ERROR    : Otherwise
// --------------------------------------------------------------------------------------------
NLS_STATUS MiniFlash::applyGRETracking(MrProt &rMrProt, long& lT, long lLine)
{
	NLS_STATUS         lStatus  = SEQU__NORMAL;
	//long lT = 0;
	//. Prepare FrequencyPhase objects of the RF pulse
    m_sSRF01zSet.prepSet (m_asSLC[0], m_sSRF01) ;
    m_sSRF01zNeg.prepNeg (m_asSLC[0], m_sSRF01) ;

	m_sSRF01zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sSRF01zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
    /* -------------------------------------------------------- */
    /* Set the frequency/phase properties of the readout events */
    /* -------------------------------------------------------- */
    m_sADCX.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCX.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCX.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCX.getMDH().setFreeParameterByIndex(0,1); // 1 means x-axis

	m_sADCX_zSet.prepSet (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCX_zNeg.prepNeg (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/

	m_sADCX_zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sADCX_zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));

	m_sADCY.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCY.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCY.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCY.getMDH().setFreeParameterByIndex(0,2); // 2 means y-axis

	m_sADCY_zSet.prepSet (m_asSLC[0], m_sADCY, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCY_zNeg.prepNeg (m_asSLC[0], m_sADCY, m_sGradRO) ;   /*! EGA-06 !*/

	m_sADCY_zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sADCY_zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));

	// Apply Gradient echo tracking sequence, then actuation sequence
	// oufel ADD PHASE CYCLING
	// Tracking sequence based on a gradient echo kernel
	//fRTEBInit( m_asSLC[0].getROT_MATRIX());
	//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
	//- *          Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
	//- *            (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
	//- *fRTEI(                                 ,              ,          ,          ,                ,              ,                ,      );
	//- **********************************************************************************************************************************************************
	fRTEI ( lT+=m_sGActuateZ.getRampDownTime(), &m_sSRF01zSet,    &m_sSRF01,         0,                0,              0,               0,    0 );
	fRTEI ( lT + m_sSRF01.getDuration()        , &m_sSRF01zNeg,            0,         0,   &m_sGReadDeph,              0,               0,    0 );
	fRTEI ( lT += m_sSRF01.getDuration()+m_sGReadDeph.getDuration()+m_sGReadDeph.getRampDownTime(),0,0,0,&m_sGradRO,   0,               0,    0 );
	fRTEI ( lT += m_sGradRO.getRampUpTime()     , &m_sADCX_zSet,            0,  &m_sADCX,               0,             0,               0,    0 );
	fRTEI ( lT + m_sADCX.getDuration()          , &m_sADCX_zNeg,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT += m_sGradRO.getDuration()       ,              0,           0,         0,   &m_sGReadDeph, &m_sGReadDeph,               0,    0 );
	fRTEI ( lT += m_sGReadDeph.getDuration()+m_sGReadDeph.getRampDownTime(),0,0,       0,               0,    &m_sGradRO,               0,    0 );
	fRTEI ( lT += m_sGradRO.getRampUpTime()     , &m_sADCY_zSet,            0,  &m_sADCY,               0,             0,               0,    0 );
	fRTEI ( lT + m_sADCY.getDuration()          , &m_sADCY_zNeg,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT += m_sGradRO.getDuration()       ,             0,            0,         0,               0,             0,               0,    0 );

	//OnErrorReturn((NLS_STATUS)fRTEBFinish());

	return lStatus;
}

// --------------------------------------------------------------------------------------------
///  \brief    This method apply a Spin echo tracking and actuation sequence kernel 
///            getMDH().setFreeParameterByIndex(0,...); used for projection
///            getMDH().setFreeParameterByIndex(1,...); used for loop
///            getMDH().setFreeParameterByIndex(2,...); used for Errors
///
///  \param    rMrProt      
///
///  \return   \arg \c SEQU__NORMAL  : If the Real time event bloc is okay
///            \arg \c SEQU_ERROR    : Otherwise
// --------------------------------------------------------------------------------------------
NLS_STATUS MiniFlash::applySETrackingActuation(MrProt &rMrProt, long& lT, long lLine)
{
	NLS_STATUS         lStatus  = SEQU__NORMAL;
	//long lT = 0;
	//fRTEBInit( m_asSLC[0].getROT_MATRIX());
    //. Prepare FrequencyPhase objects of the RF pulse
    m_sSRF01zSet.prepSet (m_asSLC[0], m_sSRF01) ;
    m_sSRF01zNeg.prepNeg (m_asSLC[0], m_sSRF01) ;

	m_sSRF01zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sSRF01zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));

	m_sSRF02zSet.prepSet (m_asSLC[0], m_sSRF02) ;
    m_sSRF02zNeg.prepNeg (m_asSLC[0], m_sSRF02) ;

	m_sSRF02zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sSRF02zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
    /* -------------------------------------------------------- */
    /* Set the frequency/phase properties of the readout events */
    /* -------------------------------------------------------- */
    m_sADCX.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCX.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCX.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCX.getMDH().setFreeParameterByIndex(0,1); // 1 means x-axis
	m_sADCX.getMDH().setFreeParameterByIndex(3,SIMULTANEOUS); // Interleaved actuation and imaging

	m_sADCX_zSet.prepSet (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCX_zNeg.prepNeg (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/

	m_sADCX_zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sADCX_zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));

	// Apply tracking sequence, then actuation sequence
	// oufel ADD PHASE CYCLING
	//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
	//- *          Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
	//- *            (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
	//- *fRTEI(                                 ,              ,          ,          ,                ,              ,                ,      );
	//- **********************************************************************************************************************************************************
	fRTEI ( lT +=m_sGActuateZ.getRampDownTime() , &m_sSRF01zSet,    &m_sSRF01,         0,             0,            0,            0,    0 );
	fRTEI ( lT + m_sSRF01.getDuration()        , &m_sSRF01zNeg,            0,         0,  &m_sGReadDeph,            0,            0,    0 );
	fRTEI ( lT += m_sSRF01.getDuration()+m_sGReadDeph.getTotalTime()+abs(tOff1)+500, &m_sSRF02zSet,  &m_sSRF02, 0, 0,0,            0,    0 );
	fRTEI ( lT + m_sSRF02.getDuration()         , &m_sSRF02zNeg,            0,         0,              0,           0,            0,    0 );
	fRTEI ( lT += m_sSRF02.getDuration()+500    ,             0,            0,         0,    &m_sGradRO,            0,            0,    0 );
	fRTEI ( lT += m_sGradRO.getRampUpTime()     , &m_sADCX_zSet,            0,  &m_sADCX,              0,           0,            0,    0 );
	fRTEI ( lT + m_sADCX.getDuration()          , &m_sADCX_zNeg,            0,         0,              0,           0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration() - m_sGradRO.getRampDownTime(),0, 0,          0,   &m_sGActuateX,             0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration() ,0, 0,          0,   &m_sGActuateX,             0,            0,    0 );
	fRTEI ( lT += m_sGradRO.getDuration()   ,            0,             0,          0,               0,             0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration()- m_sGradRO.getRampDownTime(),0, 0,           0,               0,             0,   &m_sGReadDeph,    0 );
	//fRTEI ( lT += m_sGradRO.getRampDownTime()+500   , &m_sSRF02zSet,  m_sSRF02,    0,                       0,             0,               0,    0 );
	//fRTEI ( lT + m_sSRF02.getDuration()         , &m_sSRF02zNeg,            0,         0,               0,             0,               0,    0 );
	//fRTEI ( lT += m_sSRF02.getDuration()+500        ,             0,            0,         0,               0, &m_sGReadDeph,      &m_sGradRO,    0 );
	//fRTEI ( lT += m_sGradRO.getRampUpTime()     , &m_sADCY_zSet,            0,  &m_sADCY,               0,             0,               0,    0 );
	//fRTEI ( lT + m_sADCX.getDuration()          , &m_sADCY_zNeg,            0,         0,               0,             0,               0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration()       ,             0,            0,         0,               0,             0,               0,    0 );
	//fRTEI ( lT += m_sGReadDeph.getDuration()+m_sGReadDeph.getRampDownTime(),0,0,       0,      &m_sGradRO,             0,               0,    0 );
	//fRTEI ( lT += m_sGradRO.getRampUpTime()     , &m_sADCY_zSet,            0,  &m_sADCY,               0,             0,               0,    0 );
	//fRTEI ( lT + m_sADCY.getDuration()          , &m_sADCY_zNeg,            0,         0,               0,             0,               0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration()       ,             0,            0,         0,               0,             0,               0,    0 );

	//OnErrorReturn((NLS_STATUS)fRTEBFinish());

	return lStatus;
}
// --------------------------------------------------------------------------------------------
///  \brief    This method apply a Spin echo tracking sequence kernel for capsule imaging
///            getMDH().setFreeParameterByIndex(0,...); used for projection
///            getMDH().setFreeParameterByIndex(1,...); used for loop
///            getMDH().setFreeParameterByIndex(2,...); used for Errors
///
///  \param    rMrProt      
///
///  \return   \arg \c SEQU__NORMAL  : If the Real time event bloc is okay
///            \arg \c SEQU_ERROR    : Otherwise
// --------------------------------------------------------------------------------------------
NLS_STATUS MiniFlash::applySEImagingForCapsules(MrProt &rMrProt, long& lT, long lLine)
{
	NLS_STATUS         lStatus  = SEQU__NORMAL;
	//long lT = 0;
	//fRTEBInit( m_asSLC[0].getROT_MATRIX());
    //. Prepare FrequencyPhase objects of the RF pulse

    m_sSRF01zSetOffsetNegative.prepSet(m_asSLC[0], m_sSRF01OffsetNegative) ;
    m_sSRF01zNegOffsetNegative.prepNeg(m_asSLC[0], m_sSRF01OffsetNegative) ;
	m_sSRF01zSetOffsetNegative.setFrequency(-1*m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sSRF01zNegOffsetNegative.setFrequency(-1*m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sSRF02zSetOffsetNegative.prepSet(m_asSLC[0], m_sSRF02OffsetNegative) ;
	m_sSRF02zNegOffsetNegative.prepNeg(m_asSLC[0], m_sSRF02OffsetNegative) ;
	m_sSRF02zSetOffsetNegative.setFrequency(-1*m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sSRF02zNegOffsetNegative.setFrequency(-1*m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	
    m_sSRF01zSetOffsetPositive.prepSet(m_asSLC[0], m_sSRF01OffsetPositive) ;
    m_sSRF01zNegOffsetPositive.prepNeg(m_asSLC[0], m_sSRF01OffsetPositive) ;
	m_sSRF01zSetOffsetPositive.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset) *2);
	m_sSRF01zNegOffsetPositive.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset) *2);
	m_sSRF02zSetOffsetPositive.prepSet(m_asSLC[0], m_sSRF02OffsetPositive) ;
	m_sSRF02zNegOffsetPositive.prepNeg(m_asSLC[0], m_sSRF02OffsetPositive) ;
	m_sSRF02zSetOffsetPositive.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset) *2);
	m_sSRF02zNegOffsetPositive.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset) *2);

    /* -------------------------------------------------------- */
    /* Set the frequency/phase properties of the readout events */
    /* -------------------------------------------------------- */
    m_sADCXCapusle.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCXCapusle.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCXCapusle.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCXCapusle.getMDH().setFreeParameterByIndex(0,1); // 1 means x-axis

	m_sADCX_zSetCapusle.prepSet (m_asSLC[0], m_sADCXCapusle, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCX_zNegCapusle.prepNeg (m_asSLC[0], m_sADCXCapusle, m_sGradRO) ;   /*! EGA-06 !*/

	m_sADCX_zSetCapusle.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset)*2);
	m_sADCX_zNegCapusle.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset)*2);

    m_sADCYCapusle.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCYCapusle.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCYCapusle.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCYCapusle.getMDH().setFreeParameterByIndex(0,1); // 2 means y-axis

	m_sADCY_zSetCapusle.prepSet (m_asSLC[0], m_sADCYCapusle, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCY_zNegCapusle.prepNeg (m_asSLC[0], m_sADCYCapusle, m_sGradRO) ;   /*! EGA-06 !*/

	m_sADCY_zSetCapusle.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset)*2);
	m_sADCY_zNegCapusle.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset)*2);


	m_sADCZCapusle.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCZCapusle.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCZCapusle.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCZCapusle.getMDH().setFreeParameterByIndex(0,2); // 3 means z-axis

	m_sADCZ_zSetCapusle.prepSet (m_asSLC[0], m_sADCZCapusle, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCZ_zNegCapusle.prepNeg (m_asSLC[0], m_sADCZCapusle, m_sGradRO) ;   /*! EGA-06 !*/

	m_sADCZ_zSetCapusle.setFrequency(-1*m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sADCZ_zNegCapusle.setFrequency(-1*m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));


	// Apply tracking sequence, then actuation sequence
	// oufel ADD PHASE CYCLING
	//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
	//- *          Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
	//- *            (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
	//- *fRTEI(                                 ,              ,          ,          ,                ,              ,                ,      );
	//- **********************************************************************************************************************************************************
	fRTEI ( lT                                  , &m_sSRF01zSetOffsetPositive,    &m_sSRF01OffsetPositive,0,        0,            0,            0,    0 );
	fRTEI ( lT + m_sSRF01OffsetPositive.getDuration()         , &m_sSRF01zNegOffsetPositive,0,     0,  &m_sGReadDeph,             0,            0,    0 );
	fRTEI ( lT += m_sSRF01OffsetPositive.getDuration()+m_sGReadDeph.getTotalTime()+abs(tOff1)+500, &m_sSRF02zSetOffsetPositive,  &m_sSRF02OffsetPositive, 0, 0,0,            0,    0 );
	fRTEI ( lT + m_sSRF02OffsetPositive.getDuration()         , &m_sSRF02zNegOffsetPositive,0,     0,              0,             0,            0,    0 );
	fRTEI ( lT += m_sSRF02OffsetPositive.getDuration()+500    ,             0,            0,       0,     &m_sGradRO,             0,            0,    0 );
	fRTEI ( lT += m_sGradRO.getRampUpTime()     , &m_sADCX_zSetCapusle,     0,&m_sADCXCapusle,       0,             0,            0,    0 );
	fRTEI ( lT + m_sADCXCapusle.getDuration()          , &m_sADCX_zNegCapusle,     0,       0,              0,             0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration() - m_sGradRO.getRampDownTime(),0, 0,          0,   &m_sGActuateX,             0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration() ,0, 0,          0,   &m_sGActuateX,             0,            0,    0 );
	fRTEI ( lT += m_sGradRO.getDuration()   ,            0,             0,          0,               0,             0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration()- m_sGradRO.getRampDownTime(),0, 0,           0,               0,             0,   &m_sGReadDeph,    0 );
	//fRTEI ( lT += m_sGradRO.getRampDownTime()+500   , &m_sSRF02zSet,  m_sSRF02,    0,                       0,             0,               0,    0 );
	//fRTEI ( lT + m_sSRF02.getDuration()         , &m_sSRF02zNeg,            0,         0,               0,             0,               0,    0 );
	//fRTEI ( lT += m_sSRF02.getDuration()+500        ,             0,            0,         0,               0, &m_sGReadDeph,      &m_sGradRO,    0 );
	//fRTEI ( lT += m_sGradRO.getRampUpTime()     , &m_sADCY_zSet,            0,  &m_sADCY,               0,             0,               0,    0 );
	//fRTEI ( lT + m_sADCX.getDuration()          , &m_sADCY_zNeg,            0,         0,               0,             0,               0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration()       ,             0,            0,         0,               0,             0,               0,    0 );
	//fRTEI ( lT += m_sGReadDeph.getDuration()+m_sGReadDeph.getRampDownTime(),0,0,       0,      &m_sGradRO,             0,               0,    0 );
	//fRTEI ( lT += m_sGradRO.getRampUpTime()     , &m_sADCY_zSet,            0,  &m_sADCY,               0,             0,               0,    0 );
	//fRTEI ( lT + m_sADCY.getDuration()          , &m_sADCY_zNeg,            0,         0,               0,             0,               0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration()       ,             0,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT                                  , &m_sSRF01zSetOffsetNegative,    &m_sSRF01OffsetNegative,0,        0,            0,            0,    0 );
	fRTEI ( lT + m_sSRF01OffsetNegative.getDuration()         , &m_sSRF01zNegOffsetNegative,0,     0,  0,             &m_sGReadDeph,            0,    0 );
	fRTEI ( lT += m_sSRF01OffsetNegative.getDuration()+m_sGReadDeph.getTotalTime()+abs(tOff1)+500, &m_sSRF02zSetOffsetNegative,  &m_sSRF02OffsetNegative, 0, 0,0,            0,    0 );
	fRTEI ( lT + m_sSRF02OffsetNegative.getDuration()         , &m_sSRF02zNegOffsetNegative,0,     0,              0,             0,            0,    0 );
	fRTEI ( lT += m_sSRF02OffsetNegative.getDuration()+500    ,             0,            0,       0,     0,             &m_sGradRO,            0,    0 );
	fRTEI ( lT += m_sGradRO.getRampUpTime()     , &m_sADCZ_zSetCapusle,     0,&m_sADCZCapusle,       0,             0,            0,    0 );
	fRTEI ( lT + m_sADCZCapusle.getDuration()          , &m_sADCZ_zNegCapusle,     0,       0,              0,             0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration() - m_sGradRO.getRampDownTime(),0, 0,          0,   &m_sGActuateX,             0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration() ,0, 0,          0,   &m_sGActuateX,             0,            0,    0 );
	fRTEI ( lT += m_sGradRO.getDuration()   ,            0,             0,          0,               0,             0,            0,    0 );

	//OnErrorReturn((NLS_STATUS)fRTEBFinish());


	return lStatus;
}
// --------------------------------------------------------------------------------------------
///  \brief    This method apply a Spin echo tracking sequence kernel for active marker
///
///
///  \param    rMrProt      
///
///  \return   \arg \c SEQU__NORMAL  : If the Real time event bloc is okay
///            \arg \c SEQU_ERROR    : Otherwise
// --------------------------------------------------------------------------------------------
NLS_STATUS MiniFlash::applyActiveMarkerSEImaging(MrProt &rMrProt, long& lT, long lLine)
{

	double timeDelay;
		NLS_STATUS         lStatus  = SEQU__NORMAL;
	//long lT = 0;
	//fRTEBInit( m_asSLC[0].getROT_MATRIX());
    //. Prepare FrequencyPhase objects of the RF pulse

	
    m_sSRFzSetActiveMarker.prepSet(m_asSLC[0], m_sSRFActiveMarker) ;
    m_sSRFzNegActiveMarker.prepNeg(m_asSLC[0], m_sSRFActiveMarker) ;
	m_sSRFzSetActiveMarker.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sSRFzNegActiveMarker.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));

	m_sSRFzSetActiveMarkerRefocus.prepSet(m_asSLC[0], m_sSRFActiveMarkerRefocus) ;
	m_sSRFzNegActiveMarkerRefocus.prepNeg(m_asSLC[0], m_sSRFActiveMarkerRefocus) ;
	m_sSRFzSetActiveMarkerRefocus.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sSRFzNegActiveMarkerRefocus.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));

    /* -------------------------------------------------------- */
    /* Set the frequency/phase properties of the readout events */
    /* -------------------------------------------------------- */
    m_sADCX.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCX.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCX.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCX.getMDH().setFreeParameterByIndex(0,1); // 1 means first axis
	// TO DO ADD the other combinations for the planes
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane) == X_Y)
	{
		m_sADCX.getMDH().setFreeParameterByIndex(3,0); // X_Y plane
	}
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane) == Y_Z)
	{
		m_sADCX.getMDH().setFreeParameterByIndex(3,2); // X_Y plane
	}
	else//(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane) == X_Z)
	{
		m_sADCX.getMDH().setFreeParameterByIndex(3,1); // X_Y plane
	}
	m_sADCX_zSet.prepSet (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCX_zNeg.prepNeg (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/

	m_sADCX_zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sADCX_zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
/*
    m_sADCY.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCY.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCY.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCY.getMDH().setFreeParameterByIndex(0,1); // 2 means y-axis

	m_sADCY_zSet.prepSet (m_asSLC[0], m_sADCY, m_sGradRO) ;   
    m_sADCY_zNeg.prepNeg (m_asSLC[0], m_sADCY, m_sGradRO) ;   

	m_sADCY_zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sADCY_zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
*/

	m_sADCZ.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCZ.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCZ.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCZ.getMDH().setFreeParameterByIndex(0,2); // 2 means second axis
	// TO DO ADD the other combinations for the planes
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane) == X_Y)
	{
		m_sADCZ.getMDH().setFreeParameterByIndex(3,0); // X_Y plane
	}
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane) == Y_Z)
	{
		m_sADCZ.getMDH().setFreeParameterByIndex(3,2); // X_Y plane
	}
	else//(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane) == X_Z)
	{
		m_sADCZ.getMDH().setFreeParameterByIndex(3,1); // X_Y plane
	}

	m_sADCZ_zSet.prepSet (m_asSLC[0], m_sADCZ, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCZ_zNeg.prepNeg (m_asSLC[0], m_sADCZ, m_sGradRO) ;   /*! EGA-06 !*/

	m_sADCZ_zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sADCZ_zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));

	timeDelay = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleK1) * 1000.0;

	// Apply tracking sequence, then actuation sequence
	// oufel ADD PHASE CYCLING
	//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
	//- *          Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
	//- *            (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
	//- *fRTEI(                                 ,              ,          ,          ,                ,              ,                ,      );
	//- **********************************************************************************************************************************************************
	fRTEI ( lT                                  , &m_sSRFzSetActiveMarker,    &m_sSRFActiveMarker,0,        0,            0,            0,    &m_sWakeUp );
	fRTEI ( lT + m_sSRFActiveMarker.getDuration()         , &m_sSRFzNegActiveMarker,0,     0,  0,             0,            0,    0 );
	fRTEI ( lT + m_sSRFActiveMarker.getDuration()+timeDelay         , 0,0,     0,  &m_sGReadDeph,             0,            0,    0 );
	fRTEI ( lT += m_sSRFActiveMarker.getDuration()+timeDelay+m_sGReadDeph.getTotalTime()+abs(tOffActiveMarker)+500, &m_sSRFzSetActiveMarkerRefocus,  &m_sSRFActiveMarkerRefocus, 0, 0,0,            0,    0 );
	fRTEI ( lT + m_sSRFActiveMarkerRefocus.getDuration()         , &m_sSRFzNegActiveMarkerRefocus,0,     0,              0,             0,            0,    0 );
	fRTEI ( lT += m_sSRFActiveMarkerRefocus.getDuration()+500    ,             0,            0,       0,     &m_sGradRO,             0,            0,    0 );
	fRTEI ( lT += m_sGradRO.getRampUpTime()     , &m_sADCX_zSet,     0,&m_sADCX,       0,             0,            0,    0 );
	fRTEI ( lT + m_sADCX.getDuration()          , &m_sADCX_zNeg,     0,       0,              0,             0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration() - m_sGradRO.getRampDownTime(),0, 0,          0,   &m_sGActuateX,             0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration() ,0, 0,          0,   &m_sGActuateX,             0,            0,    0 );
	fRTEI ( lT += m_sGradRO.getDuration()   ,            0,             0,          0,               0,             0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration()- m_sGradRO.getRampDownTime(),0, 0,           0,               0,             0,   &m_sGReadDeph,    0 );
	//fRTEI ( lT += m_sGradRO.getRampDownTime()+500   , &m_sSRF02zSet,  m_sSRF02,    0,                       0,             0,               0,    0 );
	//fRTEI ( lT + m_sSRF02.getDuration()         , &m_sSRF02zNeg,            0,         0,               0,             0,               0,    0 );
	//fRTEI ( lT += m_sSRF02.getDuration()+500        ,             0,            0,         0,               0, &m_sGReadDeph,      &m_sGradRO,    0 );
	//fRTEI ( lT += m_sGradRO.getRampUpTime()     , &m_sADCY_zSet,            0,  &m_sADCY,               0,             0,               0,    0 );
	//fRTEI ( lT + m_sADCX.getDuration()          , &m_sADCY_zNeg,            0,         0,               0,             0,               0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration()       ,             0,            0,         0,               0,             0,               0,    0 );
	//fRTEI ( lT += m_sGReadDeph.getDuration()+m_sGReadDeph.getRampDownTime(),0,0,       0,      &m_sGradRO,             0,               0,    0 );
	//fRTEI ( lT += m_sGradRO.getRampUpTime()     , &m_sADCY_zSet,            0,  &m_sADCY,               0,             0,               0,    0 );
	//fRTEI ( lT + m_sADCY.getDuration()          , &m_sADCY_zNeg,            0,         0,               0,             0,               0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration()       ,             0,            0,         0,               0,             0,               0,    0 );
	fRTEI ( lT                                  , &m_sSRFzSetActiveMarker,    &m_sSRFActiveMarker,0,        0,            0,            0,    0 );
	fRTEI ( lT + m_sSRFActiveMarker.getDuration()         , &m_sSRFzNegActiveMarker,0,     0,  0,             0,            0,    0 );
	fRTEI ( lT + m_sSRFActiveMarker.getDuration()+timeDelay         , 0,0,     0,  0,             &m_sGReadDeph,            0,    0 );
	
	fRTEI ( lT += m_sSRFActiveMarker.getDuration()+timeDelay+m_sGReadDeph.getTotalTime()+abs(tOffActiveMarker)+500, &m_sSRFzSetActiveMarkerRefocus,  &m_sSRFActiveMarkerRefocus, 0, 0,0,            0,    0 );
	fRTEI ( lT + m_sSRFActiveMarkerRefocus.getDuration()         , &m_sSRFzNegActiveMarkerRefocus,0,     0,              0,             0,            0,    0 );
	fRTEI ( lT += m_sSRFActiveMarkerRefocus.getDuration()+500    ,             0,            0,       0,     0,             &m_sGradRO,            0,    0 );
	fRTEI ( lT += m_sGradRO.getRampUpTime()     , &m_sADCZ_zSet,     0,&m_sADCZ,       0,             0,            0,    0 );
	fRTEI ( lT + m_sADCZ.getDuration()          , &m_sADCZ_zNeg,     0,       0,              0,             0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration() - m_sGradRO.getRampDownTime(),0, 0,          0,   &m_sGActuateX,             0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration() ,0, 0,          0,   &m_sGActuateX,             0,            0,    0 );
	//
	
	fRTEI ( lT += m_sGradRO.getTotalTime()   ,            0,             0,          0,               0,             0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration()   ,            0,             0,          0,               &m_sGActuateY,             &m_sGActuateX,            &m_sGActuateZ,    0 );
	//fRTEI ( lT += m_sGActuateY.getTotalTime()   ,            0,             0,          0,               0,             0,            0,    0 );

	//OnErrorReturn((NLS_STATUS)fRTEBFinish());


	return lStatus;
}

// --------------------------------------------------------------------------------------------
///  \brief    This method apply a Spin echo tracking and actuation sequence kernel 
///            getMDH().setFreeParameterByIndex(0,...); used for projection
///            getMDH().setFreeParameterByIndex(1,...); used for loop
///            getMDH().setFreeParameterByIndex(2,...); used for Errors
///
///  \param    rMrProt      
///
///  \return   \arg \c SEQU__NORMAL  : If the Real time event bloc is okay
///            \arg \c SEQU_ERROR    : Otherwise
// --------------------------------------------------------------------------------------------
NLS_STATUS MiniFlash::applySETrackingActuationForCapsules(MrProt &rMrProt, long& lT, long lLine)
{
	NLS_STATUS         lStatus  = SEQU__NORMAL;
	//long lT = 0;
	//fRTEBInit( m_asSLC[0].getROT_MATRIX());
    //. Prepare FrequencyPhase objects of the RF pulse
    m_sSRF01zSet.prepSet (m_asSLC[0], m_sSRF01) ;
    m_sSRF01zNeg.prepNeg (m_asSLC[0], m_sSRF01) ;

	m_sSRF01zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sSRF01zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));

	m_sSRF02zSet.prepSet (m_asSLC[0], m_sSRF02) ;
    m_sSRF02zNeg.prepNeg (m_asSLC[0], m_sSRF02) ;

	m_sSRF02zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sSRF02zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
    /* -------------------------------------------------------- */
    /* Set the frequency/phase properties of the readout events */
    /* -------------------------------------------------------- */
    m_sADCX.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCX.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCX.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCX.getMDH().setFreeParameterByIndex(0,1); // 1 means x-axis
	m_sADCX.getMDH().setFreeParameterByIndex(3,SIMULTANEOUS); // Interleaved actuation and imaging

	m_sADCX_zSet.prepSet (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCX_zNeg.prepNeg (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/

	m_sADCX_zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	m_sADCX_zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));


	// Apply tracking sequence, then actuation sequence
	// oufel ADD PHASE CYCLING
	//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
	//- *          Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
	//- *            (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
	//- *fRTEI(                                 ,              ,          ,          ,                ,              ,                ,      );
	//- **********************************************************************************************************************************************************
	fRTEI ( lT                                  , &m_sSRF01zSet,    &m_sSRF01,0,        0,            0,            0,    0 );
	fRTEI ( lT + m_sSRF01OffsetPositive.getDuration()         , &m_sSRF01zNeg,0,     0,  &m_sGReadDeph,             0,            0,    0 );
	fRTEI ( lT += m_sSRF01OffsetPositive.getDuration()+m_sGReadDeph.getTotalTime()+abs(tOff1)+500, &m_sSRF02zSet,  &m_sSRF02, 0, 0,0,            0,    0 );
	fRTEI ( lT + m_sSRF02OffsetPositive.getDuration()         , &m_sSRF02zNeg,0,     0,              0,             0,            0,    0 );
	fRTEI ( lT += m_sSRF02OffsetPositive.getDuration()+500    ,             0,            0,       0,     &m_sGradRO,             0,            0,    0 );
	fRTEI ( lT += m_sGradRO.getRampUpTime()     , &m_sADCX_zSet,     0,&m_sADCX,       0,             0,            0,    0 );
	fRTEI ( lT + m_sADCXCapusle.getDuration()          , &m_sADCX_zNeg,     0,       0,              0,             0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration() - m_sGradRO.getRampDownTime(),0, 0,          0,   &m_sGActuateX,             0,            0,    0 );
	//fRTEI ( lT += m_sGradRO.getDuration() ,0, 0,          0,   &m_sGActuateX,             0,            0,    0 );
	fRTEI ( lT += m_sGradRO.getDuration()   ,            0,             0,          0,               0,             0,            0,    0 );


	return lStatus;
}
// --------------------------------------------------------------------------------------------
///  \brief    This method apply a sinusoidal actuation pulse, interleaved with the 
///                 tracking pulse 
///
///
///  \param    rMrProt      
///
///  \return   \arg \c SEQU__NORMAL  : If the Real time event bloc is okay
///            \arg \c SEQU_ERROR    : Otherwise
// --------------------------------------------------------------------------------------------
NLS_STATUS MiniFlash::applySinusoidalActuation(MrProt &rMrProt, long& lT, long lLine)
{
	NLS_STATUS         lStatus  = SEQU__NORMAL;
	long trackStartTime = 0, nbGradBeforeTrack = 0;
	double totActuationTime;
	bool wakeupSent = false;	
	int loopSin = 0;
	int loopCos = m_nbStep/4;
    /////////////////////////////////////////////////////////////////////////////
    // Apply Tracking sequence  
	/////////////////////////////////////////////////////////////////////////////

	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == SPIN_ECHO)
	{
		OnErrorReturn((NLS_STATUS)applySETracking(rMrProt, lT, lLine));
	}
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == GRADIENT_ECHO)
	{
		OnErrorReturn((NLS_STATUS)applyGRETracking(rMrProt, lT, lLine));
	}

	fRTEI(lT+= 0, 0, 0, 0,&m_SinActuatePulse[(loopCos++)%m_nbStep], &m_SinActuatePulse[(loopSin++)%m_nbStep], 0, 0);//
	for (int i = 0; i<(m_nbStep-1); i++){
		fRTEI( lT+=m_SinActuatePulse[0].getDuration(),  0, 0, /*A*/ 0, &m_SinActuatePulse[(loopCos++)%m_nbStep],&m_SinActuatePulse[(loopSin++)%m_nbStep],0,0);
		if(i==m_nbStep/2)
			fRTEI(lT+= 0, 0, 0, 0,0, 0, 0, &m_sWakeUp);//
	}
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == NO_TRACKING)
		fRTEI( lT+=m_SinActuatePulse[0].getRampDownTime(),  0, 0, /*A*/ 0, 0,0,0,0);
	else
		fRTEI( lT+=2*m_SinActuatePulse[0].getRampDownTime(),  0, 0, /*A*/ 0, 0,0,0,0);

	return lStatus;
}

// --------------------------------------------------------------------------------------------
///  \brief    This method apply the constant actuation pulse, interleaved with the 
///                 tracking pulse 
///
///
///  \param    rMrProt      
///
///  \return   \arg \c SEQU__NORMAL  : If the Real time event bloc is okay
///            \arg \c SEQU_ERROR    : Otherwise
// --------------------------------------------------------------------------------------------
NLS_STATUS MiniFlash::applyConstantActuation(MrProt &rMrProt, long& lT, long lLine)
{
	NLS_STATUS         lStatus  = SEQU__NORMAL;
	//long lT = 0;
	double offsetTime = 0.0;
	if (m_sGActuateZ.getDuration() > m_sGActuateX.getDuration())
		if(m_sGActuateZ.getDuration() > m_sGActuateY.getDuration())
			offsetTime = m_sGActuateZ.getDuration();
		else
			offsetTime = m_sGActuateY.getDuration();
	else
		if(m_sGActuateX.getDuration() > m_sGActuateY.getDuration())
			offsetTime = m_sGActuateX.getDuration();
		else
			offsetTime = m_sGActuateY.getDuration();

	//fRTEBInit( m_asSLC[0].getROT_MATRIX());
	//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
	//- *                             Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
	//- *                               (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
	//- *fRTEI(                                                    ,              ,          ,          ,                ,              ,                ,      );
	//- **********************************************************************************************************************************************************
	//fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuateY,   &m_sGActuateX, &m_sGActuateZ,    0 );
	//OnErrorReturn((NLS_STATUS)fRTEBFinish());
	/////////////////////////////////////////////////////////////////////////////
    // Apply Tracking sequence  
	/////////////////////////////////////////////////////////////////////////////
	/*
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_TRACKACTUATE)
	{
		OnErrorReturn((NLS_STATUS)applySETrackingActuation(rMrProt, lT));
	}
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == SPIN_ECHO)
	{
		OnErrorReturn((NLS_STATUS)applySETracking(rMrProt, lT));
	}
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == GRADIENT_ECHO)
	{
		OnErrorReturn((NLS_STATUS)applyGRETracking(rMrProt, lT));
	}
	*/
	//fRTEBInit( m_asSLC[0].getROT_MATRIX());
	/*
	fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuateY,   &m_sGActuateX, &m_sGActuateZ,    0 );
	fRTEI ( lT+=offsetTime                                         ,             0,         0,         0,  &m_sGActuateY,   &m_sGActuateX, &m_sGActuateZ, &m_sWakeUp );
	fRTEI ( lT+=offsetTime                                         ,             0,         0,         0,  &m_sGActuateY,   &m_sGActuateX, &m_sGActuateZ,    0 );
	fRTEI ( lT+=2*m_sGActuateZ.getRampDownTime()                   ,             0,         0,         0,              0,               0,             0,    0 );
*/
	fRTEI ( lT                                                     ,             0,         0,         0,              0,               0, &m_sGActuateY,             0 );
	fRTEI ( lT+= 1000000                                           ,             0,         0,         0,              0,               0, &m_sGActuateY,             0 );
	fRTEI ( lT+= 1000000                                           ,             0,         0,         0,              0,               0, &m_sGActuateY,    &m_sWakeUp );
	fRTEI ( lT+= 1000000                                           ,             0,         0,         0,              0,               0, &m_sGActuateY,             0 );
	fRTEI ( lT+= m_sGActuateY.getTotalTime()                       ,             0,         0,         0,  &m_sGActuateX,               0,             0,             0 );

	return lStatus;
}

// --------------------------------------------------------------------------------------------
///  \brief    This method apply the constant actuation pulse, interleaved with the 
///                 tracking pulse 
///
///
///  \param    rMrProt      
///
///  \return   \arg \c SEQU__NORMAL  : If the Real time event bloc is okay
///            \arg \c SEQU_ERROR    : Otherwise
// --------------------------------------------------------------------------------------------
NLS_STATUS MiniFlash::applySquareWaveActuation(MrProt &rMrProt, long& lT, long lLine)
{
	NLS_STATUS         lStatus  = SEQU__NORMAL;
	//long lT = 0;
	/*double offsetTime = 0.0;
	if (m_sGActuateZ.getDuration() > m_sGActuateX.getDuration())
		if(m_sGActuateZ.getDuration() > m_sGActuateY.getDuration())
			offsetTime = m_sGActuateZ.getDuration();
		else
			offsetTime = m_sGActuateY.getDuration();
	else
		if(m_sGActuateX.getDuration() > m_sGActuateY.getDuration())
			offsetTime = m_sGActuateX.getDuration();
		else
			offsetTime = m_sGActuateY.getDuration();
	*/	
	switch (m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane)){
		case X_Y:
			m_sGActuateZ.setAmplitude(0.0);
			break;
		case Y_Z:
			m_sGActuateX.setAmplitude(0.0);
			break;
		case X_Z_PRIME:
			m_sGActuateY.setAmplitude(0.0);
			break;
		case X_Z:
			m_sGActuateY.setAmplitude(0.0);
			break;
		case X_X:
			m_sGActuateY.setAmplitude(0.0);
			m_sGActuateZ.setAmplitude(0.0);
			break;
		case Y_Y:
			m_sGActuateX.setAmplitude(0.0);
			m_sGActuateZ.setAmplitude(0.0);
			break;
		case Z_Z:
			m_sGActuateX.setAmplitude(0.0);
			m_sGActuateZ.setAmplitude(0.0);
			break;
		default:
			break;
	}
	
		//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
		//- *                             Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
		//- *                               (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
		//- *fRTEI(                                                    ,              ,          ,          ,                ,              ,                ,      );
		//- **********************************************************************************************************************************************************
		fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuateX,  &m_sGActuateZ, &m_sGActuateY, &m_sWakeUp );
		
		m_sGActuateX.setAmplitude(-m_sGActuateX.getAmplitude());
		m_sGActuateY.setAmplitude(-m_sGActuateY.getAmplitude());
		m_sGActuateZ.setAmplitude(-m_sGActuateZ.getAmplitude());

		fRTEI ( lT+=m_sGActuateX.getDuration()                         ,             0,         0,         0,  &m_sGActuateX,  &m_sGActuateZ, &m_sGActuateY,    0 );
		//fRTEI ( lT+=m_sGActuateX.getRampDownTime()                     ,             0,         0,         0,              0,               0,            0,    0 );

		m_sGActuateX.setAmplitude(-m_sGActuateX.getAmplitude());
		m_sGActuateY.setAmplitude(-m_sGActuateY.getAmplitude());
		m_sGActuateZ.setAmplitude(-m_sGActuateZ.getAmplitude());


			
	return lStatus;

}


/*
// --------------------------------------------------------------------------------------------
///  \brief    This method apply the external actuation pulses, interleaved with the 
///                 tracking pulse 
///
///
///  \param    rMrProt      
///
///  \return   \arg \c SEQU__NORMAL  : If the Real time event bloc is okay
///            \arg \c SEQU_ERROR    : Otherwise
// --------------------------------------------------------------------------------------------
NLS_STATUS MiniFlash::applyExternActuation(MrProt &rMrProt)
{
	NLS_STATUS         lStatus  = SEQU__NORMAL;
	long lT = 0, trackTime = 0, nbGradBeforeTrack = 0;
	double totActuationTime;
	bool wakeupSent = false;
	//Find the total Actuation time
	totActuationTime = (m_ExternActuatePulseY[0].getDuration() * MAX_NB_EXTERN_STEP) + m_ExternActuatePulseY[0].getRampDownTime();
	trackTime = totActuationTime - m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleRTDelay);

	if(trackTime < 0)
		return SEQU_ERROR;

	nbGradBeforeTrack = trackTime/m_ExternActuatePulseY[0].getDuration();

	fRTEBInit( m_asSLC[0].getROT_MATRIX());
	fRTEI( lT+=0,  0, 0,  0, &m_ExternActuatePulseY[0],&m_ExternActuatePulseX[0],&m_ExternActuatePulseZ[0],0);
	for (int i = 1; i<nbGradBeforeTrack; i++)
	{
		fRTEI( lT+=m_ExternActuatePulseX[i].getDuration(),  0, 0,  0, &m_ExternActuatePulseY[i],&m_ExternActuatePulseX[i],&m_ExternActuatePulseZ[i],0);
	}
	fRTEI( lT+=2*m_ExternActuatePulseX[0].getRampDownTime(),  0, 0,  0, 0,0,0,0);
	OnErrorReturn((NLS_STATUS)fRTEBFinish());
	/////////////////////////////////////////////////////////////////////////////
    // Apply Tracking sequence  
	/////////////////////////////////////////////////////////////////////////////
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == SPIN_ECHO)
	{
		OnErrorReturn((NLS_STATUS)applySETracking(rMrProt));
	}
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == GRADIENT_ECHO)
	{
		OnErrorReturn((NLS_STATUS)applyGRETracking(rMrProt));
	}

	lT = 0;
	fRTEBInit( m_asSLC[0].getROT_MATRIX());
	fRTEI( lT+=0,  0, 0,  0, &m_ExternActuatePulseY[nbGradBeforeTrack],&m_ExternActuatePulseX[nbGradBeforeTrack],&m_ExternActuatePulseZ[nbGradBeforeTrack],0);
	for (int i = nbGradBeforeTrack + 1; i<MAX_NB_EXTERN_STEP; i++)
	{
		fRTEI( lT+=m_ExternActuatePulseX[i].getDuration(),  0, 0,  0, &m_ExternActuatePulseY[i],&m_ExternActuatePulseX[i],&m_ExternActuatePulseZ[i],0);
		if (lT >  m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleWakeUpDelay) && wakeupSent == false)
		{
			fRTEI( lT,  0, 0,  0, 0,0,0,&m_sWakeUp);
			wakeupSent == true;
		}
	}
	fRTEI( lT+=m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].getRampDownTime(),  0, 0,  0, 0,0,0,0);
	OnErrorReturn((NLS_STATUS)fRTEBFinish());
	return lStatus;
}
*/

// --------------------------------------------------------------------------------------------
///  \brief    This method apply the external actuation pulses, interleaved with the 
///                 tracking pulse 
///
///
///  \param    rMrProt      
///
///  \return   \arg \c SEQU__NORMAL  : If the Real time event bloc is okay
///            \arg \c SEQU_ERROR    : Otherwise
// --------------------------------------------------------------------------------------------
NLS_STATUS MiniFlash::applyExternActuation(MrProt &rMrProt, long& lT, long lLine)
{
	NLS_STATUS         lStatus  = SEQU__NORMAL;
	long trackTime = 0, nbGradBeforeTrack = 0;
	double totActuationTime;
	bool wakeupSent = false, trackingSent = false;

	
//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
//- *                             Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
//- *                               (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
//- *fRTEI(                                                    ,              ,          ,          ,                ,              ,                ,      );
//- **********************************************************************************************************************************************************

#ifdef WIN32
	cout << "Start time: " << lT;
#endif
	fRTEI( m_nbGradAtWakeUp,  0, 0,  0, 0,0,0,&m_sWakeUp);
	for (int i = 0; i<MAX_NB_EXTERN_STEP; i++)
	{
		if( (m_nbGradBeforeTrack == 0 || i == m_nbGradBeforeTrack) && trackingSent == false)
		{

			if((i-1) >= 0)
				fRTEI( lT+=m_ExternActuatePulseX[i-1].getTotalTime(),  0, 0,  0, 0,0,0,0);
			else
				fRTEI( lT+=m_ExternActuatePulseX[MAX_NB_EXTERN_STEP-1].getRampDownTime(),  0, 0,  0, 0,0,0,0);

#ifdef WIN32
			cout << ", Tracking start time: " << lT;
#endif
			//cout << "ramp down time " << m_ExternActuatePulseX[i].getRampDownTime() << endl;
			if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_TRACKACTUATE)
			{
#ifdef WIN32
		cout << "m_loopTestClosedLoop: " << m_loopTestClosedLoop << endl;
#endif
				if(m_interleavedOrSimult == 0)
				{
					OnErrorReturn((NLS_STATUS)applySETracking(rMrProt, lT, lLine));
					//OnErrorReturn((NLS_STATUS)applySETrackingActuation(rMrProt, lT, lLine));
				}
				else{
					OnErrorReturn((NLS_STATUS)applySETrackingActuation(rMrProt, lT, lLine));
				}
			}
			else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_PI_CAPSULE)
			{
				OnErrorReturn((NLS_STATUS)applySEImagingForCapsules(rMrProt, lT, lLine));
			}
			else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXT_MULTI_ORTHO_ROTORS)
			{
				OnErrorReturn((NLS_STATUS)applySETracking3Axis(rMrProt, lT, lLine));
			}
			else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_LYAPUNOV_VEL)
			{
				OnErrorReturn((NLS_STATUS)applySETracking3Axis(rMrProt, lT, lLine));
			}
			else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_LYAPUNOV_POS)
			{
				OnErrorReturn((NLS_STATUS)applySETracking3Axis(rMrProt, lT, lLine));
			}	
			else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == SPIN_ECHO)
			{
				OnErrorReturn((NLS_STATUS)applySETracking(rMrProt, lT, lLine));
			}
			else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == GRADIENT_ECHO)
			{
				OnErrorReturn((NLS_STATUS)applyGRETracking(rMrProt, lT, lLine));
			}
			trackingSent = true;
#ifdef WIN32
			//cout << ", Tracking end : " << lT;
			//cout << ", RT feedback time: " << m_tCycle - lT;
#endif
		}
		if( i == 0)
			fRTEI( lT+=0,  0, 0,  0, &m_ExternActuatePulseX[i],&m_ExternActuatePulseZ[i],&m_ExternActuatePulseY[i],0);
		else
		{
			if(i == m_nbGradBeforeTrack)	
				fRTEI( lT+=0,  0, 0,  0, &m_ExternActuatePulseX[i],&m_ExternActuatePulseZ[i],&m_ExternActuatePulseY[i],0);
			else 
				fRTEI( lT+=m_ExternActuatePulseX[i].getDuration(),  0, 0,  0, &m_ExternActuatePulseX[i],&m_ExternActuatePulseZ[i],&m_ExternActuatePulseY[i],0);
	
			//if(i == m_nbGradAtWakeUp)
			//{
				
#ifdef WIN32
				//cout << ", Wakeup : " << lT;
				//cout << ", Wakeup time: " << m_tCycle - lT;
#endif
			//}
	
		}
	}	
	
#ifdef WIN32
	//cout << ", End lT: " << lT+m_ExternActuatePulseX[0].getDuration();
#endif


	return lStatus;
}

	/*
		setIceProgramPara(0,...)  --> 0: Com data, 1: Signal Data
		setIceProgramPara(1,...)  --> 1: Rotor, 2: Capsule
		setIceProgramPara(2,...)  --> Control type (0: Open Loop, 1:Commutation control , 2:FBLinearization, 3:PI)
		setIceProgramPara(3,...)  --> Nb rotors
		setIceProgramPara(4,...)  --> Channel to be used
		setIceProgramPara(5,...)  --> 0: Interleaved tracking and actuation, 1: Simulatneous track/actuation
		setIceProgramPara(6,...)  --> Kalman gain 
		setIceProgramPara(7,...)  --> Velocity Kalman gain
		setIceProgramPara(8,...)  --> P Gain
		setIceProgramPara(9,...)  --> I Gain
		setIceProgramPara(10,...) --> D Gain
		setIceProgramPara(11,...) --> FB linearization Gain 1
		setIceProgramPara(12,...) --> FB linearization Gain 1
		setIceProgramPara(13,...) --> gtMeas
		setIceProgramPara(14,...) --> gtRTFeedBack
		setIceProgramPara(15,...) --> Theta Final 1
		setIceProgramPara(16,...) --> Theta Final 2
		setIceProgramPara(17,...) --> Theta Final 3
		setIceProgramPara(18,...) --> Rotor arm radius
		setIceProgramPara(19,...) --> Duration tracking sequence
		setIceProgramPara(20,...) --> Max grad mT/m
		setIceProgramPara(21,...) --> Rotor Static Friction
		setIceProgramPara(22,...) --> Rotor Dynamic Friction
		setIceProgramPara(23,...) --> Rotor Load torque
#define ADC_TYPE 0
#define SIGNAL_DATA 1
#define COM_DATA 0

#define EXPERIMENT_TYPE 1
#define ROTOR_EXP 1
#define CAPSULE_EXP 2

#define CONTROL_TYPE 2
#define OPEN_LOOP 0
#define MAX_TORQUE 1
#define FBLINEARIZATION 2
#define PI 3

#define NB_ROTORS 3

#define NO_CHANNEL 4

#define TRACKING_ACTUATION_TYPE 5 
#define INTERLEAVED 0
#define SIMULTANEOUS 1

#define KALMAN_GAIN 6
#define KALMAN_VELOCITY_GAIN 7
#define P_GAIN 8
#define I_GAIN 9
#define D_GAIN 10
#define FB_LINERIZATION_GAIN_1 11
#define FB_LINERIZATION_GAIN_2 12
#define ACTUATION_DURATION_1 13
#define ACTUATION_DURATION_2 14
#define THETA_TARGET_1 15
#define THETA_TARGET_2 16
#define THETA_TARGET_3 17
#define ROTOR_ARM_RADIUS 18
#define TRACKING_DURATION 19
#define MAX_GRAD_AMP 20
#define ROTOR_STATIC_FRICTION 21
#define ROTOR_VISCOUS_FRICTION 22
#define ROTOR_LOAD_TORQUE 23
	*/
void MiniFlash::prepareComADC(MrProt &rMrProt)
{
	double actuationDuration;
	m_sADCCom.getMDH().setIceProgramPara(ADC_TYPE,COM_DATA); // Communication Data
	
	if (m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_PI_CAPSULE)
		m_sADCCom.getMDH().setIceProgramPara(EXPERIMENT_TYPE,CAPSULE_EXP); // Capsule
	else
		m_sADCCom.getMDH().setIceProgramPara(EXPERIMENT_TYPE,ROTOR_EXP); // Rotor

	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_MAXTORQUE)
		m_sADCCom.getMDH().setIceProgramPara(CONTROL_TYPE,MAX_TORQUE); // Commutation control
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_FB)
		m_sADCCom.getMDH().setIceProgramPara(CONTROL_TYPE,FBLINEARIZATION); // FBLINEARIZATION
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_PI ||
		    m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_PI_CAPSULE)
		m_sADCCom.getMDH().setIceProgramPara(CONTROL_TYPE,PI); // PI
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_TRACKACTUATE)
		m_sADCCom.getMDH().setIceProgramPara(CONTROL_TYPE,MAX_TORQUE); // MAX_TORQUE for simultaneous tracking and actuation
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_LYAPUNOV_POS)
		m_sADCCom.getMDH().setIceProgramPara(CONTROL_TYPE,LYAPUNOV_POS); // 
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_LYAPUNOV_VEL)
		m_sADCCom.getMDH().setIceProgramPara(CONTROL_TYPE,LYAPUNOV_VEL); // 
	else
		m_sADCCom.getMDH().setIceProgramPara(CONTROL_TYPE,OPEN_LOOP); // Open Loop

	m_sADCCom.getMDH().setIceProgramPara(NB_ROTORS,1);// 1 rotor
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_LYAPUNOV_VEL)	
		m_sADCCom.getMDH().setIceProgramPara(NB_ROTORS,3); // 3 rotors
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_LYAPUNOV_POS)	
		m_sADCCom.getMDH().setIceProgramPara(NB_ROTORS,3); // 3 rotors
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXT_MULTI_ORTHO_ROTORS)	
		m_sADCCom.getMDH().setIceProgramPara(NB_ROTORS,3); // 3 rotors


	m_sADCCom.getMDH().setIceProgramPara(NO_CHANNEL,(uint16_t) m_WIPParamTool.getLongValue (rMrProt, WIPLongChannelID)); // Communication Data

	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_TRACKACTUATE)
		m_sADCCom.getMDH().setIceProgramPara(TRACKING_ACTUATION_TYPE,SIMULTANEOUS); // 1: Simulatneous track/actuation
	else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_FB)
		m_sADCCom.getMDH().setIceProgramPara(TRACKING_ACTUATION_TYPE,INTERLEAVED); // 0: Interleaved tracking and actuation

	m_sADCCom.getMDH().setIceProgramPara(KALMAN_GAIN,100); //  Kalman gain
	m_sADCCom.getMDH().setIceProgramPara(KALMAN_VELOCITY_GAIN,10);  //  Velocity Kalman gain
	m_sADCCom.getMDH().setIceProgramPara(P_GAIN,(uint16_t) gK1);  //  P Gain
	m_sADCCom.getMDH().setIceProgramPara(I_GAIN,(uint16_t) gK2);  //  I Gain
	m_sADCCom.getMDH().setIceProgramPara(D_GAIN,(uint16_t) m_WIPParamTool.getLongValue (rMrProt, WIPLongChannelID));  //  D Gain
	m_sADCCom.getMDH().setIceProgramPara(FB_LINERIZATION_GAIN_1,0);  //  FB linearization Gain 1
	m_sADCCom.getMDH().setIceProgramPara(FB_LINERIZATION_GAIN_2,0);  //  FB linearization Gain 2
	//
	actuationDuration = m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT) * 1000 - m_tTracking/1000;
	m_sADCCom.getMDH().setIceProgramPara(ACTUATION_DURATION_1,(uint16_t) actuationDuration);  // Actuation time in ms
	m_sADCCom.getMDH().setIceProgramPara(ACTUATION_DURATION_2,(uint16_t) m_timeAfterTrack); // Feed-back time 
	//
	m_sADCCom.getMDH().setIceProgramPara(THETA_TARGET_1,(uint16_t) (gThetaFinal1*1000));  // Theta target for first rotor 
	m_sADCCom.getMDH().setIceProgramPara(THETA_TARGET_2,(uint16_t) 2);//gThetaFinal1);  // Theta target for second rotor, or rotor direction
	m_sADCCom.getMDH().setIceProgramPara(THETA_TARGET_3,(uint16_t) m_WIPParamTool.getLongValue (rMrProt, WIPLongChannelID) + 150);  // Theta target for third rotor
	
	m_sADCCom.getMDH().setIceProgramPara(ROTOR_ARM_RADIUS,16);  // Rotor arm radius

	m_sADCCom.getMDH().setIceProgramPara(TRACKING_DURATION,18000);  // Duration tracking sequence (us)
	m_sADCCom.getMDH().setIceProgramPara(MAX_GRAD_AMP,abs(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitude)));  // Max Grad Amplitude
	m_sADCCom.getMDH().setIceProgramPara(ROTOR_STATIC_FRICTION,(uint16_t) gK1);  // Rotor Static Friction  NB * pow(10.0,-5.0) (default 8) (1 was used for max torque)
	m_sADCCom.getMDH().setIceProgramPara(ROTOR_VISCOUS_FRICTION,(uint16_t) gK2);  // Rotor viscous Friction NB * pow(10.0,-7.0) (default 100)(10 was used for max torque)
	m_sADCCom.getMDH().setIceProgramPara(ROTOR_LOAD_TORQUE,(uint16_t) m_WIPParamTool.getDoubleValue (rMrProt, WIPDoublePeriod) + 150);  // Rotor load torque

	uint16_t xRotorCenterZ = 643;
	uint16_t xRotorCenterY = 380;
	uint16_t yRotorCenterX = 410;
	uint16_t yRotorCenterZ = 359;
	uint16_t zRotorCenterX = 472;
	uint16_t zRotorCenterY = 403;

	m_sADCCom2.getMDH().setIceProgramPara(ADC_TYPE,COM_DATA); // Communication Data
	m_sADCCom2.getMDH().setIceProgramPara(1,xRotorCenterZ); // x-Rotor center z
	m_sADCCom2.getMDH().setIceProgramPara(2,xRotorCenterY); // x-Rotor center y
	//m_sADCCom2.getMDH().setIceProgramPara(3,yRotorCenterX); // y-Rotor center x
	//m_sADCCom2.getMDH().setIceProgramPara(4,yRotorCenterZ); // y-Rotor center z
	//m_sADCCom2.getMDH().setIceProgramPara(5,zRotorCenterX); // z-Rotor center x
	//m_sADCCom2.getMDH().setIceProgramPara(6,zRotorCenterY); // z-Rotor center y

	//Target Theta for multiple rotors control
	m_sADCCom2.getMDH().setIceProgramPara(7,18); // 18 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(8,0); // 0 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(9,0); // 0 rad/s

	m_sADCCom2.getMDH().setIceProgramPara(10,0); // 0 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(11,0); // 0 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(12,18); // 18 rad/s

	m_sADCCom2.getMDH().setIceProgramPara(13,0); // 0 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(14,18); // 18 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(15,0); // 0 rad/s

	m_sADCCom2.getMDH().setIceProgramPara(16,yRotorCenterX); // 0 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(17,yRotorCenterZ); // 18 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(18,zRotorCenterX); // 0 rad/s
	m_sADCCom2.getMDH().setIceProgramPara(19,zRotorCenterY); // 0 rad/s
	

}


NLS_STATUS MiniFlash::prepareSinusoidalPulse(MrProt &rMrProt)
{

	long durationSin;
	// Prepare sinusoidal pulse
	durationSin = (((long)(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoublePeriod)*1000000) /MAX_NB_STEP)/GRAD_RASTER_TIME) * GRAD_RASTER_TIME ; //micro seconds, pulse length
	for(int i = 0; i<m_nbStep; i++){
		m_SinActuatePulse[i].setMaxMagnitude(42.9);
		m_SinActuatePulse[i].setAmplitude(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitude)*sin( (2*M_PI)/(m_nbStep) * i) );
		m_SinActuatePulse[i].setRampTimes( durationSin ); // 
		m_SinActuatePulse[i].setDuration(durationSin);
		if( !( m_SinActuatePulse[i].prep() ) || !( m_SinActuatePulse[i].check() ) )
			return m_SinActuatePulse[i].getNLSStatus();
	}

	return SEQU__NORMAL;

}

NLS_STATUS MiniFlash::prepareExternalPulse(MrProt &rMrProt, long durationExt)
{
	NLS_STATUS         lStatus  = SEQU__NORMAL;

#ifdef NOTFOREXECUTE

	// Prepare external gradients

	durationExt = (((long)(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationEXT)*1000000) /10)/GRAD_RASTER_TIME) * GRAD_RASTER_TIME ; //micro seconds, pulse length
	if(durationExt == 0)
		durationExt = 5000;
	/*
	// Prepare X external gradients
	m_ExternActuatePulseX[0].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
	m_ExternActuatePulseX[0].setAmplitude(0.0);
	m_ExternActuatePulseX[0].setAmplitude(1.0);
	m_ExternActuatePulseX[0].setRampUpTime( 1000 ); // 
	m_ExternActuatePulseX[0].setRampDownTime( durationExt ); // 
	m_ExternActuatePulseX[0].setDuration(durationExt);
	if( !( m_ExternActuatePulseX[0].prep() ) || !( m_ExternActuatePulseX[0].check() ) )
		return m_ExternActuatePulseX[0].getNLSStatus();
*/
	for(int i = 0; i<MAX_NB_EXTERN_STEP; i++){
		m_ExternActuatePulseX[i].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_ExternActuatePulseX[i].setAmplitude(0.0);
		m_ExternActuatePulseX[i].setAmplitude(pow(-1.,i));
		m_ExternActuatePulseX[i].setRampTimes( durationExt ); // 
		m_ExternActuatePulseX[i].setDuration(durationExt);
		if( !( m_ExternActuatePulseX[i].prep() ) || !( m_ExternActuatePulseX[i].check() ) )
			return m_ExternActuatePulseX[i].getNLSStatus();
	}
	/*
	m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
	m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].setAmplitude(0.0);
	m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].setAmplitude(1);
	m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].setRampUpTime( durationExt ); // 
	m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].setRampDownTime( 1000 ); // 
	m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].setDuration(durationExt);
	if( !( m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].prep() ) || !( m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].check() ) )
		return m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].getNLSStatus();
*/
		// Prepare Y external gradients
	/*
	m_ExternActuatePulseY[0].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
	m_ExternActuatePulseY[0].setAmplitude(0.0);
	m_ExternActuatePulseY[0].setAmplitude(1);
	m_ExternActuatePulseY[0].setRampUpTime( 1000 ); // 
	m_ExternActuatePulseY[0].setRampDownTime( durationExt ); // 
	m_ExternActuatePulseY[0].setDuration(durationExt);
	if( !( m_ExternActuatePulseY[0].prep() ) || !( m_ExternActuatePulseY[0].check() ) )
		return m_ExternActuatePulseY[0].getNLSStatus();
*/
	for(int i = 0; i<MAX_NB_EXTERN_STEP; i++){
		m_ExternActuatePulseY[i].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_ExternActuatePulseY[i].setAmplitude(0.0);
		m_ExternActuatePulseY[i].setAmplitude(pow(-1.,i));
		m_ExternActuatePulseY[i].setRampTimes( durationExt ); // 
		m_ExternActuatePulseY[i].setDuration(durationExt);
		if( !( m_ExternActuatePulseY[i].prep() ) || !( m_ExternActuatePulseY[i].check() ) )
			return m_ExternActuatePulseY[i].getNLSStatus();
	}
	/*
	m_ExternActuatePulseY[MAX_NB_EXTERN_STEP -1].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
	m_ExternActuatePulseY[MAX_NB_EXTERN_STEP -1].setAmplitude(0.0);
	m_ExternActuatePulseY[MAX_NB_EXTERN_STEP -1].setAmplitude(1);
	m_ExternActuatePulseY[MAX_NB_EXTERN_STEP -1].setRampUpTime( durationExt ); // 
	m_ExternActuatePulseY[MAX_NB_EXTERN_STEP -1].setRampDownTime( 1000 ); // 
	m_ExternActuatePulseY[MAX_NB_EXTERN_STEP -1].setDuration(durationExt);
	if( !( m_ExternActuatePulseY[MAX_NB_EXTERN_STEP -1].prep() ) || !( m_ExternActuatePulseY[MAX_NB_EXTERN_STEP -1].check() ) )
		return m_ExternActuatePulseY[MAX_NB_EXTERN_STEP -1].getNLSStatus();
*/
		// Prepare Z external gradients
	/*
	m_ExternActuatePulseZ[0].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
	m_ExternActuatePulseZ[0].setAmplitude(0.0);
	m_ExternActuatePulseZ[0].setAmplitude(1);
	m_ExternActuatePulseZ[0].setRampUpTime( 1000 ); // 
	m_ExternActuatePulseZ[0].setRampDownTime( durationExt ); // 
	m_ExternActuatePulseZ[0].setDuration(durationExt);
	if( !( m_ExternActuatePulseZ[0].prep() ) || !( m_ExternActuatePulseZ[0].check() ) )
		return m_ExternActuatePulseZ[0].getNLSStatus();
*/
	for(int i = 0; i<MAX_NB_EXTERN_STEP; i++){
		m_ExternActuatePulseZ[i].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_ExternActuatePulseZ[i].setAmplitude(0.0);
		m_ExternActuatePulseZ[i].setAmplitude(pow(-1.,i));
		m_ExternActuatePulseZ[i].setRampTimes( durationExt ); // 
		m_ExternActuatePulseZ[i].setDuration(durationExt);
		if( !( m_ExternActuatePulseZ[i].prep() ) || !( m_ExternActuatePulseZ[i].check() ) )
			return m_ExternActuatePulseZ[i].getNLSStatus();
	}
	/*
	m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP -1].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
	m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP -1].setAmplitude(0.0);
	m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP -1].setAmplitude(1);
	m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP -1].setRampUpTime( durationExt ); // 
	m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP -1].setRampDownTime( 1000 ); // 
	m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP -1].setDuration(durationExt);
	if( !( m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP -1].prep() ) || !( m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP -1].check() ) )
		return m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP -1].getNLSStatus();
*/
	/*
	// Prepare Y external gradients
	for(int i = 0; i<MAX_NB_EXTERN_STEP; i++){
		m_ExternActuatePulseY[i].setMaxMagnitude(20.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeY));
		m_ExternActuatePulseY[i].setAmplitude(0.0);
		m_ExternActuatePulseY[i].setRampTimes( 1000 ); // 
		m_ExternActuatePulseY[i].setDuration(20000);
		if( !( m_ExternActuatePulseY[i].prep() ) || !( m_ExternActuatePulseY[i].check() ) )
			return m_ExternActuatePulseY[i].getNLSStatus();
	}

	// Prepare Z external gradients
	for(int i = 0; i<MAX_NB_EXTERN_STEP; i++){
		m_ExternActuatePulseZ[i].setMaxMagnitude(20.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeZ));
		m_ExternActuatePulseZ[i].setAmplitude(0.0);
		m_ExternActuatePulseZ[i].setRampTimes( 1000 ); // 
		m_ExternActuatePulseZ[i].setDuration(20000);
		if( !( m_ExternActuatePulseZ[i].prep() ) || !( m_ExternActuatePulseZ[i].check() ) )
			return m_ExternActuatePulseZ[i].getNLSStatus();
	}
*/
#endif //NOTFOREXECUTE
	//double amplitu[10] = {23, -23, 23, -23, 23, -23, 23, -23, 23, -23};
	double amplituX[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
	double amplituY[10] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2};
	double amplituZ[10] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3};

	// Prepare the X-actuation bloc before tracking
	for(int i = 0; i<m_nbGradBeforeTrack; i++){
		m_ExternActuatePulseX[i].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_ExternActuatePulseX[i].setAmplitude(amplituX[i]);
		m_ExternActuatePulseX[i].setRampTimes( 500 ); // 
		m_ExternActuatePulseX[i].setDuration(durationExt);
		
		if(i == 0)
		{
			m_ExternActuatePulseX[i].setRampUpTime( 500 ); // 
		}
		else if ( i == m_nbGradBeforeTrack-1)
		{
			m_ExternActuatePulseX[i].setRampDownTime( 500 ); // 
		}

		if( !( m_ExternActuatePulseX[i].prep() ) || !( m_ExternActuatePulseX[i].check() ) )
			return m_ExternActuatePulseX[i].getNLSStatus();
	}
		
	// Prepare the X-actuation bloc after tracking
	for(int i = m_nbGradBeforeTrack; i<MAX_NB_EXTERN_STEP; i++){
		m_ExternActuatePulseX[i].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_ExternActuatePulseX[i].setAmplitude(amplituX[i]);
		m_ExternActuatePulseX[i].setRampTimes( 500 ); // 
		m_ExternActuatePulseX[i].setDuration(durationExt);
		
		if(i == m_nbGradBeforeTrack)
		{
			m_ExternActuatePulseX[i].setRampUpTime( 500 ); // 
		}
		else if ( i == MAX_NB_EXTERN_STEP-1)
		{
			m_ExternActuatePulseX[i].setRampDownTime( 500 ); // 
		}

		if( !( m_ExternActuatePulseX[i].prep() ) || !( m_ExternActuatePulseX[i].check() ) )
			return m_ExternActuatePulseX[i].getNLSStatus();
	}

#ifdef WIN32		
	cout << "m_ExternActuatePulseX Dump " << endl;
	for(int i = 0; i<MAX_NB_EXTERN_STEP; i++)
	{
		cout << "pulse " << i << " Ramp up: " << m_ExternActuatePulseX[i].getRampUpTime()
                              << " Ramp Down: " << m_ExternActuatePulseX[i].getRampDownTime()
                              << " Duration: " << m_ExternActuatePulseX[i].getDuration() << endl;
	}
#endif

	//amplitu = 1.0;
	// Prepare the Y-actuation bloc before tracking
	for(int i = 0; i<m_nbGradBeforeTrack; i++){
		m_ExternActuatePulseY[i].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_ExternActuatePulseY[i].setAmplitude(amplituY[i]);
		m_ExternActuatePulseY[i].setRampTimes( 500 ); // 
		m_ExternActuatePulseY[i].setDuration(durationExt);
		if(i == 0)
		{
			m_ExternActuatePulseY[i].setRampUpTime( 500 ); // 
		}
		else if ( i == m_nbGradBeforeTrack-1)
		{
			m_ExternActuatePulseY[i].setRampDownTime( 500 ); // 
		}

		if( !( m_ExternActuatePulseY[i].prep() ) || !( m_ExternActuatePulseY[i].check() ) )
			return m_ExternActuatePulseY[i].getNLSStatus();
	}
		
	// Prepare the Y-actuation bloc after tracking
	for(int i = m_nbGradBeforeTrack; i<MAX_NB_EXTERN_STEP; i++){
		m_ExternActuatePulseY[i].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_ExternActuatePulseY[i].setAmplitude(amplituY[i]);
		m_ExternActuatePulseY[i].setRampTimes( 500 ); // 
		m_ExternActuatePulseY[i].setDuration(durationExt);
		if(i == m_nbGradBeforeTrack)
		{
			m_ExternActuatePulseY[i].setRampUpTime( 500 ); // 
		}
		else if ( i == MAX_NB_EXTERN_STEP-1)
		{
			m_ExternActuatePulseY[i].setRampDownTime( 500 ); // 
		}

		if( !( m_ExternActuatePulseY[i].prep() ) || !( m_ExternActuatePulseY[i].check() ) )
			return m_ExternActuatePulseY[i].getNLSStatus();
	}

//amplitu = 1.0;
		// Prepare Z external gradients
	// Prepare the Z-actuation bloc before tracking
	for(int i = 0; i<m_nbGradBeforeTrack; i++){
		m_ExternActuatePulseZ[i].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_ExternActuatePulseZ[i].setAmplitude(amplituZ[i]);
		m_ExternActuatePulseZ[i].setRampTimes( 500 ); // 
		m_ExternActuatePulseZ[i].setDuration(durationExt);
		if(i == 0)
		{
			m_ExternActuatePulseZ[i].setRampUpTime( 500 ); // 
		}
		else if ( i == m_nbGradBeforeTrack-1)
		{
			m_ExternActuatePulseZ[i].setRampDownTime( 500 ); // 
		}

		if( !( m_ExternActuatePulseZ[i].prep() ) || !( m_ExternActuatePulseZ[i].check() ) )
			return m_ExternActuatePulseZ[i].getNLSStatus();
	}
		
	// Prepare the Z-actuation bloc after tracking
	for(int i = m_nbGradBeforeTrack; i<MAX_NB_EXTERN_STEP; i++){
		m_ExternActuatePulseZ[i].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_ExternActuatePulseZ[i].setAmplitude(amplituZ[i]);
		m_ExternActuatePulseZ[i].setRampTimes( 500 ); // 
		m_ExternActuatePulseZ[i].setDuration(durationExt);
		if(i == m_nbGradBeforeTrack)
		{
			m_ExternActuatePulseZ[i].setRampUpTime( 500 ); // 
		}
		else if ( i == MAX_NB_EXTERN_STEP-1)
		{
			m_ExternActuatePulseZ[i].setRampDownTime( 500 ); // 
		}

		if( !( m_ExternActuatePulseZ[i].prep() ) || !( m_ExternActuatePulseZ[i].check() ) )
			return m_ExternActuatePulseZ[i].getNLSStatus();
	}

	return lStatus;
}

// --------------------------------------------------------------------------------------------
///  \brief    This method apply the external actuation pulses, interleaved with the 
///                 tracking pulse 
///
///
///  \param    rMrProt      
///
///  \return   \arg \c SEQU__NORMAL  : If the Real time event bloc is okay
///            \arg \c SEQU_ERROR    : Otherwise
// --------------------------------------------------------------------------------------------
NLS_STATUS MiniFlash::applyInitPulse(MrProt &rMrProt, long& lT, long lLine)
{
	NLS_STATUS         lStatus  = SEQU__NORMAL;
	long trackTime = 0, nbGradBeforeTrack = 0;
	double totActuationTime;
	bool wakeupSent = false, trackingSent = false;
	double static time_sin = 0.0;
	double deltaTheta = M_PI;
	double tempDurationGrad;

	//if(m_isRotorCenterAndRaduisFound == false)
	//{
		for(int i = 0; i < MAX_NB_EXTERN_STEP; i++)
		{	

			m_InitPulseY[i].setAmplitude(0.0);
			m_InitPulseX[i].setAmplitude(24.0*cos((deltaTheta*time_sin) ));
			m_InitPulseZ[i].setAmplitude(24.0*sin(-(deltaTheta*time_sin)));

			//cout << 23.0*cos((deltaTheta*time_sin)) << endl;
			//cout << 23.0*sin(-(deltaTheta*time_sin))<< endl;
			//m_ExternActuatePulseX[i].setAmplitude(5.0);
			//m_ExternActuatePulseZ[i].setAmplitude(5.0);

			//cout << "cos((g_deltaTheta*g_time_sin) " << cos(g_deltaTheta*g_time_sin)    << endl;
			//cout << "sin(-(g_deltaTheta*g_time_sin) " << sin(-(g_deltaTheta*g_time_sin))    << endl;

			if( !( m_InitPulseX[i].prep() ) || !( m_InitPulseX[i].check() ) )
				return m_InitPulseX[i].getNLSStatus();

			if( !( m_InitPulseY[i].prep() ) || !( m_InitPulseY[i].check() ) )
				return m_InitPulseY[i].getNLSStatus();

			if( !( m_InitPulseZ[i].prep() ) || !( m_InitPulseZ[i].check() ) )
				return m_InitPulseZ[i].getNLSStatus();

			time_sin += 0.01;

		}
	//}

		fRTEI( lT+=m_InitPulseX[0].getRampDownTime(),  0, 0,  0, 0,0,0,0);

		if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == EXTERNGRD_TRACKACTUATE)
		{
			OnErrorReturn((NLS_STATUS)applySETrackingActuation(rMrProt, lT, lLine));
			//OnErrorReturn((NLS_STATUS)applySETracking(rMrProt, lT, lLine));

		}
		else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == SPIN_ECHO)
		{
			OnErrorReturn((NLS_STATUS)applySETracking(rMrProt, lT, lLine));
			//OnErrorReturn((NLS_STATUS)applySEImagingForCapsules(rMrProt, lT, lLine));
			//OnErrorReturn((NLS_STATUS)applyActiveMarkerSEImaging(rMrProt, lT, lLine));
			
		}
		else if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == GRADIENT_ECHO)
		{
			OnErrorReturn((NLS_STATUS)applyGRETracking(rMrProt, lT, lLine));
		}

	fRTEI( lT,  0, 0,  0, 0,0,0,&m_sWakeUp);
	for (int i = 0; i<MAX_NB_EXTERN_STEP; i++)
	{

		if( i == 0)
			fRTEI( lT+=0,  0, 0,  0, &m_InitPulseX[i],&m_InitPulseZ[i],&m_InitPulseY[i],0);
		else
		{
			fRTEI( lT+=m_InitPulseX[i].getDuration(),  0, 0,  0, &m_InitPulseX[i],&m_InitPulseZ[i],&m_InitPulseY[i],0);
	
		}
	}	


	return lStatus;
}

NLS_STATUS MiniFlash::prepareInitPulse(MrProt &rMrProt)
{
	NLS_STATUS         lStatus  = SEQU__NORMAL;
	
	for(int i = 0; i<MAX_NB_EXTERN_STEP; i++){
		m_InitPulseX[i].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_InitPulseY[i].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_InitPulseZ[i].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));

		m_InitPulseX[i].setDuration(10000.0);
		m_InitPulseY[i].setDuration(10000.0);
		m_InitPulseZ[i].setDuration(10000.0);

		m_InitPulseX[i].setAmplitude(0.0);
		m_InitPulseY[i].setAmplitude(0.0);
		m_InitPulseZ[i].setAmplitude(0.0);
	
		m_InitPulseX[i].setRampTimes( 500.0 ); // 
		m_InitPulseY[i].setRampTimes( 500.0 ); // 
		m_InitPulseZ[i].setRampTimes( 500.0 ); // 

		if( !( m_InitPulseX[i].prep() ) || !( m_InitPulseX[i].check() ) )
			return m_InitPulseX[i].getNLSStatus();
		if( !( m_InitPulseY[i].prep() ) || !( m_InitPulseY[i].check() ) )
			return m_InitPulseY[i].getNLSStatus();
		if( !( m_InitPulseZ[i].prep() ) || !( m_InitPulseZ[i].check() ) )
			return m_InitPulseZ[i].getNLSStatus();


	}
	return lStatus;
}
