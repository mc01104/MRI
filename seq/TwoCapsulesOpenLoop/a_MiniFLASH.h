//    -----------------------------------------------------------------------------
//      Copyright (C) Siemens AG 1998  All Rights Reserved.
//    -----------------------------------------------------------------------------
//
//     Project: NUMARIS/4
//        File: \n4_servers1\pkg\MrServers\MrImaging\seq\a_MiniFLASH\a_MiniFLASH.h
//     Version: \main\9
//      Author: Clinical
//        Date: 2010-12-02 19:49:26 +01:00
//
//        Lang: C++
//
//     Descrip: Declarations for a_MiniFLASH.cpp
//
//     Remarks: This is the demo sequence MiniFLASH.
//              DO NOT base any diagnosis on images generated by this sequence.
//
//    -----------------------------------------------------------------------------


// Make sure that this header is read only once:
#ifndef a_MiniFlash_h
#define a_MiniFlash_h 1

//------------------------------
// Includes
//------------------------------

#include "MrServers/MrMeasSrv/MeasUtils/nlsmac.h"
#include "MrServers/MrImaging/libSBB/StdSeqIF.h"
#include "MrServers/MrImaging/libSeqUtil/libSeqUtil.h"

#include "MrServers/MrMeasSrv/SeqFW/libGSL/libGSL.h"               // fGSL... prototypes
#include "MrServers/MrMeasSrv/SeqFW/libSSL/libSSL.h"               // fSSL... prototypes
#include "MrServers/MrImaging/libSBB/libSBBmsg.h"                  // SBB_... error codes

#include "MrServers/MrProtSrv/MrProt/KSpace/MrKSpace.h"            // For KSpace
#include "MrServers/MrProtSrv/MrProt/MeasParameter/MrSysSpec.h"    // For GradSpec
#include "MrServers/MrProtSrv/MrProt/MeasParameter/MrRXSpec.h"     // For MrRXSpec
#include "MrServers/MrProtSrv/MrProt/MrProt.h"                     // MrProt
#include "MrServers/MrMeasSrv/SeqIF/SeqBuffer/SeqLim.h"            // SeqLim
#include "MrServers/MrProtSrv/MrProt/SeqIF/SeqExpo.h"              // SeqExpo
#include "MrServers/MrMeasSrv/SeqIF/libRT/sREADOUT.h"              // sREADOUT
#include "MrServers/MrMeasSrv/SeqIF/libRT/sGRAD_PULSE.h"           // sGRAD_PULSE
#include "MrServers/MrMeasSrv/SeqIF/libRT/sRF_PULSE.h"             // sRF_PULSE
#include "MrServers/MrMeasSrv/SeqIF/libRT/sFREQ_PHASE.h"           // sFREQ_PHASE

#include "MrServers/MrMeasSrv/SeqIF/libRT/SEQSemaphore.h" 

#include "MrServers/MrMeasSrv/SeqIF/libMES/SEQData.h"

#include "MrServers/MrMeasSrv/SeqIF/Sequence/sequmsg.h"
#include "MrServers/MrImaging/seq/common/WIPParameterTool/WIPParameterTool.h"

#ifdef _VB_LINE
#include "MrServers/MrProtSrv/MrProt/SeqDefines.h"
#endif


#ifdef WIN32
	#include "TCHAR.h"
#endif

#ifdef BUILD_SEQU
    #define __OWNER
#endif

// The following include is necessary for the DLL generation
#include "MrCommon/MrGlobalDefinitions/ImpExpCtrl.h"



#define MAX_NB_STEP 100
#define MAX_NB_EXTERN_STEP 10
#define PERIOD_FB_GRAD 5000 // micro seconds
#define MILLI_TO_MICROSECONDS 1000
//------------------------------
// Forward declarations
//------------------------------

class MrProt;
class SeqLim;
class SeqExpo;
class SEQData;
class Sequence;

namespace SEQ_NAMESPACE
{
	enum WIPParameterPositions {
        WIPDblePosAmplitude  ,
		WIPDblePulseWidth1   ,
		WIPDblePulseWidth2   ,
		WIPDblePulseWidth3   ,
		WIPLongN1            ,
		WIPLongN2            ,
		WIPLongN3            ,
		WIPDbleTOFF          ,
		WIPSelectionPlane    ,
    };

/*	enum WIPParameterTYPE_OPTION {
		  SINUSOIDALE = 10,
		  CONSTANTGRD = 20,
		  EXTERNGRD = 30,
		  SQUAREWAVE = 40,
		  SINUSOIDALE_XAXIS = 50,
		  SINUSOIDALE_YAXIS = 60,
		  SINUSOIDALE_ZAXIS = 70,
	};

	enum WIPParameterSEQ_OPTION {
		  SPIN_ECHO = 100,
		  GRADIENT_ECHO = 200,
		  NO_TRACKING = 300,
	};
	*/
	enum WIPParameterPLANE_OPTION {
		X_X = 1,
		Y_Y = 2,
		Z_Z = 3,
//		ARB1 = 4,
	//	ARB2 = 5,
    };
/*
    static const char* sOptionType1  = "Sinusoidal gradients";
    static const char* sOptionType2  = "Constant gradients";
	static const char* sOptionType3  = "Extern gradients";
	static const char* sOptionType4  = "Square Wave gradients";
	static const char* sOptionType5  = "cos in x";
	static const char* sOptionType6  = "cos in y";
	static const char* sOptionType7  = "cos in z";
*/
    static const char* sOptionDirection1 = "x";
	static const char* sOptionDirection2 = "y";
	static const char* sOptionDirection3 = "z";
	//static const char* sOptionPlane4 = "ARB1";
	//static const char* sOptionPlane5 = "ARB2";
    //static const char* sOptionSeq1   = "Spin Echo";
	//static const char* sOptionSeq2   = "Gradient echo";
	//static const char* sOptionSeq3   = "No tracking ";


	static int iUTraceMarker = 0;


    // forward declaration
    class MiniFlashUI;

	/**
	 * @brief The MiniFlash sequence class is intended as a demo implementation for teaching purposes. Therefore, all
	 * functions are implemented in a "minimalistic" fashion.
	 */
    class __IMP_EXP MiniFlash : public StdSeqIF
    {
    public:
		/**
		 * @brief Standard constructor.
		 * 
		 * Creates a MiniFlash object with all class member objects being initialized.
		 */
        MiniFlash();


		/**
		 * @brief Destructor.
		 * 
		 * The MiniFlash sequence is destructed. A potentially associated MiniFlashUI object will
		 * be deleted.
		 */
        virtual ~MiniFlash();


		/**
		 * @brief Initialization of the sequence.
		 *
		 * This method is equivalent to the former fSeqInit(...)-function.
		 *
		 * Basically, the "hard limits" for the protocol parameters are set. The hard limits define the maximum
		 * allowed range for each parameter.
		 *
		 * In addition, the associated MiniFlashUI object is created on the Windows-32 (host) machine.
		 *
		 * @return If running on a Windows-32-machine, the status will tell whether the creation of MiniFlashUI
		 *         was successful. If not running on a Windows-32-machine, the return value will always
		 *         "SEQU__NORMAL".
		 */
        virtual NLSStatus initialize(SeqLim &rSeqLim);


		/**
		 * @brief Preparation of the sequence.
		 *
		 * This method is equivalent to the former fSeqPrep(...)-function. It checks whether or not the
		 * current protocol is valid (i.e. a sequence run with the given parameters is possible).
		 *
		 * The method is called during the binary search (graphical user interface of EXAM or POET) and prior
		 * to executing a sequence.
		 *
		 * @return Success is indicated by "SEQU__NORMAL". Otherwise, the appropriate error code is returned.
		 */
        virtual NLSStatus prepare(MrProt &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo);


		/**
		 * @brief Check of the sequence.
		 *
		 * This method is equivalent to the former fSeqCheck(...)-function. It checks whether or not the
		 * sequence could do any harm to the patient. This could be:
		 *
		 * - nerve stimulation in the patient
		 * - exceeding of the specific absorbtion rate (SAR) limit
		 *
		 * @return Success is indicated by "SEQU__NORMAL". Otherwise, the appropriate error code is returned.
		 */
        virtual NLSStatus check(MrProt &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo, SEQCheckMode *  pSEQCheckMode);


        // * ---------------------------------------------------------------------- *
        // *                                                                        *
        // * Name        :  MiniFlash::run                                          *
        // *                                                                        *
        // * Description :  Execution of the sequence                               *
        // *                                                                        *
        // * Return      :  NLS status                                              *
        // *                                                                        *
        // * ---------------------------------------------------------------------- *
        virtual NLSStatus run(MrProt &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo);


        // * ---------------------------------------------------------------------- *
        // *                                                                        *
        // * Name        :  Fl3d_ce::runKernel                                      *
        // *                                                                        *
        // * Description :  Executes the basic timing of the real-time sequence.    *
        // *                                                                        *
        // * Return      :  NLS status                                              *
        // *                                                                        *
        // * ---------------------------------------------------------------------- *
        virtual NLS_STATUS runKernel(MrProt &rMrProt,SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo, long lKernelMode, long lSlice, long lPartition, long lLine);

        // * ---------------------------------------------------------------------- *
        // *                                                                        *
        // * Name        :  MiniFlash::receive                                      *
        // *                                                                        *
        // * Description :  Executes the basic timing of the real-time sequence.    *
        // *                                                                        *
        // * Return      :  NLS status                                              *
        // *                                                                        *
        // * ---------------------------------------------------------------------- *
		virtual NLSStatus receive(SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo, SEQData& rSEQData);
                
        //  --------------------------------------------------------------
        //
        //  Name        :  getUI
        //
        //  Description :
        /// \brief <b>     Returns the pointer to the Templ UI class  </b>
        ///
        ///                This method is only sensible on the host.
        ///                On the measurement system, it will return an nearly empty object.
        ///
        //  Return      :  MiniFlashUI*
        //
        //  --------------------------------------------------------------
        const MiniFlashUI* getUI (void) const;


protected:
    // * ---------------------------------------------------------------------- *
    // * RF spoiling phase                                                      *
    // * ---------------------------------------------------------------------- *
    double m_dRFSpoilPhase;


    // * ---------------------------------------------------------------------- *
    // * Increment of the Rf spoiling phase                                     *
    // * ---------------------------------------------------------------------- *
    double m_dRFSpoilIncrement;


    // * ---------------------------------------------------------------------- *
    // * Index of the k-space center line                                       *
    // * ---------------------------------------------------------------------- *
    long m_lCenterLine;

    // * ---------------------------------------------------------------------- *
    // * flag to signal that feedback is received                               *
    // * ---------------------------------------------------------------------- *

	bool m_feedbackReceived;

    // * ---------------------------------------------------------------------- *
    // * Mini Rise Time                                                         *
    // * ---------------------------------------------------------------------- *
    double m_dMinRiseTime;


    // * ---------------------------------------------------------------------- *
    // * Mini Rise Time                                                         *
    // * ---------------------------------------------------------------------- *
    double m_dGradMaxAmpl;


    // * ---------------------------------------------------------------------- *
    // * No of phase encoding lines measured per second                         *
    // * ---------------------------------------------------------------------- *
    long m_lLinesPerSec;


    // * ---------------------------------------------------------------------- *
    // * No of phase encoding lines with iPAT                                   *
    // * m_lLinesToMeasure and m_lLinesToMeasureMax are identical if iPAT is    *
    // * disabled.                                                              *
    // * ---------------------------------------------------------------------- *
    int32_t m_lLinesToMeasure;


    // * ---------------------------------------------------------------------- *
    // * Slice position information (rotation matrices and shifts)              *
    // * ---------------------------------------------------------------------- *
    sSLICE_POS m_asSLC[1];
	        
	// * ---------------------------------------------------------------------- *
    // * RF Pulses and NCO                                                      *
    // * ---------------------------------------------------------------------- *
    sRF_PULSE_RECT    m_sSRF01;
    sFREQ_PHASE      m_sSRF01zSet;
    sFREQ_PHASE      m_sSRF01zNeg;

	sRF_PULSE_RECT    m_sSRF02;
    sFREQ_PHASE      m_sSRF02zSet;
    sFREQ_PHASE      m_sSRF02zNeg;

    // * ---------------------------------------------------------------------- *
    // * Read Out                                                               *
    // * ---------------------------------------------------------------------- *
    sREADOUT         m_sADCX;
    sFREQ_PHASE      m_sADCX_zSet;
    sFREQ_PHASE      m_sADCX_zNeg;
    // * Feedback Generator                                                     *
	sREADOUT         m_sADCY;
    sFREQ_PHASE      m_sADCY_zSet;
    sFREQ_PHASE      m_sADCY_zNeg;
	// * ---------------------------------------------------------------------- *
    // * Gradient                                                               *
    // * ---------------------------------------------------------------------- *
    sGRAD_PULSE_RO   m_sGradRO     ;
    sGRAD_PULSE      m_sGReadDeph  ;
	// * ---------------------------------------------------------------------- *
    // * Sync Bits                                                              *
    // * ---------------------------------------------------------------------- *

	sSYNC_WAKEUP m_sWakeUp;

    // * ---------------------------------------------------------------------- *
    // * Propulsion gradients                                                   *
    // * ---------------------------------------------------------------------- *

	sGRAD_PULSE      m_sGActuate1;
	sGRAD_PULSE      m_sGActuate2;
	sGRAD_PULSE      m_sGActuate3;

	//sGRAD_PULSE      m_sGActuateZ;
	//sGRAD_PULSE	     m_SinActuatePulse[MAX_NB_STEP];
	//sGRAD_PULSE	     m_ExternActuatePulseX[MAX_NB_EXTERN_STEP];
	//sGRAD_PULSE	     m_ExternActuatePulseY[MAX_NB_EXTERN_STEP];
	//sGRAD_PULSE	     m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP];

    int			     m_nbStep;

	SEQSemaphore m_sFeedbackSemaphore;          // used to synchronise run and receive
	
	uint16_t m_loop_test; 

	long tOff1;
	long tOff2;
	long m_c1; //counter used for interleaved pulses open loop (pulse 1)
	long m_c2; //counter used for interleaved pulses open loop (pulse 2)
	long m_c3; //counter used for interleaved pulses open loop (pulse 3)

	bool m_isRotorCenterAndRaduisFound;

    //  --------------------------------------------------------------
    /// \brief <b> UI class for Templ
    ///
    ///         This class is basically empty on the measurement system
    //  --------------------------------------------------------------
    MiniFlashUI* m_pUI;

    //  ------------------------------------------------------------------
    //
    //  Name        :  MiniFlash::createUI
    //
    //  Description :
    /// \brief <b>     Instantiation of UI classes   </b>
    //
    //  Return      :  NLS status
    //
    //  ------------------------------------------------------------------
    virtual NLS_STATUS createUI (SeqLim &rSeqLim);
    
	

    //  ------------------------------------------------------------------
    //
    //  Name        :  MiniFlash::UnusedArg
    //
    //  Description :
    /// \brief         Used to avoid compiler warnings
    //
    //  Return      :  void
    //
    //  ------------------------------------------------------------------
    template< class TYPE > void UnusedArg (TYPE Argument) const { if( false ) { TYPE Dummy; Dummy = Argument; } };

	// * ---------------------------------------------------------------------- *
    // * User interface                                                         *
    // * ---------------------------------------------------------------------- *
	WPT_NAMESPACE::WIPParameterTool m_WIPParamTool;
private:

    // * ------------------------------------------------------------------ *
    // * Copy constructor not implemented                                   *
    // * ------------------------------------------------------------------ *
    MiniFlash (const MiniFlash &right);



    // * ------------------------------------------------------------------ *
    // * Assignment operator not implemented                                *
    // * ------------------------------------------------------------------ *
    MiniFlash & operator=(const MiniFlash &right);

	void applyRotMatrix(long axis);
};
};

#endif
