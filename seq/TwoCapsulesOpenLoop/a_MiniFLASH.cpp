//-----------------------------------------------------------------------------
//  Copyright (C) Siemens AG 1998-2006  All Rights Reserved.  Confidential
//-----------------------------------------------------------------------------
//
// Project: NUMARIS/4
//
//    File: \n4\pkg\MrServers\MrImaging\seq\a_MiniFLASH\a_MiniFLASH.cpp
//
// Authors: Mark Brown;       SMS MED US CSG TDC;
//          Brian Dale;       SMS MED US CSG MR R&D;
//          Wolfgang Rehwald; SMS MED US CSG MR R&D;
//          Keith Heberlein;  SMS MED US CSG MR R&D;
//
//          Original Author:  Anonymous
//
//    Lang: C++
//
// Descrip: This is the demo sequence MiniFLASH.
//          DO NOT base any diagnosis on images generated by this sequence.
//
//////////////////////////////////////////////////////////////////////////////////////////
//
//                                MiniFLASH Sequence Diagram
//
//                       |-----------TE-------------|
//
//              RF --|sSRF01|--------------------------------------------
//
//              Gs -|sGSliSel|-|sGSliSelReph|-------------|sGSpoil|------
//
//              Gp ----------|sGPhasEnc|------------------|sGPhasEncRew|-
//
//              Gr ----------|sGReadDeph|-------|sGradRO|----------------
//
//             ADC -----------------------------|sADC01|-----------------
//
//                |------------------------------TR----------------------|
//
///////////////////////////////////////////////////////////////////////////////////////////

#include "MrServers/MrImaging/seq/TwoCapsulesOpenLoop/a_MiniFLASH.h"
#include "MrServers/MrImaging/seq/common/feedbackData.h"
#include "MrServers/MrImaging/seq/TwoCapsulesOpenLoop/a_MiniFLASH_UI.h"
#include "MrServers/MrMeasSrv/SeqIF/csequence.h"
#include "MrServers/MrImaging/libSeqSysProp/SysProperties.h"
#include "MrServers/MrImaging/seq/SystemProperties.h"        // Siemens system properties
#include "MrServers/MrImaging/ut/libsequt.h"                 // for mSEQTest

#ifdef WIN32
    #include "MrServers/MrMeasSrv/SeqIF/Sequence/Sequence.h"
    #include <iostream>
	using namespace std;
#endif

//#include <iostream>
// Macro: return S, if S is an error code
// (applies to functions returning MRRESULT-values)
#define OnErrorReturn(S) if(!MrSucceeded(S)) return(S)


#ifndef SEQ_NAMESPACE
    #error SEQ_NAMESPACE not defined
#endif



//  --------------------------------------------------------------------------
//
//  Name        :  SEQIF_DEFINE
//
//  Description :
///  \brief        Create instance of the sequence
//
//  Return      :  SeqIF *
//
//  --------------------------------------------------------------------------
#ifdef SEQUENCE_CLASS_MiniFLASH
    SEQIF_DEFINE (SEQ_NAMESPACE::MiniFlash)
#endif
using namespace SEQ_NAMESPACE;
using namespace WPT_NAMESPACE;

MiniFlash::MiniFlash()
        : m_sGActuate1          ("sGActuate1")
		, m_sGActuate2          ("sGActuate2")
		, m_sGActuate3          ("sGActuate3")
		, m_sWakeUp             ("sWakeUp")
		, m_sSRF01				("sSRF01")
		, m_sSRF01zSet          ("sSRF01zSet")
		, m_sSRF01zNeg			("sSRF01zNeg")
		, m_sSRF02				("sSRF02")
		, m_sSRF02zSet          ("sSRF02zSet")
		, m_sSRF02zNeg			("sSRF02zNeg")
		, m_sADCX				("sADCX")
		, m_sADCX_zSet			("sADCX_zSet")
		, m_sADCX_zNeg			("sADCX_zNeg")
		, m_sADCY				("sADCY")
		, m_sADCY_zSet			("sADCY_zSet")
		, m_sADCY_zNeg			("sADCY_zNeg")
		, m_sGradRO				("sGradRO")
		, m_sGReadDeph			("sGReadDeph")
		, m_feedbackReceived    (false)
        , m_nbStep              (MAX_NB_STEP)   //MAX_NB_STEP     
		, m_lLinesToMeasure     (0)
        , m_lLinesPerSec        (0)
        , m_lCenterLine         (0)
        , m_dRFSpoilIncrement   (0)
        , m_dRFSpoilPhase       (0)
        , m_dMinRiseTime        (100000)
		, m_loop_test           (0)
        , m_dGradMaxAmpl        (0)
		, tOff1                 (0)
		, tOff2                 (0)
        , m_pUI                 (new MiniFlashUI()) 
		, m_WIPParamTool        (*this)
{
	/*
   for (int i =0; i<m_nbStep; i++)
	   m_SinActuatePulse[i].setIdent("SinActuatePulse");

   for (int i =0; i<MAX_NB_EXTERN_STEP; i++)
   {
	   m_ExternActuatePulseX[i].setIdent("ExternActuatePulseX");
	   m_ExternActuatePulseY[i].setIdent("ExternActuatePulseY");
	   m_ExternActuatePulseZ[i].setIdent("ExternActuatePulseZ");
   }
   */
   m_isRotorCenterAndRaduisFound = false;
	m_c1 = 0;
	m_c2 = 0;
	m_c3 = 0;
}


MiniFlash::~MiniFlash() {
    if(NULL != m_pUI) {
        // delete the user interface (UI) instance (if a UI instance has been created)
        delete m_pUI;
        m_pUI = NULL;
    }
}



NLSStatus MiniFlash::initialize(SeqLim &rSeqLim) {
    // This string is intended to store, where we are in the code (used for debugging by the MRTRACE macro).
    static const char *ptModule = {"MiniFLASH::initialize"};

    // Default return value
    NLS_STATUS lStatus = SEQU__NORMAL;

	rSeqLim.setMyOrigFilename ( __FILE__ );
	rSeqLim.setSequenceOwner ("USER");
    // -----------------------
    // Setting the hard limits
    // -----------------------
   // Define selectable gradient modes
    rSeqLim.setGradients(
        SEQ::GRAD_FAST,
        SEQ::GRAD_NORMAL,
        SEQ::GRAD_WHISPER,
        SEQ::GRAD_FAST_GSWD_RISETIME,
        SEQ::GRAD_NORMAL_GSWD_RISETIME,
        SEQ::GRAD_WHISPER_GSWD_RISETIME
    );

	rSeqLim.disableSAFEConsistencyCheck();
    // RF frequency is given as a long integer number in Hertz
    // The maximum allowed RF frequency is sufficient for 1H (hydrogen nuclei) in a 3-Tesla-system
    //                         (    min,       max)
    rSeqLim.setAllowedFrequency(8000000, 130850000);


    // The repetition time (TR) and echo time (TE) are given as long integer numbers in micro seconds.
    //                              (index,  min,        max,    increment,  default)
    rSeqLim.setTR                   (    0,  100,    5000000,           10,    20000);
    rSeqLim.setTE                   (    0,  100,     100000,           10,    10000);
    rSeqLim.setBandWidthPerPixel    (    0,   80,        900,           10,      260);


    // The flip angle is given as a double number in degrees.
    //                              (        min,        max,    increment,  default)
    rSeqLim.setFlipAngle            (       10.0,       90.0,          1.0,   90.000);
    //rSeqLim.setExtSrfFilename                                     ("%MEASDAT%/extrf.dat")  ;


    // The base resolution tells how many samples in readout direction are acquired in k-space. The increment-value
    // is not set directly. Instead, a key is used which is connected to values of 16, 32, 64, etc. The allowed
    // values can be looked up in "kSpaceDefines.h".
    //                              (        min,        max,    increment,  default)
    rSeqLim.setBaseResolution       (         64,        512,  SEQ::INC_64,      128); //INC_BASE2 also available
 
	

    // The field-of-view (FOV) is given as double numbers in mm.
    //                              (        min,        max,    increment,  default)
    rSeqLim.setReadoutFOV           (        100,        500,            1,      300);
    rSeqLim.setPhaseFOV             (        100,        500,            1,      300);


    // Here, we set the number of lines in phase encoding(PE)-direction.
    //                              (        min,        max,    increment,  default)
    rSeqLim.setPELines              (         32,       1024,            1,      128);


    // The MiniFLASH sequence is intended for single-slice measurements only.
    //                              (        min,        max,    increment,  default)
    rSeqLim.setSlices               (          1,          1,            1,        1);


    // The slice thickness is given as a double number in mm.
    //                              (        min,        max,    increment,  default)
    rSeqLim.setSliceThickness       (      2.000,     10.000,        0.500,    5.000);


    // --------------------------------------
    // Instantiation of the MiniFlashUI-class
    // --------------------------------------

    

    // MRRESULT_SEV is a mask for the "severity" bits. This if-statement checks whether the severity bits
    // are set (which indicates that something went wrong).
   //if((MRRESULT_SEV & (lStatus = createUI(rSeqLim))) == MRRESULT_SEV) {

        // The MRTRACE macro is used to log information for debugging purposes
       // MRTRACE("Instantiation of MiniFlashUI class failed!");
       // return lStatus;
    //}


    // This compiler directive restricts this code to the HOST version dll.
    // In this way the same source code can be compiled for both the Host and the MARS.
/*
    if(NULL == m_pUI) {
        MRTRACE("MiniFlashUI object pointer is null (creation failed probably)!");
        return ( SEQU_ERROR );
    }
*/

    // ----------------------------------------------
    // Declaration of pointer to UI parameter classes
    // ----------------------------------------------
    lStatus = m_pUI->registerUI(rSeqLim, m_WIPParamTool);
	//lStatus = m_pUI->registerUI(rSeqLim);
    if(MrSeverity(lStatus) != MRRESULT_SUCCESS) {
        MRTRACE("Registering MiniFlashUI object failed! Errorcode: %i", lStatus);
        return lStatus;
    }

    // -----------------------------------------------------------------
    // file containing the default postprocessing protocol (EVAProtocol)
    // -----------------------------------------------------------------
 #ifdef WIN32   
    // The _T(x) macro deals with the unicode conversion of strings.
    rSeqLim.setDefaultEVAProt (_T("%SiemensEvaDefProt%\\Inline\\Inline.evp"));
#endif
    return lStatus;
}



//. -------------------------------------------------------------------------
//.. fSEQPrep: prepare real time elements and calculate energy and timing
//. -------------------------------------------------------------------------
NLSStatus MiniFlash::prepare(MrProt &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo)
{
    static const char *ptModule = {"MiniFlash::prepare"};
    NLS_STATUS   lStatus = SEQU__NORMAL;                     // * Return status *
    long         lTEFil;
    double       dMeasureTimeUsec      = 0.0;
	long durationSin, durationExt;
    // --------------------
    // get some information
    // --------------------

    OnErrorReturn(rMrProt.kSpace().linesToMeasure(m_lLinesToMeasure));

    m_dMinRiseTime = SysProperties::getGradMinRiseTime(rMrProt.gradSpec().mode());
    m_dGradMaxAmpl = SysProperties::getGradMaxAmpl(rMrProt.gradSpec().mode());
    dMeasureTimeUsec = (double)m_lLinesToMeasure * rMrProt.tr()[0];

	// make sure that m_lLinesPerSec is at least 1.
    m_lLinesPerSec =  std::max<long>(1,long(m_lLinesToMeasure * 1000000. /dMeasureTimeUsec));

    m_lCenterLine  = rMrProt.kSpace().echoLine();
/*
    //. Prepare RF pulse
    m_sSRF01.setTypeExcitation   ();
    m_sSRF01.setDuration         (1000) ;
    m_sSRF01.setFlipAngle        (rMrProt.flipAngle());
    m_sSRF01.setInitialPhase     (0);
    m_sSRF01.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF01.setSamples          (100);
   // m_sSRF01.setBandwidthTimeProduct(2.70);
    if(! m_sSRF01.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF01.getNLSStatus());

    //. Prepare RF pulse
    m_sSRF02.setTypeRefocussing  ();
    m_sSRF02.setDuration         (1280) ;
    m_sSRF02.setFlipAngle        (180);
    m_sSRF02.setInitialPhase     (0);
    m_sSRF02.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF02.setSamples          (128);
    //m_sSRF02.setBandwidthTimeProduct(2.70);
    if(! m_sSRF02.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF02.getNLSStatus());

	//. Prepare RF pulse
    m_sSRF01.setTypeExcitation   ();
    m_sSRF01.setDuration         (2560) ;
    m_sSRF01.setFlipAngle        (rMrProt.flipAngle());
    m_sSRF01.setInitialPhase     (90);
    m_sSRF01.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF01.setSamples          (128);
    m_sSRF01.setBandwidthTimeProduct(2.70);
    if(! m_sSRF01.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF01.getNLSStatus());

    m_sSRF02.setTypeExcitation   ();
    m_sSRF02.setDuration         (2560) ;
    m_sSRF02.setFlipAngle        (rMrProt.flipAngle());
    m_sSRF02.setInitialPhase     (0);
    m_sSRF02.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF02.setSamples          (128);
    m_sSRF02.setBandwidthTimeProduct(2.70);
    if(! m_sSRF01.prepSinc(rMrProt,rSeqExpo)) return (m_sSRF01.getNLSStatus());
*/
    /* ------------------------------- */
    /* Prepare the RF pulse structures */
    /* ------------------------------- */
	/*
    m_sSRF01.setTypeExcitation    ();
    m_sSRF01.setDuration          (2560);                       // specified min. ratio of slice select gradients (refoc/excit.) is 1.2
    m_sSRF01.setFlipAngle         (rMrProt.flipAngle());
    m_sSRF01.setInitialPhase      (90);
    m_sSRF01.setFamilyName        ("SE2560A90.SE90_12A2_2") ;
    m_sSRF01.setThickness         (5.0 ) ;

    m_sSRF02.setTypeRefocussing   ();
    m_sSRF02.setDuration          (2560);                       // specified min. ratio of slice select gradients (refoc/excit.) is 1.2
    m_sSRF02.setFlipAngle         (180);
    m_sSRF02.setInitialPhase      (0.0);
    m_sSRF02.setFamilyName        ("SE2560A180.SE180_12A2_2") ;
    m_sSRF02.setThickness         (5.0);

    if(! m_sSRF01.prepExternal(rMrProt,rSeqExpo) )   return (m_sSRF01.getNLSStatus());
    if(! m_sSRF02.prepExternal(rMrProt,rSeqExpo) )   return (m_sSRF02.getNLSStatus());
*/
/*
	    //. Prepare RF pulse
    m_sSRF01.setTypeExcitation   ();
    m_sSRF01.setDuration         (1000) ;
    m_sSRF01.setFlipAngle        (rMrProt.flipAngle());
    m_sSRF01.setInitialPhase     (90);
    m_sSRF01.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF01.setSamples          (100);
    // m_sSRF01.setBandwidthTimeProduct(2.70);
    if(! m_sSRF01.prepRect(rMrProt,rSeqExpo)) return (m_sSRF01.getNLSStatus());

    //. Prepare RF pulse
    m_sSRF02.setTypeRefocussing  ();
    m_sSRF02.setDuration         (1280) ;
    m_sSRF02.setFlipAngle        (180);
    m_sSRF02.setInitialPhase     (0);
    m_sSRF02.setThickness        (rMrProt.sliceSeries().aFront().thickness());
    m_sSRF02.setSamples          (128);
    //m_sSRF02.setBandwidthTimeProduct(2.70);
    if(! m_sSRF02.prepRect(rMrProt,rSeqExpo)) return (m_sSRF02.getNLSStatus());

    //. Prepare ADC
    m_sADCX.setColumns (rMrProt.kSpace().getlBaseResolution());
    m_sADCX.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
    m_sADCX.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));
	//Use the gradient Amplitude in X
    m_sADCX.getMDH().setReadOutOffcentre((float)m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));

	m_sADCY.setColumns (rMrProt.kSpace().getlBaseResolution());
    m_sADCY.setDwellTime ((long)((rMrProt.rxSpec().effDwellTime(rSeqLim.getReadoutOSFactor())[0]) + 0.5));
    m_sADCY.getMDH().setKSpaceCentreColumn((unsigned short)(rMrProt.kSpace().getlBaseResolution()/2));
    m_sADCY.getMDH().setReadOutOffcentre((float)m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeY));

	//. Prepare readout gradient
    if(!m_sGradRO.prepRO(600,(fSDSRoundUpGRT(m_sADCX.getDuration()+600)),
        600,rMrProt,m_sADCX.getDwellTime()))return(m_sGradRO.getNLSStatus());

    //. Prepare and check readout dephasing gradient
    m_sGReadDeph.setMaxMagnitude(m_dGradMaxAmpl);
    m_sGReadDeph.setMinRiseTime(m_dMinRiseTime);
	*/
	/*
	if (! m_sGReadDeph.prepSymmetricTOTShortestTime(-m_sGradRO.getMomentum(
        0,(long)(m_sGradRO.getRampUpTime() + m_sADCX.getDuration()/2))))
        return (m_sGReadDeph.getNLSStatus());
	*/
	/*
	if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionSeq) == SPIN_ECHO){

		if (! m_sGReadDeph.prepSymmetricTOTShortestTime(m_sGradRO.getMomentum(
			0,(long)(m_sGradRO.getRampUpTime() + m_sADCX.getDuration()/2))))
			return (m_sGReadDeph.getNLSStatus());
	}
	else
	{
		if (! m_sGReadDeph.prepSymmetricTOTShortestTime(-m_sGradRO.getMomentum(
			0,(long)(m_sGradRO.getRampUpTime() + m_sADCX.getDuration()/2))))
			return (m_sGReadDeph.getNLSStatus());
	}
*/

/*
	// Prepare sinosoidal pulse
	durationSin = (((long)(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoublePeriod)*1000000) /MAX_NB_STEP)/GRAD_RASTER_TIME) * GRAD_RASTER_TIME ; //micro seconds, pulse length
	for(int i = 0; i<m_nbStep; i++){
		m_SinActuatePulse[i].setMaxMagnitude(42.9);
		m_SinActuatePulse[i].setAmplitude(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitude)*sin( (2*M_PI)/(m_nbStep) * i) );
		m_SinActuatePulse[i].setRampTimes( durationSin ); // 
		m_SinActuatePulse[i].setDuration(durationSin);
		if( !( m_SinActuatePulse[i].prep() ) || !( m_SinActuatePulse[i].check() ) )
			return m_SinActuatePulse[i].getNLSStatus();
	}
*/
	/*

	durationExt = (((long)(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleDurationZ)*1000000) /10)/GRAD_RASTER_TIME) * GRAD_RASTER_TIME ; //micro seconds, pulse length
	// Prepare X external gradients
	m_ExternActuatePulseX[0].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
	m_ExternActuatePulseX[0].setAmplitude(0.0);
	m_ExternActuatePulseX[0].setRampUpTime( 1000 ); // 
	m_ExternActuatePulseX[0].setRampDownTime( durationExt ); // 
	m_ExternActuatePulseX[0].setDuration(durationExt);
	if( !( m_ExternActuatePulseX[0].prep() ) || !( m_ExternActuatePulseX[0].check() ) )
		return m_ExternActuatePulseX[0].getNLSStatus();

	for(int i = 1; i<MAX_NB_EXTERN_STEP -1; i++){
		m_ExternActuatePulseX[i].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_ExternActuatePulseX[i].setAmplitude(0.0);
		m_ExternActuatePulseX[i].setRampTimes( durationExt ); // 
		m_ExternActuatePulseX[i].setDuration(durationExt);
		if( !( m_ExternActuatePulseX[i].prep() ) || !( m_ExternActuatePulseX[i].check() ) )
			return m_ExternActuatePulseX[i].getNLSStatus();
	}
	m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
	m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].setAmplitude(0.0);
	m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].setRampUpTime( durationExt ); // 
	m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].setRampDownTime( 1000 ); // 
	m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].setDuration(durationExt);
	if( !( m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].prep() ) || !( m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].check() ) )
		return m_ExternActuatePulseX[MAX_NB_EXTERN_STEP -1].getNLSStatus();

		// Prepare Y external gradients
		m_ExternActuatePulseY[0].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_ExternActuatePulseY[0].setAmplitude(0.0);
		m_ExternActuatePulseY[0].setRampUpTime( 1000 ); // 
		m_ExternActuatePulseY[0].setRampDownTime( durationExt ); // 
		m_ExternActuatePulseY[0].setDuration(durationExt);
		if( !( m_ExternActuatePulseY[0].prep() ) || !( m_ExternActuatePulseY[0].check() ) )
		return m_ExternActuatePulseY[0].getNLSStatus();

		for(int i = 1; i<MAX_NB_EXTERN_STEP -1; i++){
		m_ExternActuatePulseY[i].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_ExternActuatePulseY[i].setAmplitude(0.0);
		m_ExternActuatePulseY[i].setRampTimes( durationExt ); // 
		m_ExternActuatePulseY[i].setDuration(durationExt);
		if( !( m_ExternActuatePulseY[i].prep() ) || !( m_ExternActuatePulseY[i].check() ) )
		return m_ExternActuatePulseY[i].getNLSStatus();
		}
		m_ExternActuatePulseY[MAX_NB_EXTERN_STEP -1].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_ExternActuatePulseY[MAX_NB_EXTERN_STEP -1].setAmplitude(0.0);
		m_ExternActuatePulseY[MAX_NB_EXTERN_STEP -1].setRampUpTime( durationExt ); // 
		m_ExternActuatePulseY[MAX_NB_EXTERN_STEP -1].setRampDownTime( 1000 ); // 
		m_ExternActuatePulseY[MAX_NB_EXTERN_STEP -1].setDuration(durationExt);
		if( !( m_ExternActuatePulseY[MAX_NB_EXTERN_STEP -1].prep() ) || !( m_ExternActuatePulseY[MAX_NB_EXTERN_STEP -1].check() ) )
		return m_ExternActuatePulseY[MAX_NB_EXTERN_STEP -1].getNLSStatus();

		// Prepare Z external gradients
		m_ExternActuatePulseZ[0].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_ExternActuatePulseZ[0].setAmplitude(0.0);
		m_ExternActuatePulseZ[0].setRampUpTime( 1000 ); // 
		m_ExternActuatePulseZ[0].setRampDownTime( durationExt ); // 
		m_ExternActuatePulseZ[0].setDuration(durationExt);
		if( !( m_ExternActuatePulseZ[0].prep() ) || !( m_ExternActuatePulseZ[0].check() ) )
		return m_ExternActuatePulseZ[0].getNLSStatus();

		for(int i = 1; i<MAX_NB_EXTERN_STEP -1; i++){
		m_ExternActuatePulseZ[i].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_ExternActuatePulseZ[i].setAmplitude(0.0);
		m_ExternActuatePulseZ[i].setRampTimes( durationExt ); // 
		m_ExternActuatePulseZ[i].setDuration(durationExt);
		if( !( m_ExternActuatePulseZ[i].prep() ) || !( m_ExternActuatePulseZ[i].check() ) )
		return m_ExternActuatePulseZ[i].getNLSStatus();
		}
		m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP -1].setMaxMagnitude(26.0);//m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleAmplitudeX));
		m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP -1].setAmplitude(0.0);
		m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP -1].setRampUpTime( durationExt ); // 
		m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP -1].setRampDownTime( 1000 ); // 
		m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP -1].setDuration(durationExt);
		if( !( m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP -1].prep() ) || !( m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP -1].check() ) )
		return m_ExternActuatePulseZ[MAX_NB_EXTERN_STEP -1].getNLSStatus();

		*/

	//. Prepare x, y , and z actuation Gradients
	//if(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionType) == CONSTANTGRD)
	//{
	m_sGActuate1.setMaxMagnitude(42.9);
	if(m_WIPParamTool.getLongValue (rMrProt, WIPLongN1) < 0){
		m_sGActuate1.setAmplitude(-1.0 * m_WIPParamTool.getDoubleValue (rMrProt, WIPDblePosAmplitude));
	}
	else
	{
		m_sGActuate1.setAmplitude(m_WIPParamTool.getDoubleValue (rMrProt, WIPDblePosAmplitude));
	}
	m_sGActuate1.setDuration(300 + m_WIPParamTool.getDoubleValue (rMrProt, WIPDblePulseWidth1)*MILLI_TO_MICROSECONDS);
	m_sGActuate1.setRampDownTime(300);
	m_sGActuate1.setRampUpTime(300);

	if( !( m_sGActuate1.prep() ) ||
	   !( m_sGActuate1.check() ) )
	   return m_sGActuate1.getNLSStatus();

	m_sGActuate2.setMaxMagnitude(42.9);
	if(m_WIPParamTool.getLongValue (rMrProt, WIPLongN2) < 0){
		m_sGActuate2.setAmplitude(-1.0 * m_WIPParamTool.getDoubleValue (rMrProt, WIPDblePosAmplitude));
	}
	else
	{
		m_sGActuate2.setAmplitude(m_WIPParamTool.getDoubleValue (rMrProt, WIPDblePosAmplitude));
	}
	m_sGActuate2.setDuration(300 + m_WIPParamTool.getDoubleValue (rMrProt, WIPDblePulseWidth2)*MILLI_TO_MICROSECONDS);
	m_sGActuate2.setRampDownTime(300);
	m_sGActuate2.setRampUpTime(300);

	if( !( m_sGActuate2.prep() ) ||
	   !( m_sGActuate2.check() ) )
	   return m_sGActuate2.getNLSStatus();

	m_sGActuate3.setMaxMagnitude(42.9);
	if(m_WIPParamTool.getLongValue (rMrProt, WIPLongN3) < 0){
		m_sGActuate3.setAmplitude(-1.0 * m_WIPParamTool.getDoubleValue (rMrProt, WIPDblePosAmplitude));
	}
	else
	{
		m_sGActuate3.setAmplitude(m_WIPParamTool.getDoubleValue (rMrProt, WIPDblePosAmplitude));
	}
	m_sGActuate3.setDuration(300 + m_WIPParamTool.getDoubleValue (rMrProt, WIPDblePulseWidth3)*MILLI_TO_MICROSECONDS);
	m_sGActuate3.setRampDownTime(300);
	m_sGActuate3.setRampUpTime(300);

	if( !( m_sGActuate3.prep() ) ||
	   !( m_sGActuate3.check() ) )
	   return m_sGActuate3.getNLSStatus();

	long N1, N2, N3;
	double ratio;
	N1 = abs(m_WIPParamTool.getLongValue (rMrProt, WIPLongN1));
	N2 = abs(m_WIPParamTool.getLongValue (rMrProt, WIPLongN2));
	N3 = abs(m_WIPParamTool.getLongValue (rMrProt, WIPLongN3));
	m_c1 = N1;
	m_c2 = N2;
	m_c3 = N3;
	/*
	if (N1 != 0 && N2 != 0)
	{
		ratio = (double)N1/(double)N2;
	}
	else
	{
		ratio = 1;
	}



	if(N1>=N2)
	{
		m_c1 = N2; // m_c1 is the smallest
	}
	else
	{
		m_c1 = N1;
	}
	if(ratio > 2)
	{
		m_c2 = 0;
		m_c3 = N1%N2;
	}
	else
	{
		m_c2 = abs(N1-N2);
		m_c3 = 0;
	}
	
*/
	//}

	// calcul time for balancing the timing table for spin echo tracking kernel

	tOff1 = (m_sSRF01.getDuration()/2 + m_sGReadDeph.getTotalTime() + m_sSRF02.getDuration()/2)
	-(m_sSRF02.getDuration()/2 + m_sGradRO.getTotalTime()/2 );

	tOff2 = (m_sSRF02.getDuration()/2 + m_sGradRO.getDuration() + m_sGReadDeph.getTotalTime() + m_sSRF02.getDuration()/2)
	-(m_sSRF02.getDuration()/2 + m_sGradRO.getTotalTime()/2 );

#ifdef WIN32
	cout << "************************************************************************" << endl;
	cout << tOff2 << endl;
	cout << "************************************************************************" << endl;
#endif
    // ------------------------------------------------
    // Preparation of all required real time components
    // ------------------------------------------------
    rSeqExpo.setRelevantReadoutsForMeasTime(m_lLinesToMeasure / m_lLinesPerSec);
    // Set receiver gain
    //OnErrorReturn(fSSLSetRxGain(K_RX_GAIN_CODE_HIGH,rMrProt,rSeqLim));
    // Prepare the slice position array
    OnErrorReturn(fSUPrepSlicePosArray (rMrProt, rSeqLim, m_asSLC));
    // Set sequence string for display in images
    //fSUSetSequenceString              ("fl", rMrProt, rSeqExpo);
	fSUSetSequenceString              ("se", rMrProt, rSeqExpo);
    //. Fill export section
	// oufel RF ENERGY CALCULATION
    rSeqExpo.setRFEnergyInSequence_Ws(0);
    rSeqExpo.setMeasuredPELines      (m_lLinesToMeasure);
    rSeqExpo.setMeasureTimeUsec      (dMeasureTimeUsec);
    rSeqExpo.setTotalMeasureTimeUsec (dMeasureTimeUsec);
    rSeqExpo.setPCAlgorithm          (SEQ::PC_ALGORITHM_NONE);
    rSeqExpo.setOnlineFFT            (SEQ::ONLINE_FFT_PHASE);
    //rSeqExpo.setICEProgramFilename   ("%SiemensIceProgs%\\IceProgramOnline2D");    // Only 2D reconstruction allowed
    rSeqExpo.setICEProgramFilename   ("%CustomerIceProgs%\\IceProgActuationCloseLoopV2");    // We Only Use MRI for gradient
    rSeqExpo.setICEProgramParam(ICE_PROGRAM_PARA_SHOW_OFFLINE, SEQ::SO_SHOW_NO);

    return (lStatus);
}

//. -------------------------------------------------------------------------
//.. fSEQCheck: check lines at the border of k-space (gradient overflow, GSWD)
//. -------------------------------------------------------------------------
NLSStatus MiniFlash::check(MrProt &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo, SEQCheckMode * /*pSEQCheckMode*/)
{
    
    static const char *ptModule = {"MiniFlash::check"};
    NLS_STATUS   lStatus = SEQU__NORMAL;
    long        lL                = 0;
    long        alLCk[4]          = {0, 1, rSeqExpo.getMeasuredPELines() - 2, rSeqExpo.getMeasuredPELines() - 1};
    while (lL < 4 )
    {
        OnErrorReturn(runKernel(rMrProt,rSeqLim,rSeqExpo,KERNEL_CHECK,0, 0, alLCk[lL]));
        lL++;
    }
    return(lStatus);
}

//. -------------------------------------------------------------------------
//.. fSEQRun: run the sequence
//. -------------------------------------------------------------------------
NLSStatus MiniFlash::run(MrProt  &rMrProt, SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo)
{
    static const char *ptModule = {"MiniFlash::run"};
    NLS_STATUS lStatus          = SEQU__NORMAL;
	long n_rep;
    //. Initialize sequence test
    if(IS_UNIT_TEST_ACTIVE(rSeqLim))
    {
        mSEQTest(rMrProt,rSeqLim,rSeqExpo,RTEB_ORIGIN_fSEQRunStart,0,0,0,0,0);
    }
    long lLine;
	long lCurrKernelCalls = 0;

    //. Send the delay between measurements
    //OnErrorReturn(fSBBMeasRepetDelaysRun ( rMrProt, rSeqLim, rSeqExpo, 0 ));

    if(IS_UNIT_TEST_ACTIVE(rSeqLim))
    {
        mSEQTest (rMrProt, rSeqLim, rSeqExpo, RTEB_ClockInitTR, 0, 0, m_asSLC[0].getSliceIndex(), 0, 0);
    }

	m_sADCX.getMDH().setFreeParameterByIndex(1,0); 
	m_sADCY.getMDH().setFreeParameterByIndex(1,0); // 2 means y-axis

	//m_sADCY.getMDH().setReadOutOffcentre(9.8);

	//n_rep = abs(m_WIPParamTool.getLongValue (rMrProt, WIPLongN1))+abs(m_WIPParamTool.getLongValue (rMrProt, WIPLongN2));
	long biggest = m_c1;
	if (m_c2 > biggest)
		biggest = m_c2;
	if (m_c3 > biggest)
		biggest = m_c3;

	n_rep = biggest;
	//cout << "repetition = " << n_rep << endl;
    for( lLine=0; lLine<n_rep; lLine++ )    
    {
		lCurrKernelCalls++;

        // Call Kernel function
        OnErrorReturn(runKernel(rMrProt, rSeqLim,
            rSeqExpo,KERNEL_IMAGE,0, 0, lLine));
    }
    if(IS_UNIT_TEST_ACTIVE(rSeqLim))
    {
        mSEQTest(rMrProt,rSeqLim,rSeqExpo,RTEB_ORIGIN_fSEQRunFinish,0,0,0,0,0);
    }
    return(SEQU__NORMAL);
}


//. -------------------------------------------------------------------------
//.. runKernel
//. -------------------------------------------------------------------------
NLS_STATUS MiniFlash::runKernel(MrProt &rMrProt, SeqLim &rSeqLim,
								MrProtocolData::SeqExpo &rSeqExpo, long lKernelMode, long /* lSlice */, long /* lPartition */, long lLine)
{
	static const char *ptModule = {"MiniFlash::runKerenl"};
	NLS_STATUS         lStatus  = SEQU__NORMAL;
	long lT;

	double offsetTime = 0.0;
    //. Prepare FrequencyPhase objects of the RF pulse
    m_sSRF01zSet.prepSet (m_asSLC[0], m_sSRF01) ;
    m_sSRF01zNeg.prepNeg (m_asSLC[0], m_sSRF01) ;

	//m_sSRF01zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	//m_sSRF01zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));

	m_sSRF02zSet.prepSet (m_asSLC[0], m_sSRF02) ;
    m_sSRF02zNeg.prepNeg (m_asSLC[0], m_sSRF02) ;

	//m_sSRF02zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	//m_sSRF02zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));

    /* -------------------------------------------------------- */
    /* Set the frequency/phase properties of the readout events */
    /* -------------------------------------------------------- */
    m_sADCX.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCX.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCX.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCX.getMDH().setFreeParameterByIndex(0,1); // 1 means x-axis
	//m_sADCX.getMDH().setFreeParameterByIndex(2,m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane)); // send the plane to the ICE
	//m_sADCX.getMDH().setFreeParameterByIndex(3,(((long)(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoublePeriod)*1000000) /10)/GRAD_RASTER_TIME) * GRAD_RASTER_TIME); // send the period to the ICE

	m_sADCX_zSet.prepSet (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCX_zNeg.prepNeg (m_asSLC[0], m_sADCX, m_sGradRO) ;   /*! EGA-06 !*/

	//m_sADCX_zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	//m_sADCX_zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));

	m_sADCY.getMDH().addToEvalInfoMask(MDH_RTFEEDBACK);
	m_sADCY.getMDH().setKSpaceCentreLineNo((unsigned short) rMrProt.kSpace().echoLine());
	m_sADCY.getMDH().setKSpaceCentrePartitionNo(0);
	m_sADCY.getMDH().setFreeParameterByIndex(0,2); // 2 means y-axis
	//m_sADCY.getMDH().setFreeParameterByIndex(2,m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane)); // send the plane to the ICE
	//m_sADCY.getMDH().setFreeParameterByIndex(3,(((long)(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoublePeriod)*1000000) /10)/GRAD_RASTER_TIME) * GRAD_RASTER_TIME); // send the period to the ICE

	m_sADCY_zSet.prepSet (m_asSLC[0], m_sADCY, m_sGradRO) ;   /*! EGA-06 !*/
    m_sADCY_zNeg.prepNeg (m_asSLC[0], m_sADCY, m_sGradRO) ;   /*! EGA-06 !*/

	//m_sADCY_zSet.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	//m_sADCY_zNeg.setFrequency(m_WIPParamTool.getDoubleValue (rMrProt, WIPDoubleFreqOffset));
	
	
	//Apply Rotation Matrix  
    applyRotMatrix(m_WIPParamTool.getSelectionValue(rMrProt, WIPSelectionPlane));

	//. Initialize real time event block with actual rotation matrix
	fRTEBInit( m_asSLC[0].getROT_MATRIX());
		// Affichage de la Rot_MAtrix
	lT = 0;

	/*
	//if(lLine < abs(m_WIPParamTool.getLongValue (rMrProt, WIPLongN1)))
	if(m_c3 > 0)
	{
		//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
		//- *                             Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
		//- *                               (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
		//- *fRTEI(                                                    ,              ,          ,          ,                ,              ,                ,      );
		//- **********************************************************************************************************************************************************
		if(lLine < m_c3)
		{
			//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
			//- *                             Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
			//- *                               (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
			//- *fRTEI(                                                    ,              ,          ,          ,                ,              ,                ,      );
			//- **********************************************************************************************************************************************************

			fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuate1,   0,               0,    &m_sWakeUp );
			lT+= m_sGActuate1.getTotalTime() + m_WIPParamTool.getDoubleValue (rMrProt, WIPDbleTOFF)*MILLI_TO_MICROSECONDS ;
			fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuate1,   0,               0,    0 );
			lT+= m_sGActuate1.getTotalTime() + m_WIPParamTool.getDoubleValue (rMrProt, WIPDbleTOFF)*MILLI_TO_MICROSECONDS ;
			fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuate1,   0,               0,    0 );
			lT+= m_sGActuate1.getTotalTime() + m_WIPParamTool.getDoubleValue (rMrProt, WIPDbleTOFF)*MILLI_TO_MICROSECONDS ;
			fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuate2,   0,               0,    0 );
			lT+= m_sGActuate2.getTotalTime() + m_WIPParamTool.getDoubleValue (rMrProt, WIPDbleTOFF)*MILLI_TO_MICROSECONDS ;
			fRTEI ( lT                                                     ,             0,         0,         0,  0,   0,               0,    0 );
		}
		else
		{
			//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
			//- *                             Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
			//- *                               (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
			//- *fRTEI(                                                    ,              ,          ,          ,                ,              ,                ,      );
			//- **********************************************************************************************************************************************************

			fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuate1,   0,               0,    &m_sWakeUp );
			lT+= m_sGActuate1.getTotalTime() + m_WIPParamTool.getDoubleValue (rMrProt, WIPDbleTOFF)*MILLI_TO_MICROSECONDS ;
			fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuate1,   0,               0,    0 );
			lT+= m_sGActuate1.getTotalTime() + m_WIPParamTool.getDoubleValue (rMrProt, WIPDbleTOFF)*MILLI_TO_MICROSECONDS ;
			fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuate2,   0,               0,    0 );
			lT+= m_sGActuate2.getTotalTime() + m_WIPParamTool.getDoubleValue (rMrProt, WIPDbleTOFF)*MILLI_TO_MICROSECONDS ;
			fRTEI ( lT                                                     ,             0,         0,         0,  0,   0,               0,    0 );
		}

	}
	else if (m_c2 > 0)
	{
		//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
		//- *                             Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
		//- *                               (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
		//- *fRTEI(                                                    ,              ,          ,          ,                ,              ,                ,      );
		//- **********************************************************************************************************************************************************
		if(lLine < m_c2)
		{
			//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
			//- *                             Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
			//- *                               (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
			//- *fRTEI(                                                    ,              ,          ,          ,                ,              ,                ,      );
			//- **********************************************************************************************************************************************************

			fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuate1,   0,               0,    &m_sWakeUp );
			lT+= m_sGActuate1.getTotalTime() + m_WIPParamTool.getDoubleValue (rMrProt, WIPDbleTOFF)*MILLI_TO_MICROSECONDS ;
			fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuate1,   0,               0,    0 );
			lT+= m_sGActuate1.getTotalTime() + m_WIPParamTool.getDoubleValue (rMrProt, WIPDbleTOFF)*MILLI_TO_MICROSECONDS ;
			fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuate2,   0,               0,    0 );
			lT+= m_sGActuate2.getTotalTime() + m_WIPParamTool.getDoubleValue (rMrProt, WIPDbleTOFF)*MILLI_TO_MICROSECONDS ;
			fRTEI ( lT                                                     ,             0,         0,         0,  0,   0,               0,    0 );
		}
		else
		{
			//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
			//- *                             Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
			//- *                               (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
			//- *fRTEI(                                                    ,              ,          ,          ,                ,              ,                ,      );
			//- **********************************************************************************************************************************************************
			
			fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuate1,   0,               0,    &m_sWakeUp );
			lT+= m_sGActuate1.getTotalTime() + m_WIPParamTool.getDoubleValue (rMrProt, WIPDbleTOFF)*MILLI_TO_MICROSECONDS ;
			fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuate2,   0,               0,    0 );
			lT+= m_sGActuate2.getTotalTime() + m_WIPParamTool.getDoubleValue (rMrProt, WIPDbleTOFF)*MILLI_TO_MICROSECONDS ;
			fRTEI ( lT                                                     ,             0,         0,         0,  0,   0,               0,    0 );
		}
	}
	else
	{
		//- ***************************************************** S E Q U E N C E   T I M I N G **********************************************************************
		//- *                             Start Time                   |      NCO     |    SRF   |    ADC   |                Gradient Events                 | Sync
		//- *                               (usec)                     |     Event    |   Event  |   Event  |      phase     |     read     |      slice     | Event
		//- *fRTEI(                                                    ,              ,          ,          ,                ,              ,                ,      );
		//- **********************************************************************************************************************************************************
		
		fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuate1,   0,               0,    &m_sWakeUp );
		lT+= m_sGActuate1.getTotalTime() + m_WIPParamTool.getDoubleValue (rMrProt, WIPDbleTOFF)*MILLI_TO_MICROSECONDS ;
		fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuate2,   0,               0,    0 );
		lT+= m_sGActuate2.getTotalTime() + m_WIPParamTool.getDoubleValue (rMrProt, WIPDbleTOFF)*MILLI_TO_MICROSECONDS ;
		fRTEI ( lT                                                     ,             0,         0,         0,  0,   0,               0,    0 );

	}

	*/

	if(m_c1 > 0)
	{
		fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuate1,   0,               0,    &m_sWakeUp );
		lT+= m_sGActuate1.getTotalTime() + m_WIPParamTool.getDoubleValue (rMrProt, WIPDbleTOFF)*MILLI_TO_MICROSECONDS ;
		fRTEI ( lT                                                     ,             0,         0,         0,  0,   0,               0,    0 );
		if(lKernelMode == KERNEL_IMAGE)
			m_c1 -= 1;
	}
	if(m_c2 > 0)
	{
		fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuate2,   0,               0,    &m_sWakeUp );
		lT+= m_sGActuate2.getTotalTime() + m_WIPParamTool.getDoubleValue (rMrProt, WIPDbleTOFF)*MILLI_TO_MICROSECONDS ;
		fRTEI ( lT                                                     ,             0,         0,         0,  0,   0,               0,    0 );
		if(lKernelMode == KERNEL_IMAGE)
			m_c2 -= 1;
	}

	if(m_c3 > 0)
	{
		fRTEI ( lT                                                     ,             0,         0,         0,  &m_sGActuate3,   0,               0,    &m_sWakeUp );
		lT+= m_sGActuate3.getTotalTime() + m_WIPParamTool.getDoubleValue (rMrProt, WIPDbleTOFF)*MILLI_TO_MICROSECONDS ;
		fRTEI ( lT                                                     ,             0,         0,         0,  0,   0,               0,    0 );
		if(lKernelMode == KERNEL_IMAGE)
			m_c3 -= 1;
	}
	//cout << "c1 " << m_c1 << "; c2 " << m_c2 << "; c3 " << m_c3 <<endl;
	//. End real time event block
	OnErrorReturn((NLS_STATUS)fRTEBFinish());
	fRTWaitForWakeup();

	m_sFeedbackSemaphore.acquire();

	m_sFeedbackSemaphore.release();
	if(m_feedbackReceived == true){
		UTRACE (Debug, iUTraceMarker, "**************************************************************** " );
		UTRACE (Debug, iUTraceMarker, "Feedback successfully received");
		UTRACE (Debug, iUTraceMarker, "**************************************************************** " );
#ifdef WIN32
		cout << "****************************************************************************" << endl;
		cout << "\nFeedback successfully received\n" ;
		cout << "****************************************************************************" << endl;
#endif
	}
	else{
		UTRACE (Debug, iUTraceMarker, "**************************************************************** " );
		UTRACE (Debug, iUTraceMarker, "Feedback successfully received");
		UTRACE (Debug, iUTraceMarker, "**************************************************************** " );
#ifdef WIN32
		cout << "****************************************************************************" << endl;
		cout << "\nFeedback NOT received\n" ;
		cout << "****************************************************************************" << endl;
#endif
	}

	if(m_feedbackReceived == true)
	{
		m_feedbackReceived = false;
	}
	//. Call sequence unit test
	if(IS_UNIT_TEST_ACTIVE(rSeqLim))
	{
		if (lKernelMode == KERNEL_CHECK)
			mSEQTest(rMrProt, rSeqLim, rSeqExpo, RTEB_ORIGIN_fSEQCheck,  10, lLine, m_asSLC[0].getSliceIndex(), 0, 0);
		else
			mSEQTest(rMrProt, rSeqLim, rSeqExpo, RTEB_ORIGIN_fSEQRunKernel,10,lLine,m_asSLC[0].getSliceIndex(), 0, 0);
		mSEQTest    (rMrProt, rSeqLim, rSeqExpo, RTEB_ClockCheck,        10, lLine, m_asSLC[0].getSliceIndex(), 0, 0);
	}


	return(lStatus);
}


NLSStatus MiniFlash::receive(SeqLim &rSeqLim, MrProtocolData::SeqExpo &rSeqExpo, SEQData& rSEQData)
{
	static const char *ptModule = {"MiniFlash::receive"};
	NLSStatus         lStatus  = SEQU__NORMAL;

	double durationTab[5] = {2, 0.75, 1, 0.5, 0.25};
	double durationSin;
	double free3 = 99.9;
	double free2 = 55.77;
	m_feedbackReceived = true;

	m_sFeedbackSemaphore.acquire();

	m_sADCX.getMDH().setFreeParameterByIndex(1,++m_loop_test); 
	m_sADCY.getMDH().setFreeParameterByIndex(1,m_loop_test); // 2 means y-axis


	FBData fbData;
	fbData = *(FBData*) rSEQData.getData();

	m_sFeedbackSemaphore.release();

	UTRACE (Debug, iUTraceMarker, "*************************** OUFEL ************************** " );
	UTRACE (Debug, iUTraceMarker, "Entering RECEIVE FUNCTION ");
	UTRACE (Debug, iUTraceMarker, "**************************** OUFEL **************************** " );
#ifdef WIN32
		cout << "****************************************************************************" << endl;
		cout << "Entering RECEIVE FUNCTION " << endl;
		cout << "****************************************************************************" << endl;
#endif

	//--------------------------------------------------------------------------------------------
	// Reserve Semaphore HERE
	//--------------------------------------------------------------------------------------------
	if(strcmp(rSEQData.getID(),"MRIR"))
	{
		UTRACE (Debug, iUTraceMarker, "**************************************************************** " );
		UTRACE (Debug, iUTraceMarker, "Feedback data in " << ptModule << " has wrong ID " << rSEQData.getID());
		UTRACE (Debug, iUTraceMarker, "**************************************************************** " );
#ifdef WIN32
		cout << "****************************************************************************" << endl;
		cout << "Feedback data in " << ptModule << " has wrong ID " << rSEQData.getID() <<endl;
		cout << "****************************************************************************" << endl;
#endif
	}

	if (fbData.lShot == 1)
		m_isRotorCenterAndRaduisFound = true;

	UTRACE (Debug, iUTraceMarker, "*************************** OUFEL ************************** " );
	UTRACE (Debug, iUTraceMarker, "DATA received " << fbData.lSlot << " and " << fbData.lShot);
	UTRACE (Debug, iUTraceMarker, "**************************** OUFEL **************************** " );
#ifdef WIN32
	cout << "****************************************************************************" << endl;
	cout << "Feedback data in " << ptModule << " has wrong ID " << rSEQData.getID() <<endl;
	cout << "****************************************************************************" << endl;
#endif


	return lStatus;

}
NLS_STATUS MiniFlash::createUI (SeqLim&)
{
	static const char *ptModule = {"MiniFlash::createUI"};
    #ifdef WIN32

        

        //  ----------------------------------------------------------------------
        //  Delete existing instance if necessary
        //  ----------------------------------------------------------------------
        if(m_pUI)  {
            delete m_pUI;
            m_pUI = NULL;
        }



        //  ----------------------------------------------------------------------
        //  Instantiation of the UI class
        //  ----------------------------------------------------------------------
        try  {
            m_pUI = new MiniFlashUI();
        }

        catch (...)  {
            delete m_pUI;
            m_pUI = NULL;

            TRACE_PUT1(TC_ALWAYS, TF_SEQ,"%s: Cannot instantiate UI class !", ptModule);
            return ( SEQU_ERROR );
        }

    #endif

    return ( SEQU_NORMAL );

}   // end: MiniFlash::createUI



const MiniFlashUI* MiniFlash::getUI (void) const
{
    return ( m_pUI );
}

// --------------------------------------------------------------------------------------------
///  \brief    This method apply a rotation matrix 
///
///
///  \param    axis : A value set by the user interface card      
///
///  \return   NONE
// --------------------------------------------------------------------------------------------
void MiniFlash::applyRotMatrix(long axis)
{
	sROT_MATRIX mat;
	switch (axis){
		case X_X:
			mat.dMat[0][0] = 1; 
			mat.dMat[0][1] = 0;
			mat.dMat[0][2] = 0;

			mat.dMat[1][0] = 0;
			mat.dMat[1][1] = 1;
			mat.dMat[1][2] = 0;

			mat.dMat[2][0] = 0;
			mat.dMat[2][1] = 0;
			mat.dMat[2][2] = 1;
			break;
		case Y_Y:
			mat.dMat[0][0] = 0; 
			mat.dMat[0][1] = -1;
			mat.dMat[0][2] = 0;

			mat.dMat[1][0] = 1;
			mat.dMat[1][1] = 0;
			mat.dMat[1][2] = 0;

			mat.dMat[2][0] = 0;
			mat.dMat[2][1] = 0;
			mat.dMat[2][2] = 1;
			break;
		case Z_Z:
			mat.dMat[0][0] = 0; 
			mat.dMat[0][1] = 0;
			mat.dMat[0][2] = -1; 

			mat.dMat[1][0] = 0;
			mat.dMat[1][1] = 1;
			mat.dMat[1][2] = 0;

			mat.dMat[2][0] = 1;
			mat.dMat[2][1] = 0;
			mat.dMat[2][2] = 0;
			break;

		default:
			break;
	}
	m_asSLC[0].setROT_MATRIX(mat);
}